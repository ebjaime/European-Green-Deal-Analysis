---
title: "NPS_project"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TITLE
TODO: Rerun everything
Load necessary libraries:

```{r}
# General
library(openxlsx)
library(MASS)
library(progress)
library(np)
library(splines)
library(devtools)
library(tidyr)
# Depth
#library(DepthProc)
#library(robustbase)
# Functional data
library(roahd)
library(fda)
library(fdatest)
# Graphics packages
library(rgl)
library(hexbin)
library(ggplot2)
library(rgl)
library(corrplot)
# GAM
library(mgcv)
# Conformal
library(conformalInference)


B=100000
seed=42
```

### Preprocessing of data

Auxiliary functions for preprocessing of data:

```{r}

# 1000 Tons Of Oil Equivalent to Terajoules = 41.1868
tto_2_tj <- function(tto) {
    return(tto * 41.868)
}

# Function cleans df removing NAN rows, setting values as numeric...
preprocess <- function(df, start_nrows=6, end_nrows=2, tj=T) { 
    
    # Remove first rows not containing significant data
    df <- df[-c(1:start_nrows,(dim(df)[1]-(end_nrows-1)):dim(df)[1]),]
    
    rownames(df) <- df[,1]
    df <- df[,-1]
    
    rownames(df)[1] <- "year"
    
    # Remove rows with NA values 
    df <- df[!df[,1]==':',]
    
    
    # 3 decimals
    df[] <- lapply(df, as.numeric)  
    
    if(!tj) # All data should be converted to Terajoules
        df[-1,] <- lapply(df[-1,], tto_2_tj)
    
    return(df)
}
```


In our script "preprocessing_SSP.rmd", we have additional code regarding the transformation of data of the SSP original data to fit our needs and located in "data/ssp_iiasa_YtY_gdp.xlsx" & "data/ssp_iiasa_YtY_pop.xlsx".



# Starting Point: Analysis of current European Renewable Transition


Loading necessary datasets. In energy balances we dont have the value Final Consumption (FC), but it can be estimated as sum of several.

```{r}
energy.balances.1  <- read.xlsx("data/complete_energy_balances.xlsx",sheet=1) # Gross available energy, first sheet should be the best

consump.fossils  <- read.xlsx("data/consumption_solid_fossil_fuels.xlsx",sheet=1) # Inland consumption
consump.gas      <- read.xlsx("data/consumption_gas.xlsx",sheet=1) # Inland consumption
consump.oil.petr <- read.xlsx("data/consumption_oil_petroleum.xlsx",sheet=1) # Inland consumption

consump.renew.1  <- read.xlsx("data/consumption_renewables.xlsx",sheet=1) # Geothermal, inland consump
consump.renew.2  <- read.xlsx("data/consumption_renewables.xlsx",sheet=2) # Solar thermal, inland consump.
consump.renew.3  <- read.xlsx("data/consumption_renewables.xlsx",sheet=3) # Biofuels, inland consump.
consump.renew.4  <- read.xlsx("data/consumption_renewables.xlsx",sheet=4) # Biogases, inland consump.
consump.renew.5  <- read.xlsx("data/consumption_renewables.xlsx",sheet=5) # Renewable waste, inland consump.

percent.renew <- read.xlsx("data/percentage_renewables.xlsx") 

prod.by.fuel <- read.xlsx("data/production_capacities_by_fuel.xlsx")
```

We will now preprocess all datasets with our auxilary function. We will also compute the total Renewable energy's consumption levels by summing all the consumptions for all types of Renewable sources.

```{r}

energy.balances.p <- preprocess(energy.balances.1, tj=F)

consump.fossils.p <- preprocess(consump.fossils[,-32], tj=T) # wo 2020

consump.fossils.p[-1,] <- consump.fossils.p[-1,] * 25 #  Calorific power of FF
                                 
consump.oil.petr.p <- preprocess(consump.oil.petr[,-32], tj=F) # wo 2020
consump.gas.p      <- preprocess(consump.gas[,-32], tj=T) # wo 2020


consump.renew.1.p <- preprocess(consump.renew.1[,-32])
consump.renew.2.p <- preprocess(consump.renew.2[,-32])
consump.renew.3.p <- preprocess(consump.renew.3[,-32])
consump.renew.4.p <- preprocess(consump.renew.4[,-32])
consump.renew.5.p <- preprocess(consump.renew.5[,-32])

consump.renew.p <- consump.renew.1.p # Sum of all renewable energies
consump.renew.p[-1,] <- consump.renew.p[-1,] + consump.renew.2.p[-1,] + consump.renew.3.p[-1,] +
    consump.renew.4.p[-1,] + consump.renew.5.p[-1,]


```

We can check what we obtain in total:

```{r}
consump.total.p <-  consump.renew.p[2,1] +
                    consump.oil.petr.p[2,1] +
                    consump.fossils.p[2,1] +
                    consump.gas.p[2,1]
                    # derived.heat +
                    # electricity 
consump.total.p
```


To visualize the obtained data, we can plot the energy balances and consumption levels for two countries:

```{r}
p_italy <- ggplot(data=as.data.frame(t(energy.balances.p)), aes(x=year, y=Italy)) +
            labs(title="Energy Balances Progression - Italy", 
                 subtitle="Gross Available Energy") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="blue", colour="darkblue", size=1)
p_italy
```

```{r}
# Example of consumption of solid fossil fuels
p_sweden <- ggplot(data=as.data.frame(t(consump.fossils.p)), aes(x=year, y=Sweden)) + #plot of energy balance or consumption of solid fossil fuels?
            labs(title="Consumption Solid Fossil Fuels - Sweden", 
                 subtitle="Inland consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="red", colour="darkred", size=1)
p_sweden

```

We will also create some auxiliary variables & datasets, so it is easier to follow what we are doing. 
```{r}
year.min       <- min(energy.balances.p[1,])
year.max       <- max(energy.balances.p[1,])
year.grid      <- seq(year.min, year.max)

countries.list <- rownames(consump.fossils.p[-c(1,2,3,4),]) 

# Removal of total EU levels on all datasets 
energy.balances.countries  <- energy.balances.p[-c(1,2,3,4),]
consump.fossils.countries  <- consump.fossils.p[-c(1,2,3,4),]
consump.oil.petr.countries <- consump.oil.petr.p[-c(1,2,3,4),]
consump.gas.countries      <- consump.gas.p[-c(1,2,3,4),]
consump.renew.countries    <- consump.renew.p[-c(1,2,3,4),]

colnames(energy.balances.countries) <- NULL
colnames(consump.fossils.countries) <- NULL
colnames(consump.oil.petr.countries) <- NULL
colnames(consump.gas.countries) <- NULL
colnames(consump.renew.countries) <- NULL
```

We obtain the differences year to year for each 
```{r}
energy.balances.diff <- energy.balances.p[-1,-length(energy.balances.p)] - energy.balances.p[-1,-1]
consump.fossils.diff <- consump.fossils.p[-1,-length(consump.fossils.p)] - consump.fossils.p[-1,-1]
consump.oil.petr.diff <- consump.oil.petr.p[-1,-length(consump.oil.petr.p)] - consump.oil.petr.p[-1,-1]
consump.gas.diff <- consump.gas.p[-1,-length(consump.gas.p)] - consump.gas.p[-1,-1]
consump.renew.diff <- consump.renew.p[-1,-length(consump.renew.p)] - consump.renew.p[-1,-1]

energy.balances.diff <- rbind(year=seq(1991, 2019), energy.balances.diff)
consump.fossils.diff <- rbind(year=seq(1991, 2019), consump.fossils.diff)
consump.oil.petr.diff <- rbind(year=seq(1991, 2019), consump.oil.petr.diff)
consump.gas.diff <- rbind(year=seq(1991, 2019), consump.gas.diff)
consump.renew.diff <- rbind(year=seq(1991, 2019), consump.renew.diff)
```


We can divide this section into three points.

## 1. What is the trend of renewable and non-renewable consumptions.


We can visualize the consumption levels of all EU countries.

Via time series visualization:
```{r}
matplot(seq(year.min, year.max), t(energy.balances.countries), type="l", lty=1,
        main="Energy Balances EU 1990 - 2019", xlab="Year", ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.fossils.countries), type="l", lty=1,
        main="Consumption of solid fossil fuels EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.oil.petr.countries), type="l", lty=1,
        main="Consumption of Oil and Petroleum EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.gas.countries), type="l", lty=1,
        main="Consumption of Natural Gas EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.renew.countries), type="l", lty=1,
        main="Consumption of RE EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")
```

Via boxplot:
```{r}
boxplot(energy.balances.countries, main="Boxplot Energy Balances", xlab="Countries", 
        ylab="Terajoules")

boxplot(consump.fossils.countries, main="Boxplot of Consumption of Solid Fossil Fuels", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.oil.petr.countries, main="Boxplot of Consumption of Oil and Petroleum", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.gas.countries, main="Boxplot of Consumption of Natural Gas", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.renew.countries, main="Consumption of Renewables", xlab="Countries", 
        ylab="Terajoule")
```


First let us check for normality with a simple Shapiro-Wilk test.

Let us visualize a random country from the dataset and check whether it might be normaly distributed:

```{r}

index.italy <- which(rownames(consump.renew.countries) == c("Italy"))
hist(t(consump.fossils.countries)[,index.italy])
hist(t(consump.oil.petr.countries)[,index.italy])
hist(t(consump.gas.countries)[,index.italy])
hist(t(consump.renew.countries)[,index.italy])

```

Now to check the distribution of p-values obtained with a Shapiro-Wilk test:
```{r}

p.values.ff <- numeric(length(countries.list)) # Fossil fuels
p.values.op <- numeric(length(countries.list)) # Oil&Petr.
p.values.ng <- numeric(length(countries.list)) # Natural gas 
p.values.re <- numeric(length(countries.list)) # RE
for(c in 1:length(countries.list)){
    p.values.ff[c] <- shapiro.test(t(consump.fossils.countries)[,c])$p.value
    p.values.op[c] <- shapiro.test(t(consump.oil.petr.countries)[,c])$p.value
    p.values.ng[c] <- shapiro.test(t(consump.gas.countries)[,c])$p.value # Ignore errors
    p.values.re[c] <- shapiro.test(t(consump.renew.countries)[,c])$p.value


    
}
hist(p.values.ff) # Shapiro-Wilk test might fail with small n values
hist(p.values.op) # Shapiro-Wilk test might fail with small n values
hist(p.values.ng) # Shapiro-Wilk test might fail with small n values
hist(p.values.re) # Shapiro-Wilk test might fail with small n values
```

### Permutational Two Population MV test - Comparing Consumption distributions

We want to compare the distributions of NR vs R fuels for each country:
```{r}
consump.fossils.mean <- colMeans(consump.fossils.countries, na.rm=T)
consump.oil.petr.mean <- colMeans(consump.oil.petr.countries, na.rm=T)
consump.gas.mean <- colMeans(consump.gas.countries, na.rm=T)
consump.renew.mean <- colMeans(consump.renew.countries, na.rm=T)

matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean,
                                       consump.renew.mean)),
        type="l",main="Consumption means for each type of fuel",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(consump.fossils.mean)[2]+300000))

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas","Renewable Energies"), col=1:4, pch=2)


```

Renewable consumption and Fossil Fuels are very different from oil & petr. and natural gas consumption.
But do these last two follow the same distribution?


```{r}

# H0: Distributions are equal
# H1: Distributions are not equal

# NG vs OP ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.gas.mean))[1]
n2 <- dim(as.matrix(consump.oil.petr.mean))[1]
n  <- n1 + n2

# Test statistic
T10 <- as.numeric((consump.gas.mean-consump.oil.petr.mean) %*% (consump.gas.mean-consump.oil.petr.mean))
T10

# Permutational distribution
T1 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled = rbind(consump.gas.countries, consump.oil.petr.countries)
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm, na.rm = T)
    t2.mean_perm = colMeans(t2_perm, na.rm = T)
    T1[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T1,xlim=range(c(T1,T10)))
abline(v=T10,col=3,lwd=4)

plot(ecdf(T1))
abline(v=T10,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T1>=T10)/B
p_val

```

```{r}

# FF vs OP ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.fossils.mean))[1]
n2 <- dim(as.matrix(consump.oil.petr.mean))[1]
n  <- n1 + n2

# Test statistic
T20 <- as.numeric((consump.fossils.mean-consump.oil.petr.mean) %*% (consump.fossils.mean-consump.oil.petr.mean))
T20

# Permutational distribution
T2 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled = rbind(consump.fossils.countries, consump.oil.petr.countries)
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm, na.rm = T)
    t2.mean_perm = colMeans(t2_perm, na.rm = T)
    T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T2,xlim=range(c(T2,T20)))
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T2>=T20)/B
p_val

```


What about using year-to-year variates? Does the renew. consumption follow the same distribution as fossils or oil & petr. consumption?
```{r}

# RE vs OP ----------------------------------------------------------------
# Use year by year change of each energy (RE vs OP (or NG or FF))

mean.consump.nonrenew <- ( consump.fossils.countries[,]+consump.gas.countries[,]+consump.oil.petr.countries[,] )/3
mean.consump.nonrenew.mean=colMeans(mean.consump.nonrenew)

matplot(seq(year.min, year.max), t(rbind(mean.consump.nonrenew.mean,
                                         consump.renew.mean)),
        type="l",main="Consumption means renewables vs non-renewables",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(mean.consump.nonrenew.mean)[2]+300000),col=c(1,3),lty=c(1,1))
legend("topright",legend=c("Non-renewable sources","Renewable sources"),col=c(1,3),pch=2)


mean.consump.nonrenew.diff <- mean.consump.nonrenew[,-length(mean.consump.nonrenew)] - mean.consump.nonrenew[,-1] #"inverse" deltas to obtain growing curve differences
consump.renew.diff <- consump.renew.countries[,-1] - consump.renew.countries[,-length(consump.renew.countries)]

mean.consump.nonrenew.diff.mean <- colMeans(mean.consump.nonrenew.diff, na.rm=T)
consump.renew.diff.mean <- colMeans(consump.renew.diff, na.rm=T)

matplot(seq(year.min+1,year.max), consump.renew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Renewable consumptions year to year average deltas",col="green")
matlines(seq(year.min+1,year.max), mean.consump.nonrenew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Mean non-renewable consumptions year to year inverse average deltas")


n1 <- dim(as.matrix(consump.renew.diff))[1]
n2 <- dim(as.matrix(mean.consump.nonrenew.diff))[1]
n  <- n1 + n2

# Test statistic
T30 <- as.numeric((consump.renew.diff.mean-mean.consump.nonrenew.diff.mean) %*% (consump.renew.diff.mean-mean.consump.nonrenew.diff.mean))
T30

# Permutational distribution
T3 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled <- cbind(consump.renew.diff,mean.consump.nonrenew.diff)
    permutation <- sample(n)
    t_perm <- t_pooled[permutation,]
    t1_perm <- t_perm[1:n1,]
    t2_perm <- t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm <- colMeans(t1_perm, na.rm = T)
    t2.mean_perm <- colMeans(t2_perm, na.rm = T)
    T3[perm]  <- (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T3,xlim=range(c(T3,T30)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T30,col=3,lwd=4)

plot(ecdf(T3),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T30,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T3>=T30)/B
p_val

```


###  Two way permutational ANOVA - Oil & Petr. consumption + Renewables to represent Energy Balances 

For each country we obtain a diff. ANOVA. E.g. Belgium:
```{r}
aov_Belgium <- aov(energy.balances.countries$Belgium ~ consump.oil.petr.countries$Belgium +       #are these factors? Maybe a linear model should make more sense
                                        consump.renew.countries$Belgium +
                                        consump.renew.countries$Belgium:consump.oil.petr.countries$Belgium)

summary(aov_Belgium)
```

We could repeat the same procedure for the total levels of the 27 EU countries:
```{r}
aov_EU <- aov(energy.balances.p$`European Union - 27 countries (from 2020)` ~
                  consump.oil.petr.p$`European Union - 27 countries (from 2020)`[-1] + 
                  consump.renew.p$`European Union - 27 countries (from 2020)`[-1] +
                  consump.renew.p$`European Union - 27 countries (from 2020)`[-1]:
                  consump.oil.petr.p$`European Union - 27 countries (from 2020)`[-1])
summary(aov_EU)

```

With this in mind, we could test if the relation bw Renewable and Non-Renewable can be ignored in a LM model.
```{r}
# H0: gamma = 0
# H1: gamma != 0
T0_oil_renew <- summary.aov(aov_EU)[[1]][3,4] # F-value
T0_oil_renew

# Compute the permutational distribution to calculate p-value
aov_EU.H0 <- aov(energy.balances.p$`European Union - 27 countries (from 2020)` ~
                  consump.oil.petr.p$`European Union - 27 countries (from 2020)`[-1] + 
                  consump.renew.p$`European Union - 27 countries (from 2020)`[-1])
aov_EU.H0

residuals_EU.H0 <- aov_EU.H0$residuals
n <- length(energy.balances.p$`European Union - 27 countries (from 2020)`) 


T_oil_renew <- numeric(B)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    permutation <- sample(n)
    residuals_EU.H0 <- residuals_EU.H0[permutation]
    energy.balances.perm.H0 <- aov_EU.H0$fitted + residuals_EU.H0
    T_oil_renew[perm] <- summary.aov(aov(energy.balances.perm.H0 ~ 
                                     consump.oil.petr.p$`European Union - 27 countries (from 2020)`[-1] + 
                                     consump.renew.p$`European Union - 27 countries (from 2020)`[-1] +
                                     consump.renew.p$`European Union - 27 countries (from 2020)`[-1]:
                                     consump.oil.petr.p$`European Union - 27 countries (from 2020)`[-1]))[[1]][3,4]
    pb$tick()
}

p_val <- sum(T_oil_renew >= T0_oil_renew)/B
p_val # Significant p-value

```


### Two sample paired MV test - Comparing Countries for diff. consumptions

 We can compare Italy's consumption of fossil fuels + renewables + petroleum vs Spain's.
 
```{r}
country1 <- "Spain"
country2 <- "Italy"
c12 <- c(country1, country2)
# Plot their respective boxplot's
boxplot(energy.balances.countries[c12],
        main="Boxplot Energy Balances", xlab="Countries", 
        ylab="Thousand tonnes of oil equivalent")

boxplot(consump.fossils.countries[c12],
        main="Boxplot of Consumption of Solid Fossil Fuels", xlab="Countries", 
        ylab="Thousand tonnes (solid fossil fuels)")

boxplot(consump.oil.petr.countries[c12],
        main="Boxplot of Consumption of Oil and Petroleum", xlab="Countries", 
        ylab="Thousand tonnes (oil and petroleum products)")

boxplot(consump.renew.countries[c12], 
        main="Consumption of Renewables", xlab="Countries", 
        ylab="Terajoule")

# Create matrices for each country
t1 <- cbind(energy.balances.countries[,country1], 
            consump.fossils.countries[,country1],  #quit -1
            consump.oil.petr.countries[,country1], #quit -1
            consump.renew.countries[,country1])    #quit -1

t2 <- cbind(energy.balances.countries[country2], 
            consump.fossils.countries[,country2],
            consump.oil.petr.countries[,country2],
            consump.renew.countries[,country2])
# Calculate means per consumption
t1.mean <- colMeans(t1)
t2.mean <- colMeans(t2)

p  <- dim(t1)[2] # Number of cols
n1 <- dim(t1)[1] # Number of rows
n2 <- dim(t2)[1] # Number of rows
n <- n1+n2

t1.cov  <-  cov(t1)
t2.cov  <-  cov(t2)
Sp      <- ((n1-1)*t1.cov + (n2-1)*t2.cov)/(n1+n2-2)
Spinv   <- solve(Sp)

delta.0 <- rep(0, p) # Assumed value for means 

diff <- t1-t2
diff.mean <- colMeans(diff)
diff.cov <- cov(diff)
diff.invcov <- solve(diff.cov)

# Computing the statistic
T30 <- as.numeric((diff.mean-delta.0)  %*% (diff.mean-delta.0))

# Permutational test
T3 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    # Random permutation
    signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
    
    diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
    diff.mean_perm <- colMeans(diff_perm)
    diff.cov_perm <- cov(diff_perm)
    diff.invcov_perm <- solve(diff.cov_perm)
    
    T3[perm] <- as.numeric((diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
    
    pb$tick()
}

# plotting the permutational distribution under H0
hist(T3,xlim=range(c(T2,T20)),breaks=100)
abline(v=T30,col=3,lwd=4)

plot(ecdf(T3))
abline(v=T30,col=3,lwd=4)

# p-value
p_val <- sum(T3>=T30)/B
p_val

```
 

## 2. How is electricity production coming from renewable sources growing?

Total electricity production

```{r}
tot_elec <- read.xlsx('data/total_electricity_use.xlsx')
# View(tot_elec)

tot_elec <- tot_elec[7:51,]    #quit useless rows
colnames(tot_elec) <- tot_elec[1,] #use years as columns names
tot_elec <- tot_elec[-1,] #first row now is useless
rownames(tot_elec) <- tot_elec[,1] #use countries as row names
tot_elec <- tot_elec[,c(-1,-18)] #first column is now useless and don't consider 2020

tot_elec <- tot_elec[!tot_elec[,1]==':',]
# View(tot_elec)

tot_elec[] <- lapply(tot_elec, as.numeric) #convert to numeric


matplot(colnames(tot_elec),t(tot_elec[4:39,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity production")
```

Production of electricity from renewables dataset

```{r}
use_renew_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=1)
# View(use_renew_elec)

use_renew_elec <- use_renew_elec[7:48,]    #quit useless rows
colnames(use_renew_elec) <- use_renew_elec[1,] #use years as columns names
use_renew_elec <- use_renew_elec[-1,] #first row now is useless
rownames(use_renew_elec) <- use_renew_elec[,1] #use countries as row names
use_renew_elec <- use_renew_elec[,-1] #first column is now useless

use_renew_elec <- use_renew_elec[!use_renew_elec[,16]==':',]
# View(use_renew_elec)

use_renew_elec[] <- lapply(use_renew_elec, as.numeric) #convert to numeric


matplot(colnames(use_renew_elec),t(use_renew_elec[4:40,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity from renewables")

```

Let's see which country is particularly above the others in total usage of renewables for electricity production

```{r}
rownames(use_renew_elec)[which.max(use_renew_elec[4:40,16])+3] #first three rows are total european statistics
```
Construct dataset with percentages of electricity coming from renewables
```{r}
elec_percentage <- tot_elec

for (j in 1:16){
  elec_percentage[,j] <- use_renew_elec[-34,j]/elec_percentage[,j]
  #34th row is Montenegro, which didn't survive preprocessing in the total electricity production dataset
}
# View(elec_percentage)
```

EU's percentage evolution

```{r}
x <- as.numeric(colnames(elec_percentage))
plot(x,as.numeric(elec_percentage[2,]),main="Percentage of electricity coming from renewable sources - EU",xlab="Year",ylab="Percentage",type="l")
points(x,as.numeric(elec_percentage[2,]),col="Green",lwd=3)
```


### MANOVA to compare the distributions from the three main types of RE for electricity consumption

Let's make a test to see if the three main renewable resources have the same distribution
(MANOVA)

```{r}
use_hydro_elec <-read.xlsx('data/use_renew_elec.xlsx',sheet=2)
use_wind_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=4)
use_solar_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=6)

#clean hydro
use_hydro_elec <- use_hydro_elec[7:48,]
colnames(use_hydro_elec) <- use_hydro_elec[1,]
use_hydro_elec <- use_hydro_elec[-1,]
rownames(use_hydro_elec) <- use_hydro_elec[,1]
use_hydro_elec <- use_hydro_elec[,-1]

use_hydro_elec <- use_hydro_elec[!use_hydro_elec[,16]==':',]

#clean wind
use_wind_elec <- use_wind_elec[7:48,]
colnames(use_wind_elec) <- use_wind_elec[1,]
use_wind_elec <- use_wind_elec[-1,]
rownames(use_wind_elec) <- use_wind_elec[,1]
use_wind_elec <- use_wind_elec[,-1]

use_wind_elec <- use_wind_elec[!use_wind_elec[,16]==':',]

#clean solar
use_solar_elec <- use_solar_elec[7:48,]
colnames(use_solar_elec) <- use_solar_elec[1,]
use_solar_elec <- use_solar_elec[-1,]
rownames(use_solar_elec) <- use_solar_elec[,1]
use_solar_elec <- use_solar_elec[,-1]

use_solar_elec <- use_solar_elec[!use_solar_elec[,16]==':',]

use_hydro_elec[] <- lapply(use_hydro_elec, as.numeric)
use_wind_elec[] <- lapply(use_wind_elec, as.numeric)
use_solar_elec[] <- lapply(use_solar_elec, as.numeric)


use_principal <- rbind(use_hydro_elec[4:40,],use_wind_elec[4:40,],use_solar_elec[4:40,])

#factor vector
source <- c(rep("Hydro",37),rep("Wind",37),rep("Solar",37))
source <- factor(source)
```

Obtain differences year to year from these datasets, as done before:

```{r}

tot_elec.diff        <- tot_elec[,-length(tot_elec)] - tot_elec[,-1]
colnames(tot_elec.diff) <- seq(2005,2019)

use_renew_elec.diff  <- use_renew_elec[,-length(use_renew_elec)] - use_renew_elec[,-1] 
colnames(use_renew_elec.diff) <- seq(2005,2019)

elec_percentage.diff <- elec_percentage[,-length(elec_percentage)] - elec_percentage[,-1]
colnames(elec_percentage.diff) <- seq(2005,2019)

use_hydro_elec.diff  <- use_hydro_elec[,-length(use_hydro_elec)] - use_hydro_elec[,-1]
use_solar_elec.diff  <- use_hydro_elec[,-length(use_hydro_elec)] - use_hydro_elec[,-1]
use_wind_elec.diff   <- use_hydro_elec[,-length(use_hydro_elec)] - use_hydro_elec[,-1]
colnames(use_hydro_elec.diff) <- seq(2005,2019)
colnames(use_solar_elec.diff) <- seq(2005,2019)
colnames(use_wind_elec.diff) <- seq(2005,2019)

use_principal.diff   <- rbind(use_hydro_elec.diff[4:40,], use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])     
colnames(use_principal.diff) <- seq(2005,2019)


```

Plot trends

```{r}
matplot(colnames(use_principal),t(use_principal),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity from Hydro-Wind-Solar",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```

```{r}
matplot(colnames(use_principal.diff),t(use_principal.diff),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity from Hydro-Wind-Solar",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```


Seems like Hydro is uniformly more used than the other two, let's proceed to statistically test this fact

Observed statistic:
```{r}
#REVIEW
fit <- manova(as.matrix(use_principal.diff) ~ source)
print(summary.manova(fit,test="Wilks")) 
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
```

Run the test

```{r}
set.seed(seed)
T_stat <- numeric(B)
n=dim(use_principal.diff)[1]

for(perm in 1:B){
  # choose random permutation
  permutation <- sample(1:n)
  source.perm <- source[permutation]
  fit.perm <- manova(as.matrix(use_principal.diff) ~ source.perm)
  T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="Wilks stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-2,1),main="Wilk stat ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```

So here we have statistical evidence that the three main renewable sources have not the same distribution in terms of total generated electricity.

We can further investigate whether Solar and Wind are equally distributed (i.e. developing at the same rate) or not.

We'll exploit local testing of this hypothesis, to (in case of rejection) directly obtain the time instant in which the developments are different

```{r}
#REVIEW
loc_test=IWT2(as.matrix(use_solar_elec.diff),as.matrix(use_wind_elec.diff))
plot(loc_test,main="Solar and Wind",col=c(2,3))
```


### Conformal prediction on types of RE for electricity production 

The three conformal models will be:
    - derive DIFF_SOLAR ~ DIFF_GDP + DIFF_POPULATION
    - derive DIFF_WIND ~ DIFF_GDP + DIFF_POPULATION
    - derive DIFF_HIDRO ~ DIFF_GDP + DIFF_POPULATION
    
For this purpose, we will first have to import the SSP data from our dataset, which was obtained by retrieving the year to year values from the original data (more details in "src/preprocessing_SSP.Rmd").
We will also calculate the differences year to year.

```{r}
gdp <- read.xlsx("data/ssp_iiasa_YtY_gdp.xlsx", 1)
pop <- read.xlsx("data/ssp_iiasa_YtY_pop.xlsx", 1)

gdp.diff <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop.diff <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

rownames(gdp.diff) <- gdp$REGION
rownames(pop.diff) <- pop$REGION

gdp.diff <- gdp.diff[,-length(gdp.diff)] - gdp.diff[,-1]
pop.diff <- pop.diff[,-length(pop.diff)] - pop.diff[,-1]

colnames(gdp.diff) <- colnames(gdp)[-c(1,2,3,4,5)]
colnames(pop.diff) <- colnames(pop)[-c(1,2,3,4,5)]

```

```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec.diff[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We discard the countries which are not going to be used, as well as the EU totals 
use_solar_elec.diff.c <- use_solar_elec.diff[c(F,F,F,discard.idx),]
use_wind_elec.diff.c <- use_wind_elec.diff[c(F,F,F,discard.idx),]
use_hydro_elec.diff.c <- use_hydro_elec.diff[c(F,F,F,discard.idx),]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(use_solar_elec.diff.c)
discard.pop.idx <- rownames(pop.diff)%in%rownames(use_solar_elec.diff.c)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]


rn <- rownames(gdp.diff)
gdp.diff <- gdp.diff[rn,]
pop.diff <- pop.diff[rn,]

use_solar_elec.diff.c <- use_solar_elec.diff.c[rn,]
use_wind_elec.diff.c <- use_solar_elec.diff.c[rn,]
use_hydro_elec.diff.c <- use_solar_elec.diff.c[rn,]


```

Montenegro and Albania should be discarded as they have NaN values or no information available for either population or GDP (see "preprocessing_SSP.Rmd"). Kosovo should be discarded as it is not recognized by the SSP predictions.

```{r}

gdp.elec.train <- gdp.diff[,as.character(seq(2005,2019))]
pop.elec.train <- pop.diff[,as.character(seq(2005,2019))]

gdp.elec.pred  <- gdp.diff[,as.character(seq(2020,2030))]
pop.elec.pred  <- pop.diff[,as.character(seq(2020,2030))]

```

REVIEW: Create dummy variables for countries with One Hot Encoding?

```{r}
dummy.country <- seq(1,dim(gdp.diff)[1])

vec_train <- cbind(gdp.elec.train[,1], pop.elec.train[,1], dummy.country)
for (j in 2:15){
    v <- cbind(gdp.elec.train[,j], pop.elec.train[,j], dummy.country)
    vec_train <- rbind(vec_train,v)
}
vec_train <- data.frame(vec_train)
colnames(vec_train) <- c("gdp","pop","country")


vec_test <- cbind(gdp.elec.pred[,1], pop.elec.pred[,1], dummy.country)
for (j in 2:11){
    v <- cbind(gdp.elec.pred[,j], pop.elec.pred[,j], dummy.country)
    vec_test <- rbind(vec_test,v)
}
vec_test <- data.frame(vec_test)
colnames(vec_test) <- c("gdp","pop","country")


vec_solar <- gather(use_solar_elec.diff.c,year,y)[,-1]
vec_hydro <- gather(use_hydro_elec.diff.c,year,y)[,-1]
vec_wind <- gather(use_wind_elec.diff.c,year,y)[,-1]
```


```{r}

train_gam <- function(x,y,out=NULL){
    colnames(x)=c("gdp", "pop", "country")
    train_data=data.frame(y,x)
    model_gam=gam(y ~ s(gdp,country,bs='re') + s(pop,country,bs='re'), data=train_data)
}


predict_gam <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop", "country")
    predict.gam(obj,new_x)
}

```


```{r}

c_preds.solar <- conformal.pred(
    vec_train, 
    vec_solar,
    as.matrix(vec_test),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam, 
    predict.fun = predict_gam)

c_preds.hydro <- conformal.pred(
    vec_train, 
    vec_hydro,
    as.matrix(vec_test),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam, 
    predict.fun = predict_gam)

c_preds.wind <- conformal.pred(
    vec_train, 
    vec_wind,
    as.matrix(vec_test),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam, 
    predict.fun = predict_gam)

c_preds_solar
```

Plot predictions 2020-2030:
```{r}
with(data.frame(vec_solar=vec_solar, year=seq(2005,2019)), plot(year, vec_solar, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Solar Electricity Use'))

lines(rep(seq(2020,2030),34),c_preds.solar$pred,lwd =2, col ="green",lty=3)
matlines(rep(seq(2020,2030),34),c_preds.solar$up,lwd =1, col =" blue",lty =3)
matlines(rep(seq(2020,2030),34),c_preds.solar$lo, lwd =1, col =" blue",lty =3)
```
```{r}
with(data.frame(vec_wind=vec_wind, year=seq(2005,2019)), plot(year, vec_wind, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Wind Electricity Use'))

lines(rep(seq(2020,2030),34),c_preds.wind$pred,lwd =2, col ="green",lty=3)
matlines(rep(seq(2020,2030),34),c_preds.wind$up,lwd =1, col =" blue",lty =3)
matlines(rep(seq(2020,2030),34),c_preds.wind$lo, lwd =1, col =" blue",lty =3)
```
```{r}
with(data.frame(vec_hydro=vec_hydro, year=seq(2005,2019)), plot(year, vec_hydro, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Hydro Electricity Use'))

lines(rep(seq(2020,2030),34),c_preds.hydro$pred,lwd =2, col ="green",lty=3)
matlines(rep(seq(2020,2030),34),c_preds.hydro$up,lwd =1, col =" blue",lty =3)
matlines(rep(seq(2020,2030),34),c_preds.hydro$lo, lwd =1, col =" blue",lty =3)
```


## 3. Analysis of EU's current day renewable energy network.

### Regression on european electricity capacity

Let's make a step regression on total European values

```{r}
x=as.numeric(colnames(use_renew_elec)) #years from 2004 to 2019

plot(x,use_renew_elec[2,],main="Total electricity from renewables - Europe",xlab="Year",ylab="Gigawatt-hour")
```
```{r}
m_cut=lm(as.numeric(use_renew_elec[2,]) ~ cut(x,breaks=10))

years.grid=seq(range(x)[1],range(x)[2],by=0.1)
preds=predict(m_cut,list(x=years.grid),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(x ,as.numeric(use_renew_elec[2,]) ,xlim=range(years.grid) ,cex =.5, col =" darkgrey ",main='Custom cut Fit',xlab="Year",ylab="Gigawatt-hour")
lines(years.grid,preds$fit ,lwd =2, col =" blue")
matlines(years.grid ,se.bands ,lwd =1, col =" blue",lty =3)
```
Terrible...
Let's try with local regression

```{r}
a=data.frame(giga=as.numeric(use_renew_elec[2,]),years_a=x)
m_loc = npreg(giga ~ years_a,
              ckertype = 'uniform',
              bws = 2, # bandwidth
              data= a)
dat=data.frame(years_a=years.grid)
preds=predict(m_loc,newdata=dat,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(
    x,
    as.numeric(use_renew_elec[2,]) ,
    xlim = range(years.grid) ,
    cex = .5,
    col = " darkgrey ",
    main = 'Local Averaging - bws2 - Uniform kernel',
    xlab="Year",
    ylab="Gigawatt-hour"
  )
lines(years.grid,preds$fit ,lwd =2, col =" blue")
matlines(years.grid,se.bands ,lwd =1, col =" blue",lty =3)
```
Maybe gaussian kernel would be better?
```{r}
a=data.frame(giga=as.numeric(use_renew_elec[2,]),years_a=x)
m_loc = npreg(giga ~ years_a,
              ckertype = 'gaussian',
              bws = 1.5, # bandwidth
              data= a)
dat=data.frame(years_a=years.grid)
preds=predict(m_loc,newdata=dat,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(
    x,
    as.numeric(use_renew_elec[2,]) ,
    xlim = range(years.grid) ,
    cex = .5,
    col = " darkgrey ",
    main = 'Local Averaging - bws2 - Gaussian kernel',
    xlab="Year",
    ylab="Gigawatt-hour"
  )
lines(years.grid,preds$fit ,lwd =2, col =" blue")
matlines(years.grid,se.bands ,lwd =1, col =" blue",lty =3)
```

```{r}
list_vec=flatten(use_renew_elec[4:40,])
vec=cbind(list_vec[[1]],rep(2004,37))
for (j in 2:16){
  v=cbind(list_vec[[j]],rep(2004+j-1,37))
  vec=rbind(vec,v)
}
vec=data.frame(vec)
colnames(vec)=c("value","year")

m_loc = npreg(value ~ year,
              ckertype = 'gaussian',
              bws = 2, # bandwidth
              data= vec)
dat=data.frame(year=years.grid)
preds=predict(m_loc,newdata=dat,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(
    vec$year,
    vec$value ,
    xlim = range(years.grid) ,
    cex = .5,
    col = " darkgrey ",
    main = 'Local Averaging - bws2 - Gaussian kernel',
    xlab="Year",
    ylab="Gigawatt-hour"
  )
lines(years.grid,preds$fit ,lwd =2, col =" blue")
matlines(years.grid,se.bands ,lwd =1, col =" blue",lty =3)
```
Let's try with splines
```{r}
model_cubic_splines <-
  lm(value ~ bs(year, degree = 3,df = 10), data = vec)

preds=predict(model_cubic_splines,dat,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

with(vec, plot(year ,value ,xlim=range(dat$year) ,cex =.5, col =" darkgrey "))
lines(dat$year,preds$fit ,lwd =2, col =" blue")
matlines(dat$year, se.bands ,lwd =1, col =" blue",lty =3)
```


### ANOVA test on 2019 capacities, dividing Europe in four regions

Set a region-based analysis of electricity capacity

```{r}
countries=rownames(no_total_no_nuclear)
north_europe=c("Denmark","Estonia","Latvia","Lithuania","Finland","Sweden","Norway","Iceland","United Kingdom","Ireland")

east_europe=c("Bulgaria","Czechia","Hungary","Poland","Romania","Slovakia","Turkey","Ukraine")

south_europe=c("Greece","Spain","Italy","Cyprus","Malta","Portugal","Croatia","Slovenia","North Macedonia","Albania","Serbia")

central_europe=c("France","Belgium","Germany (until 1990 former territory of the FRG)","Luxembourg","Netherlands","Austria")

length(countries)==length(c(north_europe,south_europe,east_europe,central_europe))  #just to see correct division
```
Let's build the dataframe with groups attached, to perform an anova test on 2019 capacities
```{r}
north=no_total_no_nuclear[match(north_europe,countries),30]
east=no_total_no_nuclear[match(east_europe,countries),30]
south=no_total_no_nuclear[match(south_europe,countries),30]
central=no_total_no_nuclear[match(central_europe,countries),30]

north=cbind(north,rep("North",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("South",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_no_nuclear=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_no_nuclear)=c("cap_19","Region")
aov_no_nuclear$Region=factor(aov_no_nuclear$Region)
```

Proceed with anova test
```{r}
attach(aov_no_nuclear)
g=nlevels(aov_no_nuclear$Region)
g
boxplot(as.numeric(cap_19) ~ Region,col=rainbow(g),main="Electricity capacity by region",ylab="Megawatt")
```

```{r}
cap_19=as.numeric(cap_19)
fit <- aov(cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

B=10000
T_stat <- numeric(B) 
n <- dim(aov_no_nuclear)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20))
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```
With aovp?
```{r}
library(lmPerm)
lmp=aovp(cap_19 ~ Region,perm="Prob",Cp=1e-6)#cp is supposed to stop iterations when standard error is at that level...
summary(lmp)
detach(aov_no_nuclear)
#pretty much same result
```
Again, we don't have statistical evidence to say that electricity capacities from renewables have different distribution in the four regions of Europe.
This is not a meaningful result, since we are not taking into account the sizes of countries. It's better to analyze a relative quantity, like the ratio between renewable and total capacity!

Let's build the ad-hoc dataframe with relative capacities of 2019
```{r}
north=no_total_no_nuclear[match(north_europe,countries),30]/(total_capacity[4:38,][match(north_europe,countries),30])

east=no_total_no_nuclear[match(east_europe,countries),30]/(total_capacity[4:38,][match(east_europe,countries),30])

south=no_total_no_nuclear[match(south_europe,countries),30]/(total_capacity[4:38,][match(south_europe,countries),30])

central=no_total_no_nuclear[match(central_europe,countries),30]/(total_capacity[4:38,][match(central_europe,countries),30])

north=cbind(north,rep("Northern",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("Southern",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_ratio_cap=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_ratio_cap)=c("ratio_cap_19","Region")
aov_ratio_cap$Region=factor(aov_ratio_cap$Region)
```

```{r}
attach(aov_ratio_cap)
g=nlevels(aov_ratio_cap$Region)
g
boxplot(as.numeric(ratio_cap_19) ~ Region,col=c("cyan1","indianred1","cornflowerblue","chartreuse1"),main="Relative renewable electricity capacity by region",ylab="Percentage")
```
```{r}
ratio_cap_19=as.numeric(ratio_cap_19)
fit <- aov(ratio_cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

T_stat <- numeric(B) 
n <- dim(aov_ratio_cap)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- ratio_cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="F stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20),main="F stat permutational ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
detach(aov_ratio_cap)
```
Still no statistical evidence of different development in different regions


Let's find a 95% confidence interval for the median of electricity capacity from renewables of 2019
```{r}
median(aov_no_nuclear$cap_19)
```
```{r}
uni_t_perm=function(data,mu0,B=1000){

data_trans=data-mu0
T0=abs(median(data_trans))
T_perm=numeric(B)
n=length(data)

for(perm in 1:B){
  
  refl <- rbinom(n, 1, 0.5)*2 - 1
  T_perm[perm]=abs(median(data_trans*refl))

}
return(sum(T_perm>=T0)/B)
}
```

```{r}
grid=seq(3000,7400,by=0.5)
length(grid)
library(pbapply)
library(parallel)
```

```{r}
cores=detectCores()
cl=makeCluster(cores)
clusterExport(cl,varlist=list("data","uni_t_perm"))
```

```{r}
data=as.numeric(aov_no_nuclear$cap_19)
perm_wrapper=function(grid_point){uni_t_perm(data,grid_point,B=2000)}
pval_function=pbsapply(grid,perm_wrapper,cl=cl)
```

```{r}
plot(grid,pval_function,type='l')
range(grid[pval_function>0.05])
```




```{r}
matplot(colnames(capacity_renew_fuels_nuclear),t(capacity_renew_fuels_nuclear[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from renewables (with nuclear)")
```


Even if we include nuclear, Germany is still at the top
```{r}
rownames(capacity_renew_fuels_nuclear)[which.max(capacity_renew_fuels_nuclear[4:38,30])+3] #first three rows are total european statistics
```






# Core: Model to predict future european CO2


```{r}
# REVIEW: what to do with NA values?

gdp.diff <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop.diff <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

rownames(gdp.diff) <- gdp$REGION
rownames(pop.diff) <- pop$REGION

gdp.diff <- gdp.diff[,-length(gdp.diff)] - gdp.diff[,-1]
pop.diff <- pop.diff[,-length(pop.diff)] - pop.diff[,-1]

colnames(gdp.diff) <- colnames(gdp)[-c(1,2,3,4,5)]
colnames(pop.diff) <- colnames(pop)[-c(1,2,3,4,5)]
```


```{r}
# Not in SSP GDP data and in EUstat data
discard.idx <- rownames(consump.oil.petr.diff[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We discard the countries which are not going to be used, as well as the EU totals 
consump.oil.petr.diff.c <- consump.oil.petr.diff[c(F,F,F,discard.idx),]
consump.gas.diff.c <- consump.gas.diff[c(F,F,F,discard.idx),]
consump.fossils.diff.c <- consump.fossils.diff[c(F,F,F,discard.idx),]
consump.renew.diff.c <- consump.renew.diff[c(F,F,F,discard.idx),]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in EUstat data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(consump.oil.petr.diff.c)
discard.pop.idx <- rownames(pop.diff)%in%rownames(consump.oil.petr.diff.c)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]


rn <- rownames(gdp.diff)
gdp.diff <- gdp.diff[rn,]
pop.diff <- pop.diff[rn,]

consump.oil.petr.diff.c <- consump.oil.petr.diff.c[rn,]
consump.gas.diff.c <- consump.gas.diff.c[rn,]
consump.fossils.diff.c <- consump.fossils.diff.c[rn,]
consump.renew.diff.c <- consump.renew.diff.c[rn,]

```


```{r}
gdp.train <- gdp.diff[,as.character(seq(1991,2019))]
pop.train <- pop.diff[,as.character(seq(1991,2019))]

gdp.pred  <- gdp.diff[,as.character(seq(2020,2030))]
pop.pred  <- pop.diff[,as.character(seq(2020,2030))]
```


## DIFF_NON_RENEWABLE CONSUMPTIONS ~ DIFF_TOTAL_GDP + DIFF_TOTAL_POPULATION

Includes three models, one for each non-renewable energy:
    - DIFF_TOTAL_PETROLEUM  ~ DIFF_TOTAL_GDP + DIFF_TOTAL_POPULATION
    - DIFF_TOTAL_SOLID FOSSIL FUELS ~ DIFF_TOTAL_GDP + DIFF_TOTAL_POPULATION
    - DIFF_TOTAL_NATURAL GAS ~ DIFF_TOTAL_GDP + DIFF_TOTAL_POPULATION

```{r}
# REVIEW: take into account country dummy variable??

vec_train <- cbind(gdp.train[,1], pop.train[,1])
for (j in 2:29){
    v <- cbind(gdp.train[,j], pop.train[,j])
    vec_train <- rbind(vec_train,v)
}
vec_train <- data.frame(vec_train)
colnames(vec_train) <- c("gdp","pop")


vec_test <- cbind(gdp.pred[,1], pop.pred[,1])
for (j in 2:11){
    v <- cbind(gdp.pred[,j], pop.pred[,j])
    vec_test <- rbind(vec_test,v)
}
vec_test <- data.frame(vec_test)
colnames(vec_test) <- c("gdp","pop")

vec_oil <- gather(consump.oil.petr.diff.c,year,y)[,-1]
vec_fos <- gather(consump.fossils.diff.c,year,y)[,-1]
vec_gas <- gather(consump.gas.diff.c,year,y)[,-1]


vec_oil.train <- cbind(vec_oil=vec_oil[1:dim(vec_train)[1]], vec_train)
vec_fos.train <- cbind(vec_fos=vec_fos[1:dim(vec_train)[1]], vec_train)
vec_gas.train <- cbind(vec_gas=vec_gas[1:dim(vec_train)[1]], vec_train)
```



Oil & Petr.
```{r}
consump.oil.petr.gam <- gam(vec_oil ~ s(gdp,bs="re") + s(pop,bs="re"),
                           data = vec_oil.train) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

Fossils:
```{r}
consump.fossils.gam <- gam(vec_fos ~ s(gdp,bs="re") + s(pop,bs="re"),
                           data = vec_fos.train) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```

Natural gas:
```{r}
consump.gas.gam <- gam(vec_gas ~ s(gdp,bs="re") + s(pop,bs="re"),
                           data = vec_gas.train) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```

Predict for 2020-2030
```{r}
# Preds (2020-2030)

consump.oil.petr.gam.preds <- predict(consump.oil.petr.gam, newdata=vec_test, se=T)

consump.fossils.gam.preds <- predict(consump.fossils.gam, newdata=vec_test, se=T)

consump.gas.gam.preds <- predict(consump.gas.gam, newdata=vec_test, se=T)
```

Plot predictions
```{r}

# See graphs
with(vec_oil.train, plot(rep(seq(1991,2019),34) ,vec_oil ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Oil & Petr.'))
points(rep(seq(2020,2030),34), consump.oil.petr.gam.preds$fit ,lwd =2, col ="red")

with(vec_fos.train, plot(rep(seq(1991,2019),34) ,vec_fos ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Fossil fules.'))
points(rep(seq(2020,2030),34), consump.fossils.gam.preds$fit ,lwd =2, col ="red")

with(vec_gas.train, plot(rep(seq(1991,2019),34) ,vec_gas ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Natural Gas'))
points(rep(seq(2020,2030),34), consump.gas.gam.preds$fit ,lwd =2, col ="red")

```

## DIFF_TOTAL_RENEWABLE CONSUMPTIONS  ~ DIFF_TOTAL_PETROLEUM  + DIFF_TOTAL_SOLID FOSSILFUELS + DIFF_TOTAL_NATURAL GAS:
```{r}
# Join all energies for common DF
vec_re <- cbind(consump.renew.diff.c[,1],consump.oil.petr.diff.c[,1],consump.fossils.diff.c[,1], consump.gas.diff.c[,1])
for (j in 2:29){
    v <- cbind(consump.renew.diff.c[,j],consump.oil.petr.diff.c[,j],consump.fossils.diff.c[,j], consump.gas.diff.c[,j])
    vec_re <- rbind(vec_re,v)
}
vec_re <- data.frame(vec_re)
colnames(vec_re) <- c("value_re", "value_oil", "value_ff", "value_ng")
```


```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil,bs='re') + s(value_ff,bs='re') + s(value_ng,bs='re'), data=vec_re)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```

```{r}
vec_re_pred <- cbind(consump.oil.petr.gam.preds$fit,consump.fossils.gam.preds$fit, consump.gas.gam.preds$fit)
vec_re_pred <- data.frame(vec_re_pred)
colnames(vec_re_pred) <- c("value_oil", "value_ff", "value_ng")


consump.renew.gam.preds <- predict(consump.renew.gam, newdata=vec_re_pred, se=T)
```

```{r}
# See graphs
with(vec_re, plot(rep(seq(1991,2019),34) ,value_re ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Renewable Energy Consumption.'))
points(rep(seq(2020,2030),34), consump.renew.gam.preds$fit ,lwd =2, col ="red")
```


## DIFF_TOTAL_CO2 ~  DIFF_TOTAL_RENEWABLE CONSUMPTION

```{r}
c02 <- read.xlsx("data/annual-co-emissions-by-region.xlsx", sheet=2)

# Check if all countries are present in other EU stats 
sum(!(unique(c02$Country) %in% rownames(consump.renew.diff.c))) > 0 
```
Calculate differences:
```{r}
c02.diff <- data.frame()
for(i in 1:34){
    for(j in 1:29){ # 1990-2019
        c02.diff <- rbind(c02.diff, c(c02$Country[(j+1)+(i-1)*31], 1990+j,
                                      c02[(j+1)+(i-1)*31, 4] - c02[j+(i-1)*31, 4]))
    }
}
colnames(c02.diff) <- colnames(c02)[c(-2,-5)]
```


```{r}
vec_c02 <- rbind(c02.diff[,3], vec_re[,1]) #FIXME
vec_c02 <- lapply(vec_c02, as.numeric)
vec_c02 <- data.frame(vec_c02)
vec_c02_pred <- data.frame(consump.renew.gam.preds$fit)

colnames(vec_c02) <- c("value_c02", "value_re")
colnames(vec_c02_pred) <- c("value_re")

```

```{r}
c02.gam <- gam(value_c02 ~ s(value_re,bs='re'), data=vec_c02)

summary(c02.gam)

hist(c02.gam$residuals)
qqnorm(c02.gam$residuals)
shapiro.test(c02.gam$residuals)
```

```{r}
c02.gam.preds <- predict(c02.gam, newdata=vec_c02_pred, se=T)

with(vec_c02, plot(rep(seq(1991,2019),34) ,value_c02 ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - c02 levels.'))
points(rep(seq(2020,2030),34), consump.renew.gam.preds$fit ,lwd =2, col ="red")
```




# Robustness

## TODO:




