---
title: "NPS_project"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TITLE
Load necessary libraries:

```{r}
# General
library(openxlsx)
library(MASS)
library(progress)
library(np)
library(splines)
library(devtools)
library(tidyr)
library(jsonlite)
library(ISLR2)
library(pbapply)
# Depth
#library(DepthProc)
#library(robustbase)
# Functional data
library(roahd)
library(fda)
library(fdatest)
# Graphics packages
library(rgl)
library(hexbin)
library(ggplot2)
library(corrplot)
# GAM
library(mgcv)
# Conformal
#devtools::install_github(repo="ryantibs/conformal", subdir="conformalInference")
library(conformalInference)
library(forecast)


B=10000
seed=42
set.seed(seed)
```

### Preprocessing of data

We implemented auxiliary functions for easy preprocessing of data:

```{r}

# 1000 Tons Of Oil Equivalent to Terajoules = 41.1868
tto_2_tj <- function(tto) {
    return(tto * 41.868)
}

# Function cleans df removing NAN rows, setting values as numeric...
preprocess <- function(df, start_nrows=6, end_nrows=2, tj=T) { 
    
    # Remove first rows not containing significant data
    df <- df[-c(1:start_nrows,(dim(df)[1]-(end_nrows-1)):dim(df)[1]),]
    
    rownames(df) <- df[,1] #use countries as rownames
    df <- df[,-1]
    
    rownames(df)[1] <- "year"
    rownames(df)[3] <- "European_Union" #we use 28 countries as European total value
    
    # Remove rows with NA values (in first column)
    df <- df[!df[,1]==':',]
    
    
    # 3 decimals
    df[] <- lapply(df, as.numeric)  
    
    if(!tj) # All data should be converted to Terajoules
        df[-1,] <- lapply(df[-1,], tto_2_tj)
    
    return(df)
}


# Function for creating a smoothing procedure for any data given an interval:
# Interval corresponds to the frequency in each year: 2 =each 6 months, 3=each 4 months...
smoothing_procedure <- function (data, from, to, write_to=NA, interval=3, row_names=NULL){
    
    new.data <- data.frame(matrix(ncol =length(from:to), nrow = 0))
    
    comb.year.grid <- seq(from, to, 1)
    
    for(c in 1:dim(data)[1]){ # For each country
        
        data.data <- as.numeric(data[c, as.character(from:to)]) 
        data.data.nans <- is.na(data.data)
        n.comb.year.grid <- comb.year.grid[!data.data.nans]
        
        times_basis <- n.comb.year.grid 
        knots       <- c(n.comb.year.grid) # Location of knots
        n_knots     <- length(knots) # Number of knots
        n_order     <- 2 # order of basis functions: cubic bspline: order = 3 + 1
        n_basis     <- length(knots) + n_order - 2;
        
        basis <- create.bspline.basis(c(min(times_basis),max(times_basis)),n_basis,n_order,knots)
        
        ys <- smooth.basis(argvals=times_basis, y=data.data[!data.data.nans], fdParobj = basis)
        
        xfd <- ys$fd
        
        data.yby <- eval.fd(seq(min(n.comb.year.grid),max(n.comb.year.grid), 1/interval), xfd) #            Obtain data year by year
        
        new.data <- rbind(new.data, c( rep(NA, ((to-from) + 1 - length(n.comb.year.grid))*interval),
                                       data.yby))
    }

    # Rename columns
    colnames(new.data) <- c(seq(from, to, 1/interval))   
    
    rownames(new.data) <- row_names
    
    
    if(!is.na(write_to)){
        write.xlsx(new.data, write_to, overwrite = T)
    }
    return(new.data)
}

```


In our script "preprocessing_SSP.rmd", we have additional code regarding the transformation of data of the SSP original data to fit our needs and located in "data/ssp_iiasa_YtY_gdp.xlsx" & "data/ssp_iiasa_YtY_pop.xlsx".



# Starting Point: Analysis of current European Renewable Transition


Loading necessary datasets. In energy balances we don't have the value Final Consumption (FC), but it can be estimated as sum of several.

```{r}
energy.balances.1  <- read.xlsx("data/complete_energy_balances.xlsx",sheet=1) # Gross available energy, first sheet should be the best

consump.fossils  <- read.xlsx("data/consumption_solid_fossil_fuels.xlsx",sheet=1) # Inland consumption
consump.gas      <- read.xlsx("data/consumption_gas.xlsx",sheet=1) # Inland consumption
consump.oil.petr <- read.xlsx("data/consumption_oil_petroleum.xlsx",sheet=1) # Inland consumption

consump.renew.1  <- read.xlsx("data/consumption_renewables.xlsx",sheet=1) # Geothermal, inland consump
consump.renew.2  <- read.xlsx("data/consumption_renewables.xlsx",sheet=2) # Solar thermal, inland consump.
consump.renew.3  <- read.xlsx("data/consumption_renewables.xlsx",sheet=3) # Biofuels, inland consump.
consump.renew.4  <- read.xlsx("data/consumption_renewables.xlsx",sheet=4) # Biogases, inland consump.
consump.renew.5  <- read.xlsx("data/consumption_renewables.xlsx",sheet=5) # Renewable waste, inland consump.

percent.renew <- read.xlsx("data/percentage_renewables.xlsx") 

prod.by.fuel.total <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=1)
prod.by.fuel.comb <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=2)
prod.by.fuel.nuclear <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=9)

```

We will now preprocess all datasets with our auxilary function. We will also compute the total Renewable energy's consumption levels by summing all the consumptions for all types of Renewable sources.

```{r}

energy.balances.p <- preprocess(energy.balances.1, tj=F)

consump.fossils.p <- preprocess(consump.fossils[,-32], tj=T) # without 2020 because of some missing data

consump.fossils.p[-1,] <- consump.fossils.p[-1,] * 25 #  Calorific power of Fossil Fuels
                                 
consump.oil.petr.p <- preprocess(consump.oil.petr[,-32], tj=F) # without 2020
consump.gas.p      <- preprocess(consump.gas[,-32], tj=T) # without 2020

consump.renew.1.p <- preprocess(consump.renew.1[,-32])
consump.renew.2.p <- preprocess(consump.renew.2[,-32])
consump.renew.3.p <- preprocess(consump.renew.3[,-32])
consump.renew.4.p <- preprocess(consump.renew.4[,-32])
consump.renew.5.p <- preprocess(consump.renew.5[,-32])

consump.renew.p <- consump.renew.1.p # Sum of all renewable energies
consump.renew.p[-1,] <- consump.renew.p[-1,] + consump.renew.2.p[-1,] + consump.renew.3.p[-1,] +consump.renew.4.p[-1,] + consump.renew.5.p[-1,]


prod.by.fuel.total.p = preprocess(prod.by.fuel.total)
prod.by.fuel.comb.p = preprocess(prod.by.fuel.comb)
prod.by.fuel.nuclear.p = preprocess(prod.by.fuel.nuclear)

prod.by.fuel.renew = prod.by.fuel.total.p
prod.by.fuel.renew[-1,] = prod.by.fuel.renew[-1,] - prod.by.fuel.comb.p[-1,] - prod.by.fuel.nuclear.p[-1,] #renewable electricity capacity (MegaWatt)

colnames(prod.by.fuel.total.p)= prod.by.fuel.total.p[1,]
prod.by.fuel.total.p=prod.by.fuel.total.p[-1,]

colnames(prod.by.fuel.comb.p)= prod.by.fuel.comb.p[1,]
prod.by.fuel.comb.p=prod.by.fuel.comb.p[-1,]

colnames(prod.by.fuel.renew)= prod.by.fuel.renew[1,]
prod.by.fuel.renew=prod.by.fuel.renew[-1,]

```


To visualize the obtained data, we can plot European renewable and non renewable consumption levels:

```{r}
r_europe <- ggplot(data=as.data.frame(t(consump.renew.p)), aes(x=year, y=European_Union)) +
            labs(title="Renewable Energies Consumption Progression - European Union", 
                 subtitle="Inland Consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="blue", colour="darkblue", size=1)
r_europe
```

```{r}
# Example of European consumption of solid fossil fuels
f_europe <- ggplot(data=as.data.frame(t(consump.fossils.p)), aes(x=year, y=European_Union)) +
            labs(title="Consumption Solid Fossil Fuels - European Union", 
                 subtitle="Inland consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="red", colour="darkred", size=1)
f_europe

```

We will also create some auxiliary variables & datasets, so it is easier to follow what we are doing. 
```{r}
year.min       <- min(energy.balances.p[1,])
year.max       <- max(energy.balances.p[1,])
year.grid      <- seq(year.min, year.max)

countries.list <- rownames(consump.fossils.p[-c(1,2,3,4),])

# Construct datasets with and without total European values 
energy.balances.countries  <- energy.balances.p[-c(1,2,3,4),]
consump.fossils.countries  <- consump.fossils.p[-c(1,2,3,4),]
consump.oil.petr.countries <- consump.oil.petr.p[-c(1,2,3,4),]
consump.gas.countries      <- consump.gas.p[-c(1,2,3,4),]
consump.renew.countries    <- consump.renew.p[-c(1,2,3,4),]

consump.oil.petr.europe <- consump.oil.petr.p[3,]
consump.gas.europe <- consump.gas.p[3,]
consump.fossils.europe <- consump.fossils.p[3,]
consump.renew.europe <- consump.renew.p[3,]

colnames(energy.balances.countries)=year.grid
colnames(consump.fossils.countries)=year.grid
colnames(consump.oil.petr.countries)=year.grid
colnames(consump.gas.countries)=year.grid
colnames(consump.renew.countries)=year.grid
```

Since we are working with time series, by their nature data are yearly correlated.
To deal with this problem, let's construct year to year variations datasets:
```{r}
energy.balances.diff <- energy.balances.p[-1,-1] - energy.balances.p[-1,-length(energy.balances.p)]
consump.fossils.diff <- consump.fossils.p[-1,-1] - consump.fossils.p[-1,-length(consump.fossils.p)]
consump.oil.petr.diff <- consump.oil.petr.p[-1,-1] - consump.oil.petr.p[-1,-length(consump.oil.petr.p)]
consump.gas.diff <- consump.gas.p[-1,-1] - consump.gas.p[-1,-length(consump.gas.p)]
consump.renew.diff <- consump.renew.p[-1,-1] - consump.renew.p[-1,-length(consump.renew.p)]

energy.balances.diff <- rbind(year=seq(1991, 2019), energy.balances.diff)
consump.fossils.diff <- rbind(year=seq(1991, 2019), consump.fossils.diff)
consump.oil.petr.diff <- rbind(year=seq(1991, 2019), consump.oil.petr.diff)
consump.gas.diff <- rbind(year=seq(1991, 2019), consump.gas.diff)
consump.renew.diff <- rbind(year=seq(1991, 2019), consump.renew.diff)
```

The analysis of current European renewable transition is structured in three sections:

## First target: investigate how renewable and non-renewable consumptions are evolving.


We can visualize the consumption levels of all EU countries.

Via time series visualization of :
```{r}
#matplot(seq(year.min, year.max), t(energy.balances.countries), type="l", lty=1,
        #main="Energy Balances EU 1990 - 2019", xlab="Year", ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.fossils.countries), type="l", lty=1,
        main="Consumption of Solid Fossil Fuels EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.oil.petr.countries), type="l", lty=1,
        main="Consumption of Oil and Petroleum EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.gas.countries), type="l", lty=1,
        main="Consumption of Natural Gas EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.renew.countries), type="l", lty=1,
        main="Consumption of Renewables EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")
```

Via boxplot:
```{r}
#boxplot(energy.balances.countries, main="Boxplot Energy Balances", xlab="Countries", 
        #ylab="Terajoules")

boxplot(consump.fossils.countries, main="Boxplot of Consumption of Solid Fossil Fuels", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.oil.petr.countries, main="Boxplot of Consumption of Oil and Petroleum", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.gas.countries, main="Boxplot of Consumption of Natural Gas", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.renew.countries, main="Consumption of Renewables", xlab="Countries", 
        ylab="Terajoule")
```


First let us check for normality with a simple Shapiro-Wilk test.

Let us visualize a random country from the dataset and check whether it might be normally distributed:

```{r}

index.italy <- which(rownames(consump.renew.diff) == c("Italy"))
hist(t(consump.fossils.diff)[,index.italy])
hist(t(consump.oil.petr.diff)[,index.italy])
hist(t(consump.gas.diff)[,index.italy])
hist(t(consump.renew.diff)[,index.italy])

```

Now to check the distribution of p-values obtained with a Shapiro-Wilk test:
```{r}

p.values.ff <- numeric(length(countries.list)) # Fossil fuels
p.values.op <- numeric(length(countries.list)) # Oil&Petr.
p.values.ng <- numeric(length(countries.list)) # Natural gas 
p.values.re <- numeric(length(countries.list)) # RE
# FIXME: Error in shapiro.test(t(consump.gas.diff)[, c]) :  all 'x' values are identical
for(c in 1:length(countries.list)){
  
  if (identical(diff(as.numeric(t(consump.fossils.diff[-c(1,2,3,4),])[,c])),rep(0,length(as.numeric(t(consump.fossils.diff[-c(1,2,3,4),])[,c]))-1)))  #we check that values are not all equal, if it happens we put a simbolic value in the vector of p-values.
    
  {p.values.ff[c]=2 }#simbolic value
  else{
    p.values.ff[c] <- shapiro.test(t(consump.fossils.diff[-c(1,2,3,4),])[,c])$p.value
  }
  
  if(identical(diff(as.numeric(t(consump.oil.petr.diff[-c(1,2,3,4),])[,c])),rep(0,length(as.numeric(t(consump.oil.petr.diff[-c(1,2,3,4),])[,c]))-1)))
    
  {p.values.op[c]=2}
  else{
    p.values.op[c] <- shapiro.test(t(consump.oil.petr.diff[-c(1,2,3,4),])[,c])$p.value
  }
  
  if(identical(diff(as.numeric(t(consump.gas.diff[-c(1,2,3,4),])[,c])),rep(0,length(as.numeric(t(consump.gas.diff[-c(1,2,3,4),])[,c]))-1))) 
    
  {p.values.ng[c]=2}
  else{
    p.values.ng[c] <- shapiro.test(t(consump.gas.diff[-c(1,2,3,4),])[,c])$p.value
  }
  
  if(identical(diff(as.numeric(t(consump.renew.diff[-c(1,2,3,4),])[,c])),rep(0,length(as.numeric(t(consump.renew.diff[-c(1,2,3,4),])[,c]))-1)))
    
  {p.values.re[c]=2}
  else{
    p.values.re[c] <- shapiro.test(t(consump.renew.diff[-c(1,2,3,4),])[,c])$p.value
  }
}
hist(p.values.ff,breaks=20)
hist(p.values.op,breaks=20)
hist(p.values.ng,breaks=20)
hist(p.values.re,breaks=20)
```

### Permutational Multivariate tests - Comparing Consumption distributions

We want to compare the distributions of Non Renewable vs Renewable fuels for each country:
```{r}
consump.fossils.mean <- colMeans(consump.fossils.countries, na.rm=T)
consump.oil.petr.mean <- colMeans(consump.oil.petr.countries, na.rm=T)
consump.gas.mean <- colMeans(consump.gas.countries, na.rm=T)
consump.renew.mean <- colMeans(consump.renew.countries, na.rm=T)

matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean,
                                       consump.renew.mean)),
        type="l",main="Consumption means for each type of fuel",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(consump.fossils.mean)[2]+300000),lwd=2)

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas","Renewable Energies"), col=1:4, pch=2)


```

Plot of only non-renewables
```{r}
matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean)),
        type="l",main="Consumption means for each type of non renewable fuel",xlab="Years",ylab="Terajoules",lwd=2,
        ylim=c(min(consump.fossils.mean)-30000,max(consump.fossils.mean)+30000))

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas"), col=1:3, pch=2)
```


We start with a permutational MANOVA to see whether the three non renewable sources have the same distribution

```{r}

consump.nonrenew.countries=rbind(consump.oil.petr.p[5:39,],
                                 consump.fossils.p[5:39,],consump.gas.p[5:39,])

nonrenew.source <- c(rep("Oil_Petr",35),rep("Fossil_Fuels",35),rep("Natural_Gas",35))
nonrenew.source <- factor(nonrenew.source)
```



```{r}
fit <- manova(as.matrix(consump.nonrenew.countries) ~ nonrenew.source)
print(summary.manova(fit,test="Wilks")) 
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
```


```{r}
set.seed(seed)
T_stat <- numeric(B)
n=dim(consump.nonrenew.countries)[1]

for(perm in 1:B){
  # choose random permutation
  permutation <- sample(1:n)
  source.perm <- nonrenew.source[permutation]
  fit.perm <- manova(as.matrix(consump.nonrenew.countries) ~ source.perm)
  T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="Wilks stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-2,1),main="Wilk stat ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```


Non-renewables coupled permutational tests
```{r}

# H0: Distributions are equal
# H1: Distributions are not equal

# NG vs OP ----------------------------------------------------------------

n1 <- dim(consump.gas.countries)[1]
n2 <- dim(consump.oil.petr.countries)[1]
n  <- n1 + n2

# Test statistic
T10 <- as.numeric((consump.gas.mean-consump.oil.petr.mean) %*% (consump.gas.mean-consump.oil.petr.mean))
T10

# Permutational distribution
T1 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)

t_pooled = rbind(consump.gas.countries, consump.oil.petr.countries)
for(perm in 1:B){
    
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm)#, na.rm = T)
    t2.mean_perm = colMeans(t2_perm)#, na.rm = T)
    T1[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T1,xlim=range(c(T1,T10)),main="Test statistic permutational distribution")
abline(v=T10,col=3,lwd=4)

plot(ecdf(T1),main="Test statistic permutational ecdf")
abline(v=T10,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T1>=T10)/B
p_val

```

```{r}

# FF vs OP ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.fossils.countries))[1]
n2 <- dim(as.matrix(consump.oil.petr.countries))[1]
n  <- n1 + n2

# Test statistic
T20 <- as.numeric((consump.fossils.mean-consump.oil.petr.mean) %*% (consump.fossils.mean-consump.oil.petr.mean))
T20

# Permutational distribution
T2 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)

t_pooled = rbind(consump.fossils.countries, consump.oil.petr.countries)

for(perm in 1:B){
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm)
    t2.mean_perm = colMeans(t2_perm)
    T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T2,xlim=range(c(T2,T20)),main="Test statistic permutational distribution")
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2),main="Test statistic permutational ecdf")
abline(v=T20,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T2>=T20)/B
p_val

```


```{r}

# NG vs FF ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.fossils.countries))[1]
n2 <- dim(as.matrix(consump.gas.countries))[1]
n  <- n1 + n2

# Test statistic
T20 <- as.numeric((consump.fossils.mean-consump.gas.mean) %*% (consump.fossils.mean-consump.gas.mean))
T20

# Permutational distribution
T2 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)

t_pooled = rbind(consump.fossils.countries, consump.gas.countries)

for(perm in 1:B){
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm)
    t2.mean_perm = colMeans(t2_perm)
    T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T2,xlim=range(c(T2,T20)),main="Test statistic permutational distribution")
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2),main="Test statistic permutational ecdf")
abline(v=T20,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T2>=T20)/B
p_val

```

We never reject the null hypothesis so we can assume that in average the 3 non-renewable sources are decreasing at the same rate.


Does the renewable consumption growth follow the same distribution as the non renewable decrease?
```{r}

# RE vs Non-RE ----------------------------------------------------------------
# Use year by year change of each energy

mean.consump.nonrenew <-(consump.fossils.countries+consump.gas.countries+consump.oil.petr.countries )/3
mean.consump.nonrenew.mean=colMeans(mean.consump.nonrenew)

matplot(seq(year.min, year.max), t(rbind(mean.consump.nonrenew.mean,
                                         consump.renew.mean)),
        type="l",main="Consumption means renewables vs non-renewables",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(mean.consump.nonrenew.mean)[2]+300000),col=c(1,3),lty=c(1,1),lwd=2)
legend("topright",legend=c("Non-renewable sources","Renewable sources"),col=c(1,3),pch=2)


mean.consump.nonrenew.diff <- mean.consump.nonrenew[,-length(mean.consump.nonrenew)] - mean.consump.nonrenew[,-1] #"inverse" deltas for non renewables to obtain growing curve differences

consump.renew.diff <- consump.renew.countries[,-1] - consump.renew.countries[,-length(consump.renew.countries)]

mean.consump.nonrenew.diff.mean <- colMeans(mean.consump.nonrenew.diff, na.rm=T)
consump.renew.diff.mean <- colMeans(consump.renew.diff, na.rm=T)

matplot(seq(year.min+1,year.max), consump.renew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Renewable consumptions year to year average deltas",col="green",lwd=2,ylim=c(-40000,100000))
matlines(seq(year.min+1,year.max), mean.consump.nonrenew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Mean non-renewable consumptions year to year inverse average deltas",lwd=2)
legend("topright",legend=c("Non-renewable sources","Renewable sources"),col=c(1,3),pch=2)


n1 <- dim(as.matrix(consump.renew.diff))[1]
n2 <- dim(as.matrix(mean.consump.nonrenew.diff))[1]
n  <- n1 + n2

# Test statistic
T30 <- as.numeric((consump.renew.diff.mean-mean.consump.nonrenew.diff.mean) %*% (consump.renew.diff.mean-mean.consump.nonrenew.diff.mean))
T30

# Permutational distribution
T3 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

pb$tick(0)

t_pooled <- cbind(consump.renew.diff,mean.consump.nonrenew.diff)

for(perm in 1:B){
    permutation <- sample(n)
    t_perm <- t_pooled[permutation,]
    t1_perm <- t_perm[1:n1,]
    t2_perm <- t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm <- colMeans(t1_perm, na.rm = T)
    t2.mean_perm <- colMeans(t2_perm, na.rm = T)
    T3[perm]  <- (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T3,xlim=range(c(T3,T30)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T30,col=3,lwd=4)

plot(ecdf(T3),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T30,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T3>=T30)/B
p_val

```




## Second Target: Investigate how electricity production coming from renewable sources is growing

Let's visualize the total electricity production trend by country

```{r}
tot_elec <- read.xlsx('data/total_electricity_use.xlsx')
# View(tot_elec)
tot_elec = preprocess(tot_elec)

colnames(tot_elec) <- tot_elec[1,] #use years as columns names
tot_elec <- tot_elec[-1,] #first row is now useless
tot_elec <- tot_elec[,-17] #don't consider 2020

matplot(colnames(tot_elec),t(tot_elec[4:39,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity production by country")
```

Let's visualize the production of electricity from renewables trend by country

```{r}
use_renew_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=1)
# View(use_renew_elec)
use_renew_elec = preprocess(use_renew_elec)

colnames(use_renew_elec) <- use_renew_elec[1,] #use years as columns names
use_renew_elec <- use_renew_elec[-1,] #first row now is useless


use_renew_elec <- use_renew_elec[!is.na(use_renew_elec[,16]),]
# View(use_renew_elec)



matplot(colnames(use_renew_elec),t(use_renew_elec[4:40,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from renewables by country")

```

Let's see which country is particularly above the others in total usage of renewables for electricity production

```{r}
rownames(use_renew_elec)[which.max(use_renew_elec[4:40,16])+3] #first three rows are total european statistics
```
Let's construct a dataset with percentage of electricity coming from renewables to visualize its evolution at a European level
```{r}
elec_percentage <- tot_elec

for (j in 1:16){
  elec_percentage[,j] <- use_renew_elec[-34,j]/elec_percentage[,j]
  #34th row is Montenegro, which didn't survive preprocessing in the total electricity production dataset
}
# View(elec_percentage)

years_04_19 <- as.numeric(colnames(elec_percentage))
plot(years_04_19,as.numeric(elec_percentage[2,]),main="Percentage of electricity coming from renewable sources - EU",xlab="Year",ylab="Percentage",type="l")
points(years_04_19,as.numeric(elec_percentage[2,]),col="Green",lwd=3)
```



### MANOVA to compare the distributions from the three main types of RE for electricity consumption

Getting and preprocessing electricity data
```{r}
use_hydro_elec <-read.xlsx('data/use_renew_elec.xlsx',sheet=2)
use_wind_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=4)
use_solar_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=6)

#clean hydro
use_hydro_elec=preprocess(use_hydro_elec)

colnames(use_hydro_elec) <- use_hydro_elec[1,]
use_hydro_elec <- use_hydro_elec[-1,]

use_hydro_elec <- use_hydro_elec[!is.na(use_hydro_elec[,16]),]

#clean wind
use_wind_elec=preprocess(use_wind_elec)

colnames(use_wind_elec) <- use_wind_elec[1,]
use_wind_elec <- use_wind_elec[-1,]

use_wind_elec <- use_wind_elec[!is.na(use_wind_elec[,16]),]

#clean solar
use_solar_elec=preprocess(use_solar_elec)

colnames(use_solar_elec) <- use_solar_elec[1,]
use_solar_elec <- use_solar_elec[-1,]

use_solar_elec <- use_solar_elec[!is.na(use_solar_elec[,16]),]

use_hydro_elec[] <- lapply(use_hydro_elec, as.numeric)
use_wind_elec[] <- lapply(use_wind_elec, as.numeric)
use_solar_elec[] <- lapply(use_solar_elec, as.numeric)


use_principal <- rbind(use_hydro_elec[4:40,],use_wind_elec[4:40,],use_solar_elec[4:40,])

#factor vector
source <- c(rep("Hydro",37),rep("Wind",37),rep("Solar",37))
source <- factor(source)
```

Let's obtain year to year differences from these datasets, as done before:

```{r}

tot_elec.diff        <- tot_elec[,-1] - tot_elec[,-length(tot_elec)]
colnames(tot_elec.diff) <- seq(2005,2019)

use_renew_elec.diff  <- use_renew_elec[,-1] - use_renew_elec[,-length(use_renew_elec)] 
colnames(use_renew_elec.diff) <- seq(2005,2019)

elec_percentage.diff <- elec_percentage[,-1] - elec_percentage[,-length(elec_percentage)]
colnames(elec_percentage.diff) <- seq(2005,2019)

use_hydro_elec.diff  <- use_hydro_elec[,-1] - use_hydro_elec[,-length(use_hydro_elec)]
use_solar_elec.diff  <- use_solar_elec[,-1] - use_solar_elec[,-length(use_solar_elec)]
use_wind_elec.diff   <- use_wind_elec[,-1] - use_wind_elec[,-length(use_wind_elec)]
colnames(use_hydro_elec.diff) <- seq(2005,2019)
colnames(use_solar_elec.diff) <- seq(2005,2019)
colnames(use_wind_elec.diff) <- seq(2005,2019)

use_principal.diff   <- rbind(use_hydro_elec.diff[4:40,], use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])     
colnames(use_principal.diff) <- seq(2005,2019)


```

Plot electricity trends

```{r}
matplot(colnames(use_principal),t(use_principal),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from Hydro-Wind-Solar",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```

```{r}
matplot(colnames(use_principal.diff),t(use_principal.diff),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from Hydro-Wind-Solar, year to year variations",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```


Seems like Hydro is uniformly more used than the other two.
Seems like Hydro has less variations than the other two, let's proceed to statistically test this fact

Observed statistic:
```{r}
fit <- manova(as.matrix(use_principal.diff) ~ source)
print(summary.manova(fit,test="Wilks")) 
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
```

Run the test

```{r}
set.seed(seed)
T_stat <- numeric(B)
n=dim(use_principal.diff)[1]

for(perm in 1:B){
  # choose random permutation
  permutation <- sample(1:n)
  source.perm <- source[permutation]
  fit.perm <- manova(as.matrix(use_principal.diff) ~ source.perm)
  T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="Wilks stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-2,1),main="Wilk stat ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```

So here we have statistical evidence that the three main renewable sources have not the same growth distribution in terms of generated electricity.

We can further investigate whether Solar and Wind are equally distributed (i.e. developing at the same rate) or not.
```{r}
wind.mean = colMeans(use_wind_elec.diff[4:40,])
solar.mean = colMeans(use_solar_elec.diff[4:40,])
years_04_19=as.numeric(colnames(use_wind_elec)) #years from 2004 to 2019
years_05_19=years_04_19[-1]

matplot(years_05_19,t(rbind(wind.mean,solar.mean)), type='l', col=c("green","red"), lty=1,xlab="Year",ylab="Gigawatt-hour",main="Mean yearly variations of electricity production")
legend("topleft",legend=c("Wind","Solar"),col=c(3,2),pch=1)
```


```{r}
n1 = n2=dim(use_wind_elec.diff[4:40,])[1]
n  = n1 + n2

T20 = as.numeric((wind.mean-solar.mean) %*% (wind.mean-solar.mean))
T20

# Estimating the permutational distribution under H0

T2 = numeric(B)
set.seed(seed)
t_pooled = rbind(use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])

for(perm in 1:B){
  # Random permutation of indexes
  permutation = sample(n)
  t_perm = t_pooled[permutation,]
  t1_perm = t_perm[1:n1,]
  t2_perm = t_perm[(n1+1):n,]
  
  # Evaluation of the test statistic on permuted data
  t1.mean_perm = colMeans(t1_perm)
  t2.mean_perm = colMeans(t2_perm)
  T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
}

hist(T2,xlim=range(c(T2,T20)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T20,col=3,lwd=4)

pvalue=sum(T2>=T20)/B
pvalue
```


### Conformal prediction on types of RE for electricity production 

To understand how Hydro, Wind and Solar sources of electricity will grow with time we proceeded with some prediction of the amount of electricity coming from each of them, in function of Gdp, population and their interaction. 
    
For this purpose, we will first have to import the SSP data from our dataset, which was obtained by retrieving the year to year values from the original data (more details in "src/preprocessing_SSP.Rmd").

We also construct variations datasets that will prove to be useful in the near future.

```{r}
gdp <- read.xlsx("data/ssp_iiasa_YtY_gdp.xlsx", 1)
pop <- read.xlsx("data/ssp_iiasa_YtY_pop.xlsx", 1)

gdp.diff <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop.diff <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

rownames(gdp.diff) <- gdp$Country.Name
rownames(pop.diff) <- pop$Country.Name

gdp.diff <- gdp.diff[,-1] - gdp.diff[,-length(gdp.diff)]
pop.diff <- pop.diff[,-1] - pop.diff[,-length(pop.diff)]
years_90_40=colnames(pop)[-c(1,2,3,4)]

colnames(gdp.diff) <- years_90_40[-1]
colnames(pop.diff) <- years_90_40[-1]

gdp <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

colnames(gdp) <- years_90_40
colnames(pop) <- years_90_40

rownames(gdp) <- rownames(gdp.diff)
rownames(pop) <- rownames(pop.diff)
```

```{r}
gdp[is.na(gdp)] <- 0 #replace NA with 0
gdp.diff[is.na(gdp.diff)] <- 0 
```

EU totals - original data
For the moment we are trying to make predictions for the three renewable electricity sources with original data
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp)
discard.pop.idx <- rownames(pop)%in%rownames(gdp)

# Take EU totals 
use_solar_elec.total <- use_solar_elec[2,]
use_wind_elec.total <- use_wind_elec[2,]
use_hydro_elec.total <- use_hydro_elec[2,]

pop <- pop[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp)%in%rownames(use_solar_elec[-c(1,2,3),])
discard.pop.idx <- rownames(pop)%in%rownames(use_solar_elec[-c(1,2,3),])

gdp <- gdp[discard.gdp.idx,]
pop <- pop[discard.pop.idx,]


rn <- rownames(gdp)
gdp <- gdp[rn,]
pop <- pop[rn,]

gdp.total <- as.numeric(colSums(gdp))
pop.total <- as.numeric(colSums(pop))
```

Montenegro and Albania should be discarded as they have NaN values or no information available for either population or GDP (see "preprocessing_SSP.Rmd"). Kosovo should be discarded as it is not recognized by the SSP predictions.



Since we have data only from 2004 (instead of 1990) to 2019, more points are needed to construct predicting models. We generate these points through a smoothing procedure, obtaining semestral data.


Smoothing for solar, wind and hydro to obtain data for each semester (total values)
```{r}
use_solar_elec.total.s <- smoothing_procedure(use_solar_elec.total, 2004, 2019, interval=2, row_names = rownames(use_solar_elec.total))
use_wind_elec.total.s <- smoothing_procedure(use_wind_elec.total, 2004, 2019, interval=2, row_names = rownames(use_wind_elec.total))
use_hydro_elec.total.s <- smoothing_procedure(use_hydro_elec.total, 2004, 2019, interval=2, row_names = rownames(use_hydro_elec.total))
```



```{r}
#using EU total values
gdp.elec.train <- gdp[,as.character(seq(2004,2019))]
pop.elec.train <- pop[,as.character(seq(2004,2019))]
gdp.elec.train = colSums(gdp.elec.train)
pop.elec.train = colSums(pop.elec.train)

gdp.elec.pred  <- gdp[,as.character(seq(2020,2030))]
pop.elec.pred  <- pop[,as.character(seq(2020,2030))]
gdp.elec.pred = colSums(gdp.elec.pred)
pop.elec.pred = colSums(pop.elec.pred)
```


Smoothing on Gdp and Population (total values)
```{r}

gdp.elec.train.s <- smoothing_procedure(t(data.frame(gdp.elec.train)), 2004, 2019, interval=2)
pop.elec.train.s <- smoothing_procedure(t(data.frame(pop.elec.train)), 2004, 2019, interval=2)

gdp.elec.pred.s <- smoothing_procedure(t(data.frame(gdp.elec.pred)), 2020, 2030, interval=2)
pop.elec.pred.s <- smoothing_procedure(t(data.frame(pop.elec.pred)), 2020, 2030, interval=2)

```


```{r}
#vectors for EU total data
vec_train = cbind(as.numeric(gdp.elec.train.s), as.numeric(pop.elec.train.s))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(as.numeric(gdp.elec.pred.s), as.numeric(pop.elec.pred.s))
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

We first tried to construct models using original data and checked the correlation of the residuals using the (partial) autocorrelation function, obtaining as we will see high correlation values.


Let's find the adequate models to use for conformal prediction

#### Wind model - original data
```{r}
tr_data=data.frame(t(use_wind_elec.total.s),vec_train)
colnames(tr_data)[1]="European_Union"
with(tr_data,plot(gdp,European_Union,main="Wind electricity vs gdp"))
with(tr_data,plot(pop,European_Union,main="Wind electricity vs pop"))
```


```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
Acf(model_gam$residuals)
```


```{r}
Pacf(model_gam$residuals)
```

#### Solar model - original data
```{r}
tr_data=data.frame(t(use_solar_elec.total.s),vec_train)

with(tr_data,plot(gdp,European_Union,main="Solar electricity vs gdp"))
with(tr_data,plot(pop,European_Union,main="Solar electricity vs pop"))

```

```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's see with a permutational anova if the interaction term is significant (residuals are not gaussian)
```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][3,4]

aov.H0= aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr') +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][3,4] 
pb$tick
}
sum(T_perm>= T0)/B


```

So we cannot drop the interaction term, let's try to quit the gdp
```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][1,4]

aov.H0= aov(gam(European_Union ~ s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr') +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][1,4] 
pb$tick
}
sum(T_perm>= T0)/B
```

Let's also try to drop the population term
```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][2,4]

aov.H0= aov(gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr') +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][2,4] 
pb$tick
}
sum(T_perm>= T0)/B
```

We can drop it

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
Acf(model_gam$residuals)

```

```{r}
Pacf(model_gam$residuals)
```


#### Hydro model - original data
```{r}
tr_data=data.frame(t(use_hydro_elec.total.s),vec_train)

with(tr_data,plot(gdp,European_Union,main="Hydro electricity vs gdp"))
with(tr_data,plot(pop,European_Union,main="Hydro electricity vs pop"))

```


```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's see if the interaction term is significant (residuals are gaussian)

```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)
anova(model_gam_reduced,model_gam,test="F")
```

We can quit the interaction term

```{r}
model_gam=model_gam_reduced

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

We should also try to quit population (residuals are gaussian)

```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') ,data=tr_data)
anova(model_gam_reduced,model_gam,test="F")
```

Seems like population is significant after all...

```{r}
Acf(model_gam$residuals)
```


```{r}
Pacf(model_gam$residuals)
```


Differences are much needed...

Since working with original data gave us residuals with high correlations, we decided to fit models using the year to year variations. We construct some GAM models on which we perform conformal prediction.
Each time we search for the best GAM model by looking at the significance of the covariates and the adjusted R squared.

#### First order differences dataframes
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We discard the countries which are not going to be used 
use_solar_elec.diff.c <- use_solar_elec.diff[c(F,F,F,discard.idx),]
use_wind_elec.diff.c <- use_wind_elec.diff[c(F,F,F,discard.idx),]
use_hydro_elec.diff.c <- use_hydro_elec.diff[c(F,F,F,discard.idx),]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(use_solar_elec.diff.c)
discard.pop.idx <- rownames(pop.diff)%in%rownames(use_solar_elec.diff.c)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]


rn <- rownames(gdp.diff)
gdp.diff <- gdp.diff[rn,]
pop.diff <- pop.diff[rn,]

use_solar_elec.diff.c <- use_solar_elec.diff.c[rn,]
use_wind_elec.diff.c <- use_wind_elec.diff.c[rn,]
use_hydro_elec.diff.c <- use_hydro_elec.diff.c[rn,]

```


Smoothing for solar, wind and hydro to obtain data for each month (variations)
```{r}
use_solar_elec.diff.s <- smoothing_procedure(use_solar_elec.diff.c, 2005, 2019, interval=2, row_names = rownames(use_solar_elec.diff.c))
use_wind_elec.diff.s <- smoothing_procedure(use_wind_elec.diff.c, 2005, 2019, interval=2, row_names = rownames(use_wind_elec.diff.c))
use_hydro_elec.diff.s <- smoothing_procedure(use_hydro_elec.diff.c, 2005, 2019, interval=2, row_names = rownames(use_hydro_elec.diff.c))
```

```{r}
#obtaining EU values
gdp.diff.total=t(data.frame(colSums(gdp.diff)))
pop.diff.total=t(data.frame(colSums(pop.diff)))

use_solar_elec.diff.total=t(data.frame(colSums(use_solar_elec.diff.s)))
use_wind_elec.diff.total=t(data.frame(colSums(use_wind_elec.diff.s)))
use_hydro_elec.diff.total=t(data.frame(colSums(use_hydro_elec.diff.s)))

```


```{r}
#using EU yearly variations
gdp.elec.diff.train <- gdp.diff.total[,as.character(seq(2005,2019))]
pop.elec.diff.train <- pop.diff.total[,as.character(seq(2005,2019))]

gdp.elec.diff.pred  <- gdp.diff.total[,as.character(seq(2020,2030))]
pop.elec.diff.pred  <- pop.diff.total[,as.character(seq(2020,2030))]
```

```{r}
gdp.elec.diff.train.s <- smoothing_procedure(t(data.frame(gdp.elec.diff.train)), 2005, 2019, interval=2)
pop.elec.diff.train.s <- smoothing_procedure(t(data.frame(pop.elec.diff.train)), 2005, 2019, interval=2)

gdp.elec.diff.pred.s <- smoothing_procedure(t(data.frame(gdp.elec.diff.pred)), 2020, 2030, interval=2)
pop.elec.diff.pred.s <- smoothing_procedure(t(data.frame(pop.elec.diff.pred)), 2020, 2030, interval=2)

```


```{r}
#vectors for EU yearly variations
vec_train = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(as.numeric(gdp.elec.diff.pred.s), as.numeric(pop.elec.diff.pred.s))
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

#### Wind model - First order differences

```{r}
tr_data=data.frame(t(use_wind_elec.diff.total.s),vec_train)
colnames(tr_data)[1]="European_Union"

with(tr_data,plot(gdp,European_Union,main="Wind diff electricity vs diff gdp"))
with(tr_data,plot(pop,European_Union,main="Wind diff electricity vs diff pop"))

```

```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's try quitting one covariate at a time. We start quitting the interaction term (gaussian residuals)
```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```
Let's put back the interraction term and quit gdp

```{r}
model_gam_reduced=gam(European_Union ~ s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```
Let's put back gdp and quit population


```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")

```

Let's try quitting the smooth terms, one at a time
```{r}
model_gam1=lm(European_Union ~ bs(gdp) + bs(pop) + gdp:pop,data=tr_data)

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```

```{r}
model_gam2=lm(European_Union ~ bs(gdp) + pop + bs(I(gdp*pop)),data=tr_data)

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```


```{r}
model_gam3=lm(European_Union ~ gdp + bs(pop) + bs(I(gdp*pop)),data=tr_data)

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```


By looking at R squared and singular significance, the second one seems the best, let's go with it
```{r}
model_gam_wind=model_gam2

```


```{r}
Acf(model_gam_wind$residuals)
```

```{r}
Pacf(model_gam_wind$residuals)
```

Unfortunately there is again a bit of correlation at 2 steps but this could be due to the smoothing that we had to apply in order to construct the models (as mentioned before). Anyway it is clearly better than the corresponding best model constructed with original data.


#### Hydro model - First order differences

Let's go on constructing hydro model

```{r}
tr_data=data.frame(t(use_hydro_elec.diff.total.s),vec_train)
colnames(tr_data)[1]="European_Union"

with(tr_data,plot(gdp,European_Union,main="Hydro diff electricity vs diff gdp"))
with(tr_data,plot(pop,European_Union,main="Hydro diff electricity vs diff pop"))

```

```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's try quitting one covariate at a time (residuals are gaussian)

```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```


```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```

```{r}
model_gam_reduced=gam(European_Union ~ s(pop,bs='cr') + s(I(gdp*pop),bs='cr') ,data=tr_data)

anova(model_gam_reduced,model_gam,test="F")

```

Let's try quitting the smooth terms, one at a time

```{r}
model_gam1=lm(European_Union ~ bs(gdp) + bs(pop) + gdp:pop,data=tr_data)

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```

```{r}
model_gam2=lm(European_Union ~ bs(gdp) + pop + bs(I(gdp*pop)),data=tr_data)

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```


```{r}
model_gam3=lm(European_Union ~ gdp + bs(pop) + bs(I(gdp*pop)),data=tr_data)

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

From the third one, let's try to quit the interaction term (residuals are gaussian)

```{r}
model_gam_reduced=lm(European_Union ~ gdp + bs(pop),data=tr_data)

anova(model_gam_reduced,model_gam3,test="F")
```
We can quit the interaction term

```{r}
model_gam3=model_gam_reduced

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```
Let's try quit the gdp (residuals are gaussian)

```{r}
model_gam_reduced=lm(European_Union ~ bs(pop),data=tr_data)

anova(model_gam_reduced,model_gam3,test="F")
```
We can quit gdp

```{r}
model_gam3=model_gam_reduced

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```
Let's get back to the complete model and now we try to quit two smooth terms at a time

```{r}
model_gam1=lm(European_Union ~ bs(gdp) + pop + gdp:pop,data=tr_data)

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```


```{r}
model_gam2=lm(European_Union ~ gdp + bs(pop) + gdp:pop,data=tr_data)

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```

```{r}
model_gam3=lm(European_Union ~ gdp + pop + bs(I(gdp*pop)),data=tr_data)

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

From the third model we start quitting the interaction term (residuals are gaussian)

```{r}
model_gam_reduced=lm(European_Union ~ gdp + pop,data=tr_data)

anova(model_gam_reduced,model_gam3,test="F")
```

We can quit the interaction term

```{r}
model_gam3=model_gam_reduced

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

Let's try quitting gdp (residuals are gaussian)
```{r}
model_gam_reduced=lm(European_Union ~  pop,data=tr_data)

anova(model_gam_reduced,model_gam3,test="F")
```
We can quit gdp


```{r}
model_gam3=model_gam_reduced

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

Go back to the first model
```{r}
summary(model_gam1)
shapiro.test(model_gam1$residuals)
```

Let's try to quit the gdp (gaussian residuals)
```{r}
model_gam_reduced=lm(European_Union ~  pop + gdp:pop,data=tr_data)

anova(model_gam_reduced,model_gam1,test="F")
```

We can quit it
```{r}
model_gam1=model_gam_reduced

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```

Let's try to quit the interaction (gaussian residuals)
```{r}
model_gam_reduced=lm(European_Union ~  pop,data=tr_data)

anova(model_gam_reduced,model_gam1,test="F")
```

We obtain the same result as before so we should try with the second model
```{r}
summary(model_gam2)
shapiro.test(model_gam2$residuals)
```

Let's try to quit the interaction
```{r}
model_gam_reduced=lm(European_Union ~ gdp + bs(pop),data=tr_data)

anova(model_gam_reduced,model_gam2,test="F")
```

We quit it
```{r}
model_gam2=model_gam_reduced

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```

Try to quit gdp (gaussian residuals)
```{r}
model_gam_reduced=lm(European_Union ~  bs(pop),data=tr_data)

anova(model_gam_reduced,model_gam2,test="F")
```

We can quit it
```{r}
model_gam2=model_gam_reduced

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```

Let's try to explain the differences of hydro usage with original data of EU gdp and population

```{r}
#vectors for EU total data
vec_train = cbind(as.numeric(gdp.elec.train.s[,3:31]), as.numeric(pop.elec.train.s[,3:31]))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(as.numeric(gdp.elec.pred.s), as.numeric(pop.elec.pred.s))
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

```{r}
tr_data=data.frame(t(use_hydro_elec.diff.total.s),vec_train)
colnames(tr_data)[1]="European_Union"

with(tr_data,plot(gdp,European_Union,main="Hydro diff electricity vs gdp"))
with(tr_data,plot(pop,European_Union,main="Hydro diff electricity vs pop"))

```

```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's try to quit the interaction (residuals are gaussian)
```{r}
model_gam_reduced=gam(European_Union ~  s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```

We cannot quit the interaction term, let's try with gdp
```{r}
model_gam_reduced=gam(European_Union ~  s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```

We cannot quit gdp either, so we have our model

```{r}
Acf(model_gam$residuals)

```


```{r}
Pacf(model_gam$residuals)
```

```{r}
model_gam_hydro=model_gam
```


#### Solar model - First order differences

Let's go back to yearly variations datasets
```{r}
#vectors for EU yearly variations
vec_train = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(as.numeric(gdp.elec.diff.pred.s), as.numeric(pop.elec.diff.pred.s))
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

```{r}
tr_data=data.frame(t(use_solar_elec.diff.total.s),vec_train)
colnames(tr_data)[1]="European_Union"

with(tr_data,plot(gdp,European_Union,main="Solar diff electricity vs diff gdp"))
with(tr_data,plot(pop,European_Union,main="Solar diff electricity vs diff pop"))

```

```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Again, let's quit one covariate at a time (residuals are not gaussian)
```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][3,4]

aov.H0= aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr') +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][3,4] 
pb$tick
}
sum(T_perm>= T0)/B
```

We can quit the interaction term

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's try to quit pop (residuals are not gaussians)

```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)))[[1]][2,4]

aov.H0= aov(gam(European_Union ~ s(gdp,bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)))[[1]][2,4] 
pb$tick
}
sum(T_perm>= T0)/B
```


So we can quit pop too
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's try to quit one smooth term at a time
```{r}
model_gam1=lm(European_Union ~ bs(gdp) + bs(pop) + gdp:pop,data=tr_data)

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```

```{r}
model_gam2=lm(European_Union ~ bs(gdp) + pop + bs(I(gdp*pop)),data=tr_data)

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```

```{r}
model_gam3=lm(European_Union ~ gdp + bs(pop) + bs(I(gdp*pop)),data=tr_data)

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

Starting from the second, we could try to lower the degree of gdp spline (residuals are gaussian)

```{r}
model_gam_reduced=lm(European_Union ~ bs(gdp,degree=2) + pop+ bs(I(gdp*pop)),data=tr_data)

anova(model_gam_reduced,model_gam2,test="F")

```

So we cannot reduce the degree of gdp spline to degree 2
Let's try to lower the degree of the interaction term




```{r}
model_gam_reduced=lm(European_Union ~ bs(gdp) + pop+ bs(I(gdp*pop),degree=2),data=tr_data)

anova(model_gam_reduced,model_gam2,test="F")

```

We cannot reduce the interaction spline degree either, so we have our model

```{r}
Acf(model_gam2$residuals)

```


```{r}
Pacf(model_gam2$residuals)
```
High correlation in 1 step residuals but we stick with this model
```{r}
model_gam_solar=model_gam2
```

Little review of the selected models
```{r}
summary(model_gam_wind)

```

```{r}
summary(model_gam_hydro)

```

```{r}
summary(model_gam_solar)

```



### Predictions

```{r}
train_gam_wind <- function(x,y,out=NULL){
    colnames(x)=c("gdp", "pop")
    train_data=data.frame(y,x)
    model_gam=lm(y ~ bs(gdp) + pop + bs(I(gdp * pop)), 
    data = train_data)
}


predict_gam_wind <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop")
    as.numeric(predict(obj,new_x))
}

lm_train_wind=lm.funs(intercept = T)$train.fun
lm_predict_wind=lm.funs(intercept = T)$predict.fun

```

```{r}
vec_train_wind = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train_wind=data.frame(vec_train_wind)
colnames(vec_train_wind)=c("gdp","pop")


vec_test_wind = cbind(as.numeric(gdp.elec.diff.pred.s), as.numeric(pop.elec.diff.pred.s))
vec_test_wind=data.frame(vec_test_wind)
colnames(vec_test_wind)=c("gdp","pop")

design_matrix_gdp=bs(vec_train_wind$gdp)
design_matrix_pop=bs(vec_train_wind$pop,degree=1)
design_matrix_int=bs(I(vec_train_wind$gdp * vec_train_wind$pop))
design_matrix_wind=matrix(cbind(design_matrix_gdp,design_matrix_pop,design_matrix_int),nrow=dim(vec_train_wind)[1])

pred_grid_gdp=bs(vec_test_wind$gdp)
pred_grid_pop=bs(vec_test_wind$pop,degree=1)
pred_grid_int=bs(I(vec_test_wind$gdp*vec_test_wind$pop))

pred_grid_wind=matrix(cbind(pred_grid_gdp,pred_grid_pop,pred_grid_int),nrow=dim(vec_test_wind)[1])

```

```{r}
train_gam_hydro <- function(x,y,out=NULL){
    colnames(x)=c("gdp", "pop")
    train_data=data.frame(y,x)
    model_gam=gam(y ~ s(gdp, bs = "cr") + s(pop, bs = "cr") + s(I(gdp*pop), bs = "cr"), data=train_data)
}


predict_gam_hydro <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop")
    predict.gam(obj,new_x)
}
```

```{r}
vec_train_hydro = cbind(as.numeric(gdp.elec.train.s[,3:31]), as.numeric(pop.elec.train.s[,3:31]))
vec_train_hydro=data.frame(vec_train_hydro)
colnames(vec_train_hydro)=c("gdp","pop")

vec_test_hydro = cbind(as.numeric(gdp.elec.pred.s), as.numeric(pop.elec.pred.s))
vec_test_hydro=data.frame(vec_test_hydro)
colnames(vec_test_hydro)=c("gdp","pop")
```

```{r}
train_gam_solar <- function(x,y,out=NULL){
    colnames(x)=c("gdp", "pop")
    train_data=data.frame(y,x)
    model_gam=lm(y ~ bs(gdp) + pop + bs(I(gdp*pop)), data=train_data)
}


predict_gam_solar <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop")
    as.numeric(predict(obj,new_x))
}
```

```{r}
vec_train_solar = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train_solar=data.frame(vec_train_solar)
colnames(vec_train_solar)=c("gdp","pop")

vec_test_solar = cbind(as.numeric(gdp.elec.diff.pred.s), as.numeric(pop.elec.diff.pred.s))
vec_test_solar=data.frame(vec_test_solar)
colnames(vec_test_solar)=c("gdp","pop")
```


```{r}
#Eu total predictions
c_preds.wind.total <- conformal.pred(
    #design_matrix_wind,
    as.matrix(vec_train_wind), 
    use_wind_elec.diff.total,
    as.matrix(rbind(vec_train_wind,vec_test_wind)),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam_wind, 
    predict.fun = predict_gam_wind)

c_preds.hydro.total <- conformal.pred(
    as.matrix(vec_train_hydro), 
    use_hydro_elec.diff.total,
    as.matrix(rbind(vec_train_hydro,vec_test_hydro)),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam_hydro, 
    predict.fun = predict_gam_hydro)

c_preds.solar.total <- conformal.pred(
    as.matrix(vec_train_solar), 
    use_solar_elec.diff.total,
    as.matrix(rbind(vec_train_solar,vec_test_solar)),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam_solar, 
    predict.fun = predict_gam_solar)
```

Plot predictions 2020-2030:

```{r}
plot(seq(2005,2019,0.5), use_wind_elec.diff.total.s, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='Prediction - Wind Diff Electricity Use',ylim=c(0,100000))

preds_wind=as.numeric(predict(model_gam_wind,newdata=vec_test_wind))
lines(seq(2005,2019,0.5),model_gam_wind$fitted.values,lwd=2,col="green",lty=1)
lines(seq(2020,2030,0.5),preds_wind,lwd=2,col="green",lty=2)

```

```{r}
plot(seq(2005,2019,0.5), use_hydro_elec.diff.total.s, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='Prediction - Hydro Diff Electricity Use',ylim=c(0,12000))

preds_hydro=as.numeric(predict(model_gam_hydro,newdata=vec_test_hydro))
lines(seq(2005,2019,0.5),model_gam_hydro$fitted.values,lwd=2,col="green",lty=1)
lines(seq(2020,2030,0.5),preds_hydro,lwd=2,col="green",lty=2)
```

```{r}
plot(seq(2005,2019,0.5), use_solar_elec.diff.total.s, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='Prediction - Solar Diff Electricity Use',ylim=c(-50000,50000))

preds_solar=as.numeric(predict(model_gam_solar,newdata=vec_test_solar))
lines(seq(2005,2019,0.5),model_gam_solar$fitted.values,lwd=2,col="green",lty=1)
lines(seq(2020,2030,0.5),preds_solar,lwd=2,col="green",lty=2)
```


```{r}
plot(seq(2005,2019,0.5), use_wind_elec.diff.total, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Wind Electricity Use',ylim=c(-50000,100000))

lines(c(seq(2005,2019,0.5),seq(2020,2030,0.5)),c_preds.wind.total$pred,lwd =2, col ="green",lty=3)
lines(c(seq(2005,2019,0.5),seq(2020,2030,0.5)),c_preds.wind.total$up,lwd =1, col =" blue",lty =3)
lines(c(seq(2005,2019,0.5),seq(2020,2030,0.5)),c_preds.wind.total$lo, lwd =1, col =" blue",lty =3)
lines(seq(2005,2019,0.5),c_preds.wind.total$fit, lwd =1, col =" green",lty =1)

```

```{r}
plot(seq(2005,2019,0.5), use_hydro_elec.diff.total, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Hydro Electricity Use',ylim=c(-10000,10000))

lines(c(seq(2005,2019,0.5),seq(2020,2030,0.5)),c_preds.hydro.total$pred,lwd =2, col ="green",lty=3)
lines(c(seq(2005,2019,0.5),seq(2020,2030,0.5)),c_preds.hydro.total$up,lwd =1, col =" blue",lty =3)
lines(c(seq(2005,2019,0.5),seq(2020,2030,0.5)),c_preds.hydro.total$lo, lwd =1, col =" blue",lty =3)
lines(seq(2005,2019,0.5),c_preds.hydro.total$fit, lwd =1, col =" green",lty =1)


```

```{r}
plot(seq(2005,2019,0.5), use_solar_elec.diff.total, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Solar Electricity Use',ylim=c(-60000,40000))

lines(c(seq(2005,2019,0.5),seq(2020,2030,0.5)),c_preds.solar.total$pred,lwd =2, col ="green",lty=3)
lines(c(seq(2005,2019,0.5),seq(2020,2030,0.5)),c_preds.solar.total$up,lwd =1, col =" blue",lty =3)
lines(c(seq(2005,2019,0.5),seq(2020,2030,0.5)),c_preds.solar.total$lo, lwd =1, col =" blue",lty =3)
lines(seq(2005,2019,0.5),c_preds.solar.total$fit, lwd =1, col =" green",lty =1)


```
```{r}
wind.predictions=use_wind_elec.total[,16]+cumsum(c_preds.wind.total$pred)
wind.predictions.up=use_wind_elec.total[,16]+cumsum(c_preds.wind.total$up)
wind.predictions.low=use_wind_elec.total[,16]+cumsum(c_preds.wind.total$lo)

plot(seq(2004,2019),use_wind_elec.total,xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Wind Electricity Use',ylim=c(min(use_wind_elec.total-1000),max(wind.predictions.up+1000)))
points(seq(2020,2030,0.5),wind.predictions,col="green",cex=0.5)
lines(seq(2020,2030,0.5),wind.predictions.up,col="blue",lwd=1,lty=3)
lines(seq(2020,2030,0.5),wind.predictions.low,col="blue",lwd=1,lty=3)

```

```{r}
hydro.predictions=use_hydro_elec.total[,16]+cumsum(c_preds.hydro.total$pred)
hydro.predictions.up=use_hydro_elec.total[,16]+cumsum(c_preds.hydro.total$up)
hydro.predictions.low=use_hydro_elec.total[,16]+cumsum(c_preds.hydro.total$lo)

plot(seq(2004,2019),use_hydro_elec.total,xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Hydro Electricity Use',ylim=c(min(hydro.predictions.low-1000),max(hydro.predictions.up+1000)))
points(seq(2020,2030,0.5),hydro.predictions,col="green",cex=0.5)
lines(seq(2020,2030,0.5),hydro.predictions.up,col="blue",lwd=1,lty=3)
lines(seq(2020,2030,0.5),hydro.predictions.low,col="blue",lwd=1,lty=3)

```
```{r}
solar.predictions=use_solar_elec.total[,16]+cumsum(c_preds.solar.total$pred)
solar.predictions.up=use_solar_elec.total[,16]+cumsum(c_preds.solar.total$up)
solar.predictions.low=use_solar_elec.total[,16]+cumsum(c_preds.solar.total$lo)

plot(seq(2004,2019),use_solar_elec.total,xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Solar Electricity Use',ylim=c(min(solar.predictions.low-1000),max(solar.predictions.up+1000)))
points(seq(2020,2030,0.5),solar.predictions,col="green",cex=0.5)
lines(seq(2020,2030,0.5),solar.predictions.up,col="blue",lwd=1,lty=3)
lines(seq(2020,2030,0.5),solar.predictions.low,col="blue",lwd=1,lty=3)
```


## Third Target: Analyse the current European renewable energy network.

### Regression on european electricity capacity

Let's plot some trends
```{r}
matplot(colnames(prod.by.fuel.total.p),t(prod.by.fuel.total.p[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Total electricity capacities")
```

```{r}
matplot(colnames(prod.by.fuel.comb.p),t(prod.by.fuel.comb.p[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from non-renewables")
```


```{r}
prod.by.fuel.renew.countries=prod.by.fuel.renew[-c(1,2,3),]
matplot(colnames(prod.by.fuel.renew.countries),t(prod.by.fuel.renew.countries),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from renewables")
```

Now let's perform different kinds of nonparametric regression to compare European trends of renewable vs non renewable electricity capacity
```{r}
years_90_19=as.numeric(colnames(prod.by.fuel.comb.p))
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European non-renewable electricity capacity",xlab="Year",ylab="Megawatt")
```

```{r}
m_list=lapply(1:10,function(degree){lm(as.numeric(prod.by.fuel.comb.p[2,]) ~ poly(as.numeric(years_90_19),degree=degree))})
do.call(anova,m_list)
```


```{r}
summary(m_list[[2]])
```

```{r}
summary(m_list[[3]])

```

```{r}
summary(m_list[[6]])

```


```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[2]]$fitted.values,col="red")

```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[3]]$fitted.values,col="red")
```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[6]]$fitted.values,col="red")
```

Third grade polynomial regression seems reasonable (theorethically we should choose grade 9, since it's the last significant model: 10th grade regression is not significant)

```{r}
comb_model=m_list[[3]]
```


Now let's move to renewables
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
```

```{r}
m_list=lapply(1:10,function(degree){lm(as.numeric(prod.by.fuel.renew[2,]) ~ poly(as.numeric(years_90_19),degree=degree))})
do.call(anova,m_list)
```
```{r}
summary(m_list[[2]])

```
```{r}
summary(m_list[[4]])

```
```{r}
summary(m_list[[7]])

```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[2]]$fitted.values,col="green")
```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[4]]$fitted.values,col="green")
```

```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[7]]$fitted.values,col="green")
```
Since by passing to fourth grade we only add one parameter w.r.t second grade (third grade coefficient is considered zero), we can consider the fourth grade regression.

But we can notice that the coefficient of fourth grade is negative! It's not really reasonable for future predictions, so we stick to second grade


```{r}
ren_model=m_list[[2]]
```


```{r}
anni=seq(range(years_90_19)[1],range(years_90_19)[2],by=0.25)
preds=predict(comb_model,list(years_90_19=anni),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(years_90_19 ,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni), ylim=range(as.numeric(prod.by.fuel.renew[2,]))+5000,cex =.5, col =" darkgrey ",main='Polynomial regression on european electricity capacity',xlab="Year",ylab="Megawatt")
lines(anni,preds$fit ,lwd =2, col =" red")
matlines (anni ,se.bands ,lwd =1, col =" red",lty =3)

preds=predict(ren_model,list(years_90_19=anni),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ",pch=2)
lines(anni,preds$fit ,lwd =2, col =" green")
matlines (anni ,se.bands ,lwd =1, col =" green",lty =3)

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)
```

Let's try with spline regression
```{r}
#combustible fuels
b=data.frame(cap=as.numeric(prod.by.fuel.comb.p[2,]),years_b=years_90_19)
comb_model_spline <- lm(cap ~ bs(years_b, df=7,degree=2), data=b )
dat_b=data.frame(years_b=anni)

preds=predict(comb_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni),
    ylim=range(as.numeric(prod.by.fuel.renew[2,]))+5000,cex =.5, col =" darkgrey ",
    main="Splines regression on european electricity capacity",xlab="Year",ylab="Megawatt")

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)

lines(anni,preds$fit ,lwd =2, col =" red")
matlines(anni, se.bands ,lwd =1, col =" red",lty =3)

#renewables
c=data.frame(cap=as.numeric(prod.by.fuel.renew[2,]),years_b=years_90_19)
ren_model_spline <- lm(cap ~ bs(years_b, df=7,degree=2), data=c )
dat_b=data.frame(years_b=anni)

preds=predict(ren_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ")
lines(anni,preds$fit ,lwd =2, col =" green")
matlines(anni, se.bands ,lwd =1, col =" green",lty =3)
```

Natural splines
```{r}
comb_model_spline <- lm(cap ~ ns(years_b, df=8), data=b )
dat_b=data.frame(years_b=anni)

preds=predict(comb_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

plot(years_90_19 ,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni) ,ylim=range(as.numeric(prod.by.fuel.renew[2,]))+3000,cex =.5, col =" darkgrey ",
     main="Natural Splines regression on european electricity capacity",xlab="Year",ylab="Megawatt")

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)

lines(anni,preds$fit ,lwd =2, col =" red")
matlines(anni, se.bands ,lwd =1, col =" red",lty =3)

ren_model_spline <- lm(cap ~ ns(years_b, df=7), data=c )
dat_b=data.frame(years_b=anni)

preds=predict(ren_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ")
lines(anni,preds$fit ,lwd =2, col =" green")
matlines(anni, se.bands ,lwd =1, col =" green",lty =3)
```

Natural cubic splines seems the best approach, it better captures all the local variations.


### ANOVA test on 2019 capacities, dividing Europe in four regions

Set a region-based analysis of electricity capacity

```{r}

countries=rownames(prod.by.fuel.renew.countries)# TODO: recompute this dataset, it's the sum of the capacities coming from different sources in prod.by.fuel dataset (discard combustible fuels and nuclear)

north_europe=c("Denmark","Estonia","Latvia","Lithuania","Finland","Sweden","Norway","Iceland","United Kingdom","Ireland")

east_europe=c("Bulgaria","Czechia","Hungary","Poland","Romania","Slovakia","Turkey","Ukraine")

south_europe=c("Greece","Spain","Italy","Cyprus","Malta","Portugal","Croatia","Slovenia","North Macedonia","Albania","Serbia")

central_europe=c("France","Belgium","Germany (until 1990 former territory of the FRG)","Luxembourg","Netherlands","Austria") #TODO: change Germany name

length(countries)==length(c(north_europe,south_europe,east_europe,central_europe))  #just to see correct division
```
Let's build the dataframe with groups attached, to perform an anova test on 2019 capacities
```{r}
north=prod.by.fuel.renew.countries[match(north_europe,countries),30]
east=prod.by.fuel.renew.countries[match(east_europe,countries),30]
south=prod.by.fuel.renew.countries[match(south_europe,countries),30]
central=prod.by.fuel.renew.countries[match(central_europe,countries),30]

north=cbind(north,rep("North",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("South",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_no_nuclear=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_no_nuclear)=c("cap_19","Region")
aov_no_nuclear$Region=factor(aov_no_nuclear$Region)
```

Proceed with anova test
```{r}
attach(aov_no_nuclear)
g=nlevels(aov_no_nuclear$Region)
g
boxplot(as.numeric(cap_19) ~ Region,col=rainbow(g),main="Electricity capacity by region",ylab="Megawatt")
```

```{r}
cap_19=as.numeric(cap_19)
fit <- aov(cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

B=10000
T_stat <- numeric(B) 
n <- dim(aov_no_nuclear)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20))
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```
With aovp?
```{r}
library(lmPerm)
lmp=aovp(cap_19 ~ Region,perm="Prob",Cp=1e-6)#cp is supposed to stop iterations when standard error is at that level...
summary(lmp)
detach(aov_no_nuclear)
#pretty much same result
```
Again, we don't have statistical evidence to say that electricity capacities from renewables have different distribution in the four regions of Europe.
This is not a meaningful result, since we are not taking into account the sizes of countries. It's better to analyze a relative quantity, like the ratio between renewable and total capacity!

Let's build the ad-hoc dataframe with relative capacities of 2019
```{r}
north=prod.by.fuel.renew.countries[match(north_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(north_europe,countries),30])

east=prod.by.fuel.renew.countries[match(east_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(east_europe,countries),30])

south=prod.by.fuel.renew.countries[match(south_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(south_europe,countries),30])

central=prod.by.fuel.renew.countries[match(central_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(central_europe,countries),30])

north=cbind(north,rep("Northern",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("Southern",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_ratio_cap=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_ratio_cap)=c("ratio_cap_19","Region")
aov_ratio_cap$Region=factor(aov_ratio_cap$Region)
```

```{r}
attach(aov_ratio_cap)
g=nlevels(aov_ratio_cap$Region)
g
boxplot(as.numeric(ratio_cap_19) ~ Region,col=c("cyan1","indianred1","cornflowerblue","chartreuse1"),main="Relative renewable electricity capacity by region",ylab="Percentage")
```
```{r}
ratio_cap_19=as.numeric(ratio_cap_19)
fit <- aov(ratio_cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

T_stat <- numeric(B) 
n <- dim(aov_ratio_cap)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- ratio_cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="F stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20),main="F stat permutational ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
detach(aov_ratio_cap)
```
Still no statistical evidence of different development in different regions

# Core: Model to predict future european GHG emissions
We have set ourselves the goal of predicting whether the Green Deal target of a 55% cut in greenhouse gases emissions by 2030 with respect to 1990 levels is feasible.

With the target to develop a model to predict future Greenhouse gases emissions as a function of the other energy indicators we had to previously construct a variety of auxiliar models to predict covariates values to be used in the final model.


Keeping only European countries for which we have complete data of Gdp, Population and Energy consumptions.
```{r}
# Not in SSP GDP data and in EUstat data
discard.idx <- rownames(consump.oil.petr.diff[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We smooth the non-renewable data to obtain values for each month of each year
consump.oil.petr.diff.s <- consump.oil.petr.diff[-1,]
consump.fossils.diff.s <- consump.fossils.diff[-1,]
consump.gas.diff.s <- consump.gas.diff[-1,]

colnames(consump.oil.petr.diff.s) <- consump.oil.petr.diff[1,]
colnames(consump.fossils.diff.s) <- consump.fossils.diff[1,]
colnames(consump.gas.diff.s) <- consump.gas.diff[1,]

consump.oil.petr.diff.s <- smoothing_procedure(consump.oil.petr.diff.s, 1991, 2019,interval=1, row_names = rownames(consump.oil.petr.diff.s))
consump.gas.diff.s <- smoothing_procedure(consump.gas.diff.s, 1991, 2019,interval=1, row_names = rownames(consump.gas.diff.s))
consump.fossils.diff.s <- smoothing_procedure(consump.fossils.diff.s, 1991, 2019, interval=1,row_names = rownames(consump.fossils.diff.s))

# We discard the countries which are not going to be used, as well as the EU totals 
consump.oil.petr.diff.total <- consump.oil.petr.diff[3,]
consump.gas.diff.total <- consump.gas.diff[3,]
consump.fossils.diff.total <- consump.fossils.diff[3,]
consump.renew.diff.total <- consump.renew.diff[3,]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in EUstat data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(consump.oil.petr.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(consump.oil.petr.diff)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]

gdp.diff.total<-as.numeric(colSums(gdp.diff,na.rm=T))[1:40] #we have data until 2100,                                                               so we keep only until 2030
pop.diff.total<-as.numeric(colSums(pop.diff,na.rm=T))[1:40]

```





Since we are working with time series, where there is a strong temporal dependence, from now on each time we are constructing a model we check the correlation of the residuals using the (partial) autocorrelation function. This is important to understand whether the model is able to capture the relations in original data or whether it is better to perform a first order differentiation to mitigate the natural collinearity problem of these datasets. With this idea in mind, we initially fit the models with original data and then saw whether it is necessary or not to switch to the yearly variations.


## EU_NON_RENEWABLE CONSUMPTIONS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION

Includes three models, one for each non-renewable energy:
    - EU_PETROLEUM  ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
    - EU_SOLID FOSSIL FUELS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
    - EU_NATURAL GAS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION

```{r}
gdp.train <- gdp.total[1:30] #from 1990 until 2019
pop.train <- pop.total[1:30]

gdp.pred <- gdp.total[31:41]
pop.pred <- pop.total[31:41]
```


```{r}
#Eu total data
vec_oil <- t(rbind(consump.oil.petr.europe,gdp.train,pop.train))
vec_oil <- data.frame(vec_oil)
colnames(vec_oil)=c("oil_eu","gdp_eu","pop_eu")

vec_oil_pred <- cbind(gdp.pred, pop.pred)
vec_oil_pred <- data.frame(vec_oil_pred)

colnames(vec_oil_pred) <- c("gdp_eu","pop_eu")

vec_fossil <- t(rbind(consump.fossils.europe,gdp.train, pop.train))
vec_fossil <- data.frame(vec_fossil)
colnames(vec_fossil)=c("fossil_eu","gdp_eu","pop_eu")

vec_fossil_pred=vec_oil_pred

vec_gas <- t(rbind(consump.gas.europe,gdp.train, pop.train))
vec_gas <- data.frame(vec_gas)
colnames(vec_gas)=c("gas_eu","gdp_eu","pop_eu")

vec_gas_pred=vec_oil_pred
```

### Oil & Petr.
```{r}
with(vec_oil,plot(gdp_eu,oil_eu))

with(vec_oil,plot(pop_eu,oil_eu))
```

```{r}
consump.oil.petr.gam <- gam(oil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') +s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

Let's see if we can discard the interaction term (residuals are gaussian)

```{r}
oil_petr_reduced=gam(oil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr'),
                           data = vec_oil)
anova(oil_petr_reduced,consump.oil.petr.gam,test="F")
```

so we can discard the interaction term

```{r}
consump.oil.petr.gam <- gam(oil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') ,
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```


```{r}
Pacf(consump.oil.petr.gam$residuals)
```


### Fossils
```{r}
with(vec_fossil,plot(gdp_eu,fossil_eu))

with(vec_fossil,plot(pop_eu,fossil_eu))
```

```{r}
consump.fossils.gam <- gam(fossil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```


```{r}
Pacf( 
  consump.fossils.gam$residuals
)
```

### Natural gas
```{r}
with(vec_gas,plot(gdp_eu,gas_eu))

with(vec_gas,plot(pop_eu,gas_eu))
```


```{r}
consump.gas.gam <- gam(gas_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)

```
Let's try to quit the interaction (residuals are gaussian)

```{r}
T0 <- summary.aov(aov(gam(gas_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas)))[[1]][3,4]

aov.H0= aov(gam(gas_eu ~ s(gdp_eu,bs='cr')  + s(pop_eu,bs='cr'),
                           data = vec_gas))
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),data = vec_gas)))[[1]][3,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

```{r}
gas_reduced=gam(gas_eu ~ s(pop_eu,bs='cr') + s(gdp_eu,bs='cr'),data=vec_gas)
anova(gas_reduced,consump.gas.gam,test="F")
```
We cannot discard the interaction, let's try with the gdp

```{r}
T0 <- summary.aov(aov(gam(gas_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas)))[[1]][1,4]

aov.H0= aov(gam(gas_eu ~  s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas))
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),data = vec_gas)))[[1]][1,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```
So we don't quit gdp either

```{r}
Pacf(
  consump.gas.gam$residuals
)
```
Since the correlations are not negligible, we pass to first order differences

## DIFF_NON_RENEWABLE CONSUMPTIONS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION

Includes three models, one for each non-renewable energy:
    - DIFF_EU_PETROLEUM  ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION
    - DIFF_EU_SOLID FOSSIL FUELS ~ DIFF_EU_GDP + DIFF_EU_POPULATION +                                                                            DIFF_EU_GDP:DIFF_EU_POPULATION
    - DIFF_EU_NATURAL GAS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION

```{r}
gdp.train <- gdp.diff.total[1:29]
pop.train <- pop.diff.total[1:29]

gdp.pred  <- gdp.diff.total[30:40]
pop.pred  <- pop.diff.total[30:40]
```




```{r}

vec_oil.diff <- t(rbind(consump.oil.petr.diff.total,gdp.train,pop.train))
vec_oil.diff <- data.frame(vec_oil.diff)
colnames(vec_oil.diff) <- c("dif_oil_eu","dif_gdp_eu","dif_pop_eu")

# Variables to predict oil
vec_oil_pred.diff <- cbind(gdp.pred, pop.pred)
vec_oil_pred.diff <- data.frame(vec_oil_pred.diff)

colnames(vec_oil_pred.diff) <- c("dif_gdp_eu","dif_pop_eu")

vec_fossil.diff <- t(rbind(consump.fossils.diff.total,gdp.train, pop.train))
vec_fossil.diff <- data.frame(vec_fossil.diff)
colnames(vec_fossil.diff) <- c("dif_fossil_eu","dif_gdp_eu","dif_pop_eu")

# Variables to predict ff
vec_fossil_pred.diff = vec_oil_pred.diff

colnames(vec_fossil_pred.diff) <- c("dif_gdp_eu","dif_pop_eu")

vec_gas.diff <- t(rbind(consump.gas.diff.total,gdp.train, pop.train))
vec_gas.diff <- data.frame(vec_gas.diff)
colnames(vec_gas.diff) <- c("dif_gas_eu","dif_gdp_eu","dif_pop_eu")

# Variables to predict gas
vec_gas_pred.diff=vec_fossil_pred.diff

```




### Oil & Petr.
```{r}
with(vec_oil.diff,plot(dif_gdp_eu,dif_oil_eu))
with(vec_oil.diff,plot(dif_pop_eu,dif_oil_eu))

```


```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_oil.diff) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```
We try to quit the interaction term (residuals are gaussian)

```{r}
T0 <- summary.aov(aov(gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_oil.diff) ))[[1]][3,4]

aov.H0= aov(gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') ,data = vec_oil.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_oil.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_oil.diff) ))[[1]][3,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

So we can quit the interaction term
```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_oil.diff) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

Let's try to quit pop too (residuals are gaussian)
```{r}
oil_reduced=gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') ,data = vec_oil.diff)
anova(oil_reduced,consump.oil.petr.gam,test="F")
```
So we can quit population too

```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') ,data = vec_oil.diff) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

We now test whether the smooth function is needed for the covariates or if it is sufficient (or even better...) to consider a linear relationship

```{r}
consump.oil.petr.gam.1 <- lm(dif_oil_eu ~ bs(dif_gdp_eu) + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,data = vec_oil.diff) 

summary(consump.oil.petr.gam.1)

hist(consump.oil.petr.gam.1$residuals)
qqnorm(consump.oil.petr.gam.1$residuals)
shapiro.test(consump.oil.petr.gam.1$residuals)
```
```{r}
consump.oil.petr.gam.2 <- lm(dif_oil_eu ~ bs(dif_gdp_eu) + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff) 

summary(consump.oil.petr.gam.2)

hist(consump.oil.petr.gam.2$residuals)
qqnorm(consump.oil.petr.gam.2$residuals)
shapiro.test(consump.oil.petr.gam.2$residuals)
```

```{r}
consump.oil.petr.gam.3 <- gam(dif_oil_eu ~ dif_gdp_eu + bs(dif_pop_eu)+ bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```
The third one seems promising, let's try to quit pop from it (residuals are gaussian)

```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu + bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff)
anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```

We can quit pop

```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu +  bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

We try to reduce the degree of the interaction term as well (residuals are gaussian)

```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu +  bs(I(dif_gdp_eu*dif_pop_eu),degree=2),data = vec_oil.diff) 
anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```

We can reduce the interaction degree

```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu +  bs(I(dif_gdp_eu*dif_pop_eu),degree=2),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

Reduce again? (residuals are gaussian)
```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu +  bs(I(dif_gdp_eu*dif_pop_eu),degree=1),data = vec_oil.diff) 
anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```

We can reduce to degree 1

```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu +  bs(I(dif_gdp_eu*dif_pop_eu),degree=1),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

Completely quit interaction? (gaussian residuals)
```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu ,data = vec_oil.diff) 
anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```

Yes, we quit it completely
```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu ,data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

Let's try to quit two smooth terms at a time
```{r}
consump.oil.petr.gam.1 <- lm(dif_oil_eu ~ dif_gdp_eu + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,data = vec_oil.diff) 

summary(consump.oil.petr.gam.1)

hist(consump.oil.petr.gam.1$residuals)
qqnorm(consump.oil.petr.gam.1$residuals)
shapiro.test(consump.oil.petr.gam.1$residuals)
```

```{r}
consump.oil.petr.gam.2 <- lm(dif_oil_eu ~ dif_gdp_eu + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,data = vec_oil.diff) 

summary(consump.oil.petr.gam.2)

hist(consump.oil.petr.gam.2$residuals)
qqnorm(consump.oil.petr.gam.2$residuals)
shapiro.test(consump.oil.petr.gam.2$residuals)
```

```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

From the third let's try to reduce the interaction degree to one (residuals are gaussian)

```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu),degree=1),data = vec_oil.diff) 
anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```

We can
```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu),degree=1),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

Should we quit the interaction? (gaussian residuals)

```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu,data = vec_oil.diff)

anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```
Quit it

```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu ,data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

```{r}
consump.oil.petr.gam=consump.oil.petr.gam.3

Acf(  consump.oil.petr.gam$residuals
)
Pacf(
  consump.oil.petr.gam$residuals
)
```



### Fossils

```{r}
with(vec_fossil.diff,plot(dif_gdp_eu,dif_fossil_eu))
with(vec_fossil.diff,plot(dif_pop_eu,dif_fossil_eu))
```


```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_fossil.diff) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
Let's try to quit the interaction (residuals are gaussian)

```{r}
fossil_reduced=gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') ,data = vec_fossil.diff)
anova(fossil_reduced,consump.fossils.gam,test="F")
```

We can quit the interaction term

```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_fossil.diff) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```

Let's try to quit gdp as well (residuals are gaussian)
```{r}
T0 <- summary.aov(aov(gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') ,data = vec_fossil.diff) ))[[1]][1,4]

aov.H0= aov(gam(dif_fossil_eu ~ s(dif_pop_eu,bs='cr') ,data = vec_fossil.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_fossil.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_fossil.diff) ))[[1]][1,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit it
```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_pop_eu,bs='cr'),data = vec_fossil.diff) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```

```{r}
Acf( 
  consump.fossils.gam$residuals
)
```

```{r}
Pacf( 
  consump.fossils.gam$residuals
)
```



### Natural gas
```{r}
with(vec_gas.diff,plot(dif_gdp_eu,dif_gas_eu))
with(vec_gas.diff,plot(dif_pop_eu,dif_gas_eu))
```

```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas.diff) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```

Let's try to quit gdp (residuals are gaussian)
```{r}
gas_reduced=gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_gas.diff)
anova(gas_reduced,consump.gas.gam,test="F")
```

We can quit gdp

```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas.diff) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```


Trying to quit interaction as well (residuals are gaussian)
```{r}
gas_reduced=gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') ,data = vec_gas.diff)
anova(gas_reduced,consump.gas.gam,test="F")
```

We can quit the interaction too

```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr'), data = vec_gas.diff) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```
Let's try again with some linear contributions

```{r}
consump.gas.gam.1 <- lm(dif_gas_eu ~ bs(dif_gdp_eu) + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.1)

hist(consump.gas.gam.1$residuals)
qqnorm(consump.gas.gam.1$residuals)
shapiro.test(consump.gas.gam.1$residuals)
```

```{r}
consump.gas.gam.2 <- lm(dif_gas_eu ~ bs(dif_gdp_eu) + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) 
summary(consump.gas.gam.2)

hist(consump.gas.gam.2$residuals)
qqnorm(consump.gas.gam.2$residuals)
shapiro.test(consump.gas.gam.2$residuals)
```

```{r}
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu) + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```
From the third, let's try to quit the interaction (residuals are gaussian)


```{r}
T0 <- summary.aov(aov(lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu) + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) ))[[1]][3,4]

aov.H0= aov(lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu) ,
                           data = vec_gas.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(lm(risposta.perm.H0 ~ dif_gdp_eu + bs(dif_pop_eu) + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) ))[[1]][3,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit the interaction

```{r}
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu),
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

Let's try to quit population (residual are not gaussian)
```{r}
T0 <- summary.aov(aov(lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu),
                           data = vec_gas.diff) ))[[1]][2,4]

aov.H0= aov(lm(dif_gas_eu ~ dif_gdp_eu ,
                           data = vec_gas.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(lm(risposta.perm.H0 ~ dif_gdp_eu + bs(dif_pop_eu),
                           data = vec_gas.diff) ))[[1]][2,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit population

```{r}
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

We quit two smooth terms at a time

```{r}
consump.gas.gam.1 <- lm(dif_gas_eu ~ bs(dif_gdp_eu) + dif_pop_eu + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.1)

hist(consump.gas.gam.1$residuals)
qqnorm(consump.gas.gam.1$residuals)
shapiro.test(consump.gas.gam.1$residuals)
```

```{r}
consump.gas.gam.2 <- lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.2)

hist(consump.gas.gam.2$residuals)
qqnorm(consump.gas.gam.2$residuals)
shapiro.test(consump.gas.gam.2$residuals)
```

```{r}
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

From the third let's try to quit the interaction (residuals are not gaussian)

```{r}
T0 <- summary.aov(aov(lm(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) ))[[1]][3,4]

aov.H0= aov(lm(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu,data = vec_gas.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(lm(risposta.perm.H0 ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) ))[[1]][3,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit the interaction

```{r}
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu ,
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

We try to quit population too (residuals are gaussian)
```{r}
gas_reduced=lm(dif_gas_eu ~ dif_gdp_eu,
                           data = vec_gas.diff)
anova(gas_reduced,consump.gas.gam.3,test="F")
```

We can quit population too

```{r}
consump.gas.gam.3 <- gam(dif_gas_eu ~ dif_gdp_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

No good..., from the number one let's try to quit gdp
```{r}
summary(consump.gas.gam.1)
shapiro.test(consump.gas.gam.1$residuals)
```

Residuals are not gaussian
```{r}
T0 <- summary.aov(aov(lm(dif_gas_eu ~bs(dif_gdp_eu) + dif_pop_eu + dif_gdp_eu:dif_pop_eu ,data = vec_gas.diff) ))[[1]][1,4]

aov.H0= aov(lm(dif_gas_eu ~  dif_pop_eu + dif_gdp_eu:dif_pop_eu ,data = vec_gas.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ bs(dif_gdp_eu) + dif_pop_eu + dif_gdp_eu:dif_pop_eu,data = vec_gas.diff) ))[[1]][1,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We quit gdp
```{r}
consump.gas.gam.1 <- lm(dif_gas_eu ~  dif_pop_eu + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.1)

hist(consump.gas.gam.1$residuals)
qqnorm(consump.gas.gam.1$residuals)
shapiro.test(consump.gas.gam.1$residuals)
```

Finally!!!
```{r}
consump.gas.gam=consump.gas.gam.1
```


### Predictions for 2020-2030
```{r}
summary(consump.oil.petr.gam)
summary(consump.fossils.gam)
summary(consump.gas.gam)
```


```{r}
# Preds (2020-2030)

consump.oil.petr.gam.preds <- predict(consump.oil.petr.gam, newdata=vec_oil_pred.diff, se=T)

consump.fossils.gam.preds <- predict(consump.fossils.gam, newdata=vec_fossil_pred.diff, se=T)

consump.gas.gam.preds <- predict(consump.gas.gam, newdata=vec_gas_pred.diff, se=T)
```


Plot predictions
```{r}
# See graphs
with(vec_oil.diff, plot(seq(1991,2019) ,dif_oil_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Oil & Petr.'))
points(seq(2020,2030), consump.oil.petr.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.oil.petr.gam$fitted.values,lwd=1,col="blue")
lines(seq(1991,2030),rep(0,length(seq(1991,2030))),lty=2,lwd=1,col =" darkgrey ")


with(vec_fossil.diff, plot(seq(1991,2019) ,dif_fossil_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Fossil fuels'))
points(seq(2020,2030), consump.fossils.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.fossils.gam$fitted.values,lwd=1,col="blue")
lines(seq(1991,2030),rep(0,length(seq(1991,2030))),lty=2,lwd=1,col =" darkgrey ")



with(vec_gas.diff, plot(seq(1991,2019) ,dif_gas_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Natural Gas'))
points(seq(2020,2030), consump.gas.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.gas.gam$fitted.values,lwd=1,col="blue")
lines(seq(1991,2030),rep(0,length(seq(1991,2030))),lty=2,lwd=1,col =" darkgrey ")


```

We proceeded with yearly variations framework also for the following models


## DIFF_EU_RENEWABLE CONSUMPTIONS  ~ DIFF_EU_PETROLEUM  + DIFF_EU_SOLID FOSSILFUELS + DIFF_EU_NATURAL GAS + interactions

```{r}
# Join all energies for common DF
vec_re <- cbind(as.numeric(consump.renew.diff.total[1,]),vec_oil.diff$dif_oil_eu,vec_fossil.diff$dif_fossil_eu, vec_gas.diff$dif_gas_eu)

vec_re <- data.frame(vec_re)
colnames(vec_re) <- c("value_re", "value_oil", "value_ff", "value_ng")
```

We need smoothing also on oil,fossil fuels and natural gas differences, to fit a more complex mode with interactions

```{r}
rownames(vec_re)=years_90_19[2:30]
vec_re.temp=t(vec_re)
vec_re.s=smoothing_procedure(vec_re.temp,1991,2019,interval=3)
rownames(vec_re.s)=rownames(vec_re.temp)
vec_re.s=data.frame(t(vec_re.s))
```

```{r}
with(vec_re.s,plot(value_oil,value_re,main="Diff renewables vs diff oil"))
with(vec_re.s,plot(value_ff,value_re,main="Diff renewables vs diff fossil fuels"))
with(vec_re.s,plot(value_ng,value_re,main="Diff renewables vs diff natural gas"))

```


```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil,bs='cr') + s(value_ff,bs='cr') + s(value_ng,bs='cr') + s(I(value_oil*value_ff),bs='cr') + s(I(value_ff*value_ng),bs='cr') + s(I(value_oil*value_ng),bs='cr') + s(I(value_oil*value_ff*value_ng),bs='cr'), data=vec_re.s)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```

Let's try to quit natural gas and oil - fossil fuels interaction (residuals are gaussian)

```{r}
ren_reduced=gam(value_re ~ s(value_oil, bs = "cr") + s(value_ff, bs = "cr")  + s(I(value_ff * value_ng), bs = "cr") +s(I(value_oil * value_ng), bs = "cr") + s(I(value_oil *value_ff * value_ng), bs = "cr"),
                data = vec_re.s)
anova(ren_reduced,consump.renew.gam,test="F")
```

We can quit them

```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil, bs = "cr") + s(value_ff, bs = "cr")  + s(I(value_ff * value_ng), bs = "cr") +s(I(value_oil * value_ng), bs = "cr") + s(I(value_oil *value_ff * value_ng), bs = "cr"),
                data = vec_re.s)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```


```{r}
Acf(consump.renew.gam$residuals)
```



```{r}
Pacf(consump.renew.gam$residuals)
```



### Predictions for 2020-2030
```{r}
oil.preds.s=data.frame(t(consump.oil.petr.gam.preds$fit))
colnames(oil.preds.s)=seq(2020,2030)
oil.preds.s=smoothing_procedure(oil.preds.s,2020,2030,interval=3)

ff.preds.s=data.frame(t(consump.fossils.gam.preds$fit))
colnames(ff.preds.s)=seq(2020,2030)
ff.preds.s=smoothing_procedure(ff.preds.s,2020,2030,interval=3)

gas.preds.s=data.frame(t(consump.gas.gam.preds$fit))
colnames(gas.preds.s)=seq(2020,2030)
gas.preds.s=smoothing_procedure(gas.preds.s,2020,2030,interval=3)
```



```{r}
vec_re_pred <- t(rbind(oil.preds.s,ff.preds.s, gas.preds.s))
vec_re_pred <- data.frame(vec_re_pred)
colnames(vec_re_pred) <- c("value_oil", "value_ff", "value_ng")


consump.renew.gam.preds <- predict(consump.renew.gam, newdata=vec_re_pred, se=T)
```




```{r}
# See graphs
with(vec_re, plot(seq(1991,2019) ,value_re ,xlim=c(1991,2030),cex=.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Renewable Energy Consumption'))
points(seq(2020,2030,1/3), consump.renew.gam.preds$fit ,cex=1, col ="red")
lines(seq(1991,2019,1/3),consump.renew.gam$fitted.values,col="blue",lwd=1)
lines(seq(1991,2030,1/3),rep(0,length(seq(1991,2030,1/3))),lwd=1,lty=2,col =" darkgrey ")

```



```{r}
renew.predictions=data.frame(t(consump.renew.gam.preds$fit))
colnames(renew.predictions)=seq(2020,2030,1/3)
renew.predictions=renew.predictions[1,as.character(seq(2020,2030))]
```

```{r}
(renew.predictions.total=consump.renew.europe[,30]+cumsum(as.numeric(renew.predictions)))
```


## DIFF_TOTAL_GHG ~  DIFF_TOTAL_RENEWABLE CONSUMPTION



```{r}
ghg=read.xlsx("data/ghg_emissions.xlsx", sheet=3, colNames=F)

ghg <- na.omit(ghg) # Remove NA values
#ghg=data.frame(t(ghg[,-1])) # Remove column names 
#ghg <- ghg[!apply(ghg == "", 1, all), ] # Remove empty values

ghg <- data.frame(lapply(ghg, as.numeric)) # Set cells as numeric
ghg=data.frame(t(ghg))
rownames(ghg) <- years_90_19

#ghg <- ghg[-c(1,2)]
colnames(ghg)="ValueGhg"

head(ghg)

```



```{r}
plot(years_90_19,ghg$ValueGhg,xlab="Years",ylab="Percentage emissions",main="Percentage of Ghg emissions wrt 1990")
```



```{r}
ghg.diff=data.frame(diff_ghg=diff(ghg$ValueGhg))
```

```{r}
plot(seq(1991,2019),ghg.diff$diff_ghg,xlab="Years",ylab="Percentage emissions",main="Variations of percentage of Ghg emissions wrt 1990")
```


```{r}
#using differences for covariates
vec_ghg.diff= cbind(ghg.diff$diff_ghg,vec_re$value_re,vec_oil.diff$dif_gdp_eu,vec_oil.diff$dif_pop_eu)
vec_ghg.diff <- data.frame(vec_ghg)
vec_ghg_pred.diff <- data.frame(t(renew.predictions),vec_oil_pred.diff$dif_gdp_eu,vec_oil_pred.diff$dif_pop_eu)

colnames(vec_ghg) <- c("value_ghg", "value_re","value_gdp","value_pop")
colnames(vec_ghg_pred.diff) <- c("value_re","value_gdp","value_pop")

```




```{r}
#using original data for covariates (Greenhouse gases still in differences)
vec_c02= cbind(Co2.diff$diff_co2,t(consump.renew.europe[,2:30]),gdp.total[2:30],pop.total[2:30])
vec_c02 <- data.frame(vec_c02)
vec_c02_pred <- data.frame(t(renew.predictions.total),gdp.total[31:41],pop.total[31:41])

colnames(vec_c02) <- c("value_ghg", "value_re","value_gdp","value_pop")
colnames(vec_c02_pred) <- c("value_re","value_gdp","value_pop")

```



```{r}
rownames(vec_ghg.diff)=years_90_19[2:30]
vec_ghg.temp=t(vec_ghg.diff)
vec_ghg.diff.s=smoothing_procedure(vec_ghg.temp,1991,2019,interval=3)
rownames(vec_ghg.diff.s)=rownames(vec_ghg.temp)
vec_ghg.diff.s=data.frame(t(vec_ghg.diff.s))
View(vec_ghg.diff.s)
```

```{r}
vec_ghg_pred.temp=t(vec_ghg_pred.diff)
vec_ghg_pred.diff.s=smoothing_procedure(vec_ghg_pred.temp,2020,2030,interval=3)
rownames(vec_ghg_pred.diff.s)=rownames(vec_ghg_pred.temp)
vec_ghg_pred.diff.s=data.frame(t(vec_ghg_pred.diff.s))
```

```{r}
with(vec_ghg.diff.s,plot(value_re,value_ghg,main="Diff ghg vs diff renewables"))
with(vec_ghg.diff.s,plot(value_gdp,value_ghg,main="Diff ghg vs diff gdp"))
with(vec_ghg.diff.s,plot(value_pop,value_ghg,main="Diff ghg vs diff pop"))

```

```{r}
ghg.gam <- gam(value_ghg ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr') + s(I(value_re*value_gdp),bs='cr') + s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') + s(I(value_re*value_gdp*value_pop),bs='cr'), data=vec_ghg.diff.s)

summary(ghg.gam)

hist(ghg.gam$residuals)
qqnorm(ghg.gam$residuals)
shapiro.test(ghg.gam$residuals)
```

Let's try to quit renewables-gdp interaction (non gaussian residuals)
```{r}
T0 <- summary.aov(aov(gam(value_ghg ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr') + s(I(value_re*value_gdp),bs='cr') + s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') + s(I(value_re*value_gdp*value_pop),bs='cr'), data=vec_ghg.diff.s) ))[[1]][4,4]

aov.H0= aov(gam(value_ghg ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr')  + s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') + s(I(value_re*value_gdp*value_pop),bs='cr'), data=vec_ghg.diff.s) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_ghg.diff.s)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr') + s(I(value_re*value_gdp),bs='cr')+ s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') + s(I(value_re*value_gdp*value_pop),bs='cr'), data=vec_ghg.diff.s) ))[[1]][4,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit it

```{r}
ghg.gam <- gam(value_ghg ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr')+ s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') + s(I(value_re*value_gdp*value_pop),bs='cr'), data=vec_ghg.diff.s)

summary(ghg.gam)

hist(ghg.gam$residuals)
qqnorm(ghg.gam$residuals)
shapiro.test(ghg.gam$residuals)
```


Let's try to quit the triple interaction (non gaussian residuals)
```{r}
T0 <- summary.aov(aov(gam(value_ghg ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr') +  s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') + s(I(value_re*value_gdp*value_pop),bs='cr'), data=vec_ghg.diff.s) ))[[1]][6,4]

aov.H0= aov(gam(value_ghg ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr')  + s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr'), data=vec_ghg.diff.s) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_ghg.diff.s)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr') + s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') + s(I(value_re*value_gdp*value_pop),bs='cr'), data=vec_ghg.diff.s) ))[[1]][6,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit the triple interaction too
```{r}
ghg.gam <- gam(value_ghg ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr')+ s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') , data=vec_ghg.diff.s)

summary(ghg.gam)

hist(ghg.gam$residuals)
qqnorm(ghg.gam$residuals)
shapiro.test(ghg.gam$residuals)
```

Quit renewables? (gaussian residuals)
```{r}
ghg_reduced=gam(value_ghg ~  s(value_gdp,bs='cr') + s(value_pop,bs='cr')+ s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') , data=vec_ghg.diff.s)
anova(ghg_reduced,ghg.gam,test="F")
```

We cannot quit renewables, so we have our final model

```{r}
Acf(ghg.gam$residuals)

```

```{r}
Pacf(ghg.gam$residuals)
```


```{r}
#simple baseline model
ghg.gam.b <- gam(value_ghg ~ s(value_re,bs='cr'), data=vec_ghg.diff)

summary(ghg.gam.b)

hist(ghg.gam.b$residuals)
qqnorm(ghg.gam.b$residuals)
shapiro.test(ghg.gam.b$residuals)
```

```{r}
Pacf(ghg.gam.b$residuals)
```


```{r}
#predictions with simple model
ghg.gam.preds.b <- predict(ghg.gam.b, newdata=vec_ghg_pred.diff, se=T)

with(vec_ghg.diff, plot(seq(1991,2019) ,value_ghg ,xlim=c(1990,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Ghg Emissions'))
points(seq(2020,2030),ghg.gam.preds.b$fit ,cex=0.5, col ="red")
lines(seq(1991,2019),ghg.gam.b$fitted.values,lwd=1,col="blue")
lines(seq(1991,2030,1/3),rep(0,length(seq(1991,2030,1/3))),col="darkgrey",lty=2)
```


### Predicted decrease
How much is the predicted decrease?
```{r}
ghg.gam.preds <- predict(ghg.gam, newdata=vec_ghg_pred.diff.s, se=T)

with(vec_ghg.diff, plot(seq(1991,2019) ,value_ghg ,xlim=c(1990,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Ghg Emissions'))
points(seq(2020,2030,1/3),ghg.gam.preds$fit ,cex=0.5, col ="red")
lines(seq(1991,2019,1/3),ghg.gam$fitted.values,lwd=1,col="blue")
lines(seq(1991,2030,1/3),rep(0,length(seq(1991,2030,1/3))),col="darkgrey",lty=2)
```




```{r}
idx_deltas=seq(1,length(ghg.gam.preds$fit),by=3)
deltas=as.numeric(ghg.gam.preds$fit[idx_deltas])
Percentage_emissions=ghg[30,1]+cumsum(deltas)
Percentage_decrease=as.numeric(100-Percentage_emissions[11])

Percentage_emissions
Percentage_decrease
```

```{r}
#with baseline model
deltas.b=as.numeric(ghg.gam.preds.b$fit)
Percentage_emissions.b=ghg[30,1]+cumsum(deltas.b)
Percentage_decrease.b=as.numeric(100-Percentage_emissions.b[11])

Percentage_emissions.b
Percentage_decrease.b
```

```{r}
with(ghg, plot(seq(1990,2019) ,ValueGhg ,xlim=c(1990,2030),ylim=c(40,100),cex =.5,xlab="Year",ylab="Percentage" , col =" darkgrey ",main='GAM Prediction - Ghg Emissions'))
points(seq(2020,2030),Percentage_emissions,cex=.5,col="green")
lines(seq(1990,2030),rep(45,length(seq(1990,2030))),col="darkgrey",lty=2)
```


A cut of 48.23% is expected with the actual rhythm, so more effort is needed in order to comply with the Green Deal objective!


```{r}
#with baseline model
with(ghg, plot(seq(1990,2019) ,ValueGhg ,xlim=c(1990,2030),ylim=c(40,100),cex =.5,xlab="Year",ylab="Percentage" , col =" darkgrey ",main='GAM Prediction - Ghg Emissions'))
points(seq(2020,2030),Percentage_emissions.b,cex=.5,col="green")
lines(seq(1990,2030),rep(45,length(seq(1990,2030))),col="darkgrey",lty=2)
```


Let's also compute the conformal prediction intervals
```{r}
train_gam_ghg <- function(x,y,out=NULL){
    train_data=data.frame(y,x)
    colnames(x)=c("value_re","value_gdp", "value_pop")
    model_gam= gam(y ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr')+ s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr') , 
    data = train_data)
}


predict_gam_ghg <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("value_re","value_gdp", "value_pop")
    as.numeric(predict(obj,new_x))
}
```


```{r}
c_preds.ghg <- conformal.pred(
    vec_ghg.diff.s[,-1], 
    vec_ghg.diff.s[,1],
    as.matrix(rbind(vec_ghg.diff[,-1],vec_ghg_pred.diff)),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam_ghg, 
    predict.fun = predict_gam_ghg)
```
```{r}
plot(seq(1991,2019), vec_ghg.diff$value_ghg, xlim=range(c(1990,2030)),cex =.5,xlab="Year",ylab="Diff percentage",col =" darkgrey ",main='GAM conformal prediction - Ghg percentage variations',ylim=c(-10,10))

lines(seq(1991,2030),c_preds.ghg$pred,lwd =2, col ="green",lty=3)
lines(seq(1991,2030),c_preds.ghg$up,lwd =1, col =" blue",lty =3)
lines(seq(1991,2030),c_preds.ghg$lo, lwd =1, col =" blue",lty =3)
lines(seq(1991,2019,1/3),c_preds.ghg$fit, lwd =1, col =" green",lty =1)
```

```{r}
lo_perc=ghg[30,1]+cumsum(c_preds.ghg$lo[30:40])
up_perc=ghg[30,1]+cumsum(c_preds.ghg$up[30:40])
for (i in 1:11){
  lo_perc[i]=max(0,lo_perc[i])
  up_perc[i]=min(100,up_perc[i])

}
```


```{r}
with(ghg, plot(seq(1990,2019) ,ValueGhg ,xlim=c(1990,2030),ylim=c(0,100),cex =.5,xlab="Year",ylab="Percentage" , col =" darkgrey ",main='GAM Prediction - Ghg Emissions'))
points(seq(2020,2030),Percentage_emissions,cex=.5,col="green")
lines(seq(1990,2030),rep(45,length(seq(1990,2030))),col="darkgrey",lty=2)
lines(seq(2020,2030),lo_perc,col="green",lty=2)
lines(seq(2020,2030),up_perc,col="green",lty=2)

```


```{r}
#with baseline model

train_gam_ghg.b <- function(x,y,out=NULL){
    colnames(x)=c("value_re")
    train_data=data.frame(y,x)
    
    model_gam= gam(y ~ s(value_re,bs='cr'), 
    data = train_data)
}


predict_gam_ghg.b <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("value_re")
    as.numeric(predict(obj,new_x))
}

c_preds.ghg.b <- conformal.pred(
    vec_ghg.diff[,2], 
    vec_ghg.diff[,1],
    as.matrix(c(vec_ghg.diff[,2],vec_ghg_pred.diff[,1])),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam_ghg.b, 
    predict.fun = predict_gam_ghg.b)
```

```{r}
plot(seq(1991,2019), vec_ghg.diff$value_ghg, xlim=range(c(1990,2030)),cex =.5,xlab="Year",ylab="Diff percentage",col =" darkgrey ",main='GAM conformal prediction - Ghg percentage variations',ylim=c(-10,10))

lines(seq(1991,2030),c_preds.ghg.b$pred,lwd =2, col ="green",lty=3)
lines(seq(1991,2030),c_preds.ghg.b$up,lwd =1, col =" blue",lty =3)
lines(seq(1991,2030),c_preds.ghg.b$lo, lwd =1, col =" blue",lty =3)
lines(seq(1991,2019),c_preds.ghg.b$fit, lwd =1, col =" green",lty =1)
```


```{r}
lo_perc.b=ghg[30,1]+cumsum(c_preds.ghg.b$lo[30:40])
up_perc.b=ghg[30,1]+cumsum(c_preds.ghg.b$up[30:40])
for (i in 1:11){
  lo_perc.b[i]=max(0,lo_perc.b[i])
  up_perc.b[i]=min(100,up_perc.b[i])

}

with(ghg, plot(seq(1990,2019) ,ValueGhg ,xlim=c(1990,2030),ylim=c(0,100),cex =.5,xlab="Year",ylab="Percentage" , col =" darkgrey ",main='GAM Prediction - Ghg Emissions'))
points(seq(2020,2030),Percentage_emissions.b,cex=.5,col="green")
lines(seq(1990,2030),rep(45,length(seq(1990,2030))),col="darkgrey",lty=2)
lines(seq(2020,2030),lo_perc.b,col="green",lty=2)
lines(seq(2020,2030),up_perc.b,col="green",lty=2)
```

# Robustness

```{r}
library(robustbase)
library(psych)
library(MASS)
library(ellipse)
library(here)
library(DescTools)
library(knitr)
library(RobStatTM)
```


## a. Test for outliers in diff dataset

Objective: Try to spot the most extreme cases (countries) in our dataset(s), where our model could struggle the most when trying to predict future values. 

```{r}
# Standarization on differences of each country since MCD depends on Mahalannobis distance 
sd.consump.ff.diff <- t(scale(t(consump.fossils.diff.s)))
sd.consump.oil.diff <- t(scale(t(consump.oil.petr.diff.s)))
sd.consump.gas.diff <- t(scale(t(consump.gas.diff.s)))

sd.consump.renew.diff <- t(scale(t(consump.renew.diff[-1,])))

# REVIEW: check if just from 1991-2019
sd.pop.diff <- t(scale(t(pop.diff[,1:29])))
sd.gdp.diff <- t(scale(t(gdp.diff[,1:29])))

matplot(t(sd.consump.ff.diff), type="l")
matplot(t(sd.consump.oil.diff), type="l")
matplot(t(sd.consump.gas.diff), type="l")

matplot(t(sd.consump.renew.diff), type="l")

matplot(t(sd.gdp.diff), type="l")
matplot(t(sd.pop.diff), type="l")
```


```{r}
### MCD on dataset of various energies

alpha <- .75
```


### a1. For Non-renewable energy consumption
Using Fossil fuels, Oil & petroleum and Natural Gas
```{r}
## N -> countries
## p -> each year
# (E.g. on Fossil fuels consumption)

# WARNING: We expect to obtain bad results since MCD handles p > n problems badly

# fit_MCD.1 <- covMcd(x = consump.fossils.diff.s, alpha = .75, nsamp = "best")
fit_MCD.1 <- covMcd(x = sd.consump.ff.diff, alpha = alpha, nsamp = "best")

mcd_best.1 <- fit_MCD.1$best

N <- nrow(consump.fossils.diff.s)
p <- ncol(consump.fossils.diff.s)
plot(consump.fossils.diff.s[,1:5], col=ifelse(1:N%in%mcd_best.1,"black","red"),pch=19)

# Which are the outliers?
rownames(consump.fossils.diff.s)[!(1:N%in%mcd_best.1)]
```


```{r}
## N -> countries
## p -> diff. type of energies/datum
# (E.g. for 1991)

sd.consump.nr.1991 <- data.frame(cbind(sd.consump.ff.diff[,1], sd.consump.gas.diff[,1], sd.consump.oil.diff[,1])) # Combine all NR energy consumptions for 1991
colnames(sd.consump.nr.1991) <- c("FF", "Gas", "Oil") 
rownames(sd.consump.nr.1991) <- rownames(sd.consump.ff.diff)
sd.consump.nr.1991 <- na.omit(sd.consump.nr.1991) # Discard Cyprus and Iceland with NA values in Gas consump.

fit_MCD.2 <- covMcd(x = sd.consump.nr.1991, alpha = alpha, nsamp = "best")

mcd_best.2 <- fit_MCD.2$best

N <- nrow(sd.consump.nr.1991)
p <- ncol(sd.consump.nr.1991)
pairs(sd.consump.nr.1991[,1:3], col=ifelse(1:N%in%mcd_best.2,"black","red"), pch=19)

# Which are the outliers?
rownames(sd.consump.nr.1991)[!(1:N%in%mcd_best.2)]

## Try the former method for each year 1991 - 2019 to see which is the most repeated outliers

nr_outliers_mcd <- function(year, alpha=.75){
    year <- 2020-year
    sd.consump.nr.aux <- data.frame(cbind(sd.consump.ff.diff[,year], sd.consump.gas.diff[,year], sd.consump.oil.diff[,year])) # Combine all NR energy consumptions for 1991
    colnames(sd.consump.nr.aux) <- c("FF", "Gas", "Oil") 
    rownames(sd.consump.nr.aux) <- rownames(sd.consump.ff.diff)
    sd.consump.nr.aux <- na.omit(sd.consump.nr.aux) # Discard Cyprus and Iceland with NA values in Gas consump.
    
    fit_MCD.aux <- covMcd(x = sd.consump.nr.aux, alpha = alpha, nsamp = "best")
    
    mcd_best.aux <- fit_MCD.aux$best
    
    N <- nrow(sd.consump.nr.aux)
    p <- ncol(sd.consump.nr.aux)
    if(plott==T){
        plot(fit_MCD.aux)
    }
    
    # Which are the outliers?
    return(rownames(sd.consump.nr.aux)[!(1:N%in%mcd_best.aux)])
}

# Test for 1991
nr_outliers_mcd(1991)
nr_outliers_mcd(1992)

outliers <- NULL
for(i in 1991:2019){
    outliers <- c(outliers, nr_outliers_mcd(i))
}

# Get 5 most repeated outlying countries in non-renewable energies
outl_occ <- table(outliers)
outl_occ.sort <- outl_occ[order(outl_occ, decreasing = T)]
outl_occ.sort[1:5] # Top 5 outliers

### Plots

top5.outl <- which(rownames(sd.consump.ff.diff) %in% names(outl_occ.sort[1:5])) # Get top 5 most repeated outliers
# For the 1991 data, we can colour this top outliers as:
pairs(sd.consump.nr.1991[,1:3], col=ifelse(1:N%in%top5.outl,"red","black"), pch=19)

# Mahalannobis distance plots,
# Distance distance plots,
# QQplots
# Scree plot
plot(fit_MCD.2, classic=TRUE)
rownames(sd.consump.nr.1991)[c(17,9,16,36)]

```
### a2. For Renewable energy consumption 
Using renwable differences
```{r}
## N -> countries
## p -> each year
# (On the renewable levels)

# WARNING: We expect to obtain bad results since MCD handles p > n problems badly

fit_MCD.3 <- covMcd(x = sd.consump.renew.diff, alpha = alpha, nsamp = "best")

mcd_best.3 <- fit_MCD.3$best

N <- nrow(sd.consump.renew.diff)
p <- ncol(sd.consump.renew.diff)
plot(sd.consump.renew.diff[,1:5], col=ifelse(1:N%in%mcd_best.3,"black","red"),pch=19)

# Which are the outliers?
rownames(sd.consump.renew.diff)[!(1:N%in%mcd_best.3)]

```

We cannot repeat the experiment with N coutnries and each dimension being teh renewable sources, since this would be a univariate dataset, where MCD cannot be applied

### a3. For extra-covariates GDP & Population

The "each year as a dimension" model, as in a1 and a2 will not be skipped.


```{r}
## N -> countries
## p -> 2 (population + gdp)
# (E.g. for 1991)

gdpp_outliers_mcd <- function(year, alpha=.75, plott=F){
    year <- 2020-year
    sd.gdpp.aux <- data.frame(cbind(sd.gdp.diff[,year], sd.pop.diff[,year])) # Combine all NR energy consumptions for 1991
    colnames(sd.gdpp.aux) <- c("GDP", "POP") 
    rownames(sd.gdpp.aux) <- rownames(sd.gdp.diff)
    sd.gdpp.aux <- na.omit(sd.gdpp.aux)
    
    fit_MCD.aux <- covMcd(x = sd.gdpp.aux, alpha = alpha, nsamp = "best")
    
    mcd_best.aux <- fit_MCD.aux$best
    
    N <- nrow(sd.gdpp.aux)
    p <- ncol(sd.gdpp.aux)
    if(plott==T){
        plot(fit_MCD.aux)
    }
    
    # Which are the outliers?
    return(rownames(sd.gdpp.aux)[!(1:N%in%mcd_best.aux)])
}

# Test for 1991
gdpp_outliers_mcd(1991)
gdpp_outliers_mcd(1992)

outliers <- NULL
for(i in 1991:2019){
    outliers <- c(outliers, gdpp_outliers_mcd(i))
}

# Get 5 most repeated outlying countries in non-renewable energies
outl_occ.gdpp <- table(outliers)
outl_occ.sort.gdpp <- outl_occ.gdpp[order(outl_occ.gdpp, decreasing = T)]
outl_occ.sort.gdpp[1:5] # Top 5 outliers


### Plot
gdpp_outliers_mcd(1994, plott=T)

```


## b. Robust linear models

Least Median Squares Regression

```{r}

### LMR
# Core 1. EU_NON_RENEWABLE CONSUMPTIONS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
fit_lms.1 <- lmsreg(oil_eu ~ gdp_eu + pop_eu + gdp_eu*pop_eu,
                           data = vec_oil)

hist(fit_lms.1$residuals)
qqnorm(fit_lms.1$residuals)
shapiro.test(fit_lms.1$residuals)

fit_lms.2 <- lmsreg(fossil_eu ~ gdp_eu + pop_eu + gdp_eu*pop_eu,
                           data = vec_fossil)

hist(fit_lms.2$residuals)
qqnorm(fit_lms.2$residuals)
shapiro.test(fit_lms.2$residuals)

fit_lms.3 <- lmsreg(gas_eu ~ gdp_eu + pop_eu + gdp_eu*pop_eu,
                           data = vec_gas)

hist(fit_lms.3$residuals)
qqnorm(fit_lms.3$residuals)
shapiro.test(fit_lms.3$residuals)

# Core 2. DIFF_NON_RENEWABLE CONSUMPTIONS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION
fit_lms.4 <- lmsreg(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu + dif_gdp_eu*dif_pop_eu,data = vec_oil.diff)

hist(fit_lms.4$residuals)
qqnorm(fit_lms.4$residuals)
shapiro.test(fit_lms.4$residuals)

fit_lms.5 <- lmsreg(dif_fossil_eu ~ dif_gdp_eu + dif_pop_eu + dif_gdp_eu*dif_pop_eu, data = vec_fossil.diff)

hist(fit_lms.5$residuals)
qqnorm(fit_lms.5$residuals)
shapiro.test(fit_lms.5$residuals)

fit_lms.6 <- lmsreg(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu + dif_gdp_eu*dif_pop_eu,
                           data = vec_gas.diff)

hist(fit_lms.6$residuals)
qqnorm(fit_lms.6$residuals)
shapiro.test(fit_lms.6$residuals)

```

Least Trimmed Squares Regression

```{r}
# Core 1. EU_NON_RENEWABLE CONSUMPTIONS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
fit_lms.7 <-  ltsReg(oil_eu ~ gdp_eu + pop_eu + gdp_eu*pop_eu, alpha=alpha, mcd=TRUE, data = vec_oil)

hist(fit_lms.7$residuals)
qqnorm(fit_lms.7$residuals)
shapiro.test(fit_lms.7$residuals)

fit_lms.8 <- ltsReg(fossil_eu ~ gdp_eu + pop_eu + gdp_eu*pop_eu, alpha=alpha, mcd=TRUE, data = vec_fossil)

hist(fit_lms.8$residuals)
qqnorm(fit_lms.8$residuals)
shapiro.test(fit_lms.8$residuals)

fit_lms.9 <- ltsReg(gas_eu ~ gdp_eu + pop_eu + gdp_eu*pop_eu, alpha=alpha, mcd=TRUE, data = vec_gas)

hist(fit_lms.9$residuals)
qqnorm(fit_lms.9$residuals)
shapiro.test(fit_lms.9$residuals)

# Core 2. DIFF_NON_RENEWABLE CONSUMPTIONS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION
fit_lms.10 <- ltsReg(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu + dif_gdp_eu*dif_pop_eu,alpha=alpha, mcd=TRUE,data = vec_oil.diff)

hist(fit_lms.10$residuals)
qqnorm(fit_lms.10$residuals)
shapiro.test(fit_lms.10$residuals)

fit_lms.11 <- ltsReg(dif_fossil_eu ~ dif_gdp_eu + dif_pop_eu + dif_gdp_eu*dif_pop_eu,alpha=alpha, mcd=TRUE, data = vec_fossil.diff)

hist(fit_lms.11$residuals)
qqnorm(fit_lms.11$residuals)
shapiro.test(fit_lms.11$residuals)

fit_lms.12 <- ltsReg(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu + dif_gdp_eu*dif_pop_eu, alpha=alpha, mcd=TRUE, data = vec_gas.diff)

hist(fit_lms.12$residuals)
qqnorm(fit_lms.12$residuals)
shapiro.test(fit_lms.12$residuals)
```


