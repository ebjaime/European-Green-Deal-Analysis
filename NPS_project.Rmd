---
title: "NPS_project"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TITLE
TODO: Rerun everything
Load necessary libraries:

```{r}
# General
library(openxlsx)
library(MASS)
library(progress)
library(np)
library(splines)
library(devtools)
library(tidyr)
# Depth
#library(DepthProc)
#library(robustbase)
# Functional data
library(roahd)
library(fda)
library(fdatest)
# Graphics packages
library(rgl)
library(hexbin)
library(ggplot2)
library(rgl)
library(corrplot)
# GAM
library(mgcv)
# Conformal
library(conformalInference)
library(forecast)


B=10000
seed=42
```

### Preprocessing of data

We implemented auxiliary functions for easy preprocessing of data:

```{r}

# 1000 Tons Of Oil Equivalent to Terajoules = 41.1868
tto_2_tj <- function(tto) {
    return(tto * 41.868)
}

# Function cleans df removing NAN rows, setting values as numeric...
preprocess <- function(df, start_nrows=6, end_nrows=2, tj=T) { 
    
    # Remove first rows not containing significant data
    df <- df[-c(1:start_nrows,(dim(df)[1]-(end_nrows-1)):dim(df)[1]),]
    
    rownames(df) <- df[,1] #use countries as rownames
    df <- df[,-1]
    
    rownames(df)[1] <- "year"
    rownames(df)[3] <- "European_Union" #we use 28 countries as European total value
    
    # Remove rows with NA values (in first column)
    df <- df[!df[,1]==':',]
    
    
    # 3 decimals
    df[] <- lapply(df, as.numeric)  
    
    if(!tj) # All data should be converted to Terajoules
        df[-1,] <- lapply(df[-1,], tto_2_tj)
    
    return(df)
}
```


In our script "preprocessing_SSP.rmd", we have additional code regarding the transformation of data of the SSP original data to fit our needs and located in "data/ssp_iiasa_YtY_gdp.xlsx" & "data/ssp_iiasa_YtY_pop.xlsx".



# Starting Point: Analysis of current European Renewable Transition


Loading necessary datasets. In energy balances we don't have the value Final Consumption (FC), but it can be estimated as sum of several.

```{r}
energy.balances.1  <- read.xlsx("data/complete_energy_balances.xlsx",sheet=1) # Gross available energy, first sheet should be the best

consump.fossils  <- read.xlsx("data/consumption_solid_fossil_fuels.xlsx",sheet=1) # Inland consumption
consump.gas      <- read.xlsx("data/consumption_gas.xlsx",sheet=1) # Inland consumption
consump.oil.petr <- read.xlsx("data/consumption_oil_petroleum.xlsx",sheet=1) # Inland consumption

consump.renew.1  <- read.xlsx("data/consumption_renewables.xlsx",sheet=1) # Geothermal, inland consump
consump.renew.2  <- read.xlsx("data/consumption_renewables.xlsx",sheet=2) # Solar thermal, inland consump.
consump.renew.3  <- read.xlsx("data/consumption_renewables.xlsx",sheet=3) # Biofuels, inland consump.
consump.renew.4  <- read.xlsx("data/consumption_renewables.xlsx",sheet=4) # Biogases, inland consump.
consump.renew.5  <- read.xlsx("data/consumption_renewables.xlsx",sheet=5) # Renewable waste, inland consump.

percent.renew <- read.xlsx("data/percentage_renewables.xlsx") 

prod.by.fuel.total <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=1)
prod.by.fuel.comb <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=2)
prod.by.fuel.nuclear <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=9)

```

We will now preprocess all datasets with our auxilary function. We will also compute the total Renewable energy's consumption levels by summing all the consumptions for all types of Renewable sources.

```{r}

energy.balances.p <- preprocess(energy.balances.1, tj=F)

consump.fossils.p <- preprocess(consump.fossils[,-32], tj=T) # without 2020 because of some missing data

consump.fossils.p[-1,] <- consump.fossils.p[-1,] * 25 #  Calorific power of Fossil Fuels
                                 
consump.oil.petr.p <- preprocess(consump.oil.petr[,-32], tj=F) # without 2020
consump.gas.p      <- preprocess(consump.gas[,-32], tj=T) # without 2020


consump.renew.1.p <- preprocess(consump.renew.1[,-32])
consump.renew.2.p <- preprocess(consump.renew.2[,-32])
consump.renew.3.p <- preprocess(consump.renew.3[,-32])
consump.renew.4.p <- preprocess(consump.renew.4[,-32])
consump.renew.5.p <- preprocess(consump.renew.5[,-32])

consump.renew.p <- consump.renew.1.p # Sum of all renewable energies
consump.renew.p[-1,] <- consump.renew.p[-1,] + consump.renew.2.p[-1,] + consump.renew.3.p[-1,] +consump.renew.4.p[-1,] + consump.renew.5.p[-1,]


prod.by.fuel.total.p = preprocess(prod.by.fuel.total)
prod.by.fuel.comb.p = preprocess(prod.by.fuel.comb)
prod.by.fuel.nuclear.p = preprocess(prod.by.fuel.nuclear)

prod.by.fuel.renew = prod.by.fuel.total.p
prod.by.fuel.renew[-1,] = prod.by.fuel.renew[-1,] - prod.by.fuel.comb.p[-1,] - prod.by.fuel.nuclear.p[-1,] #renewable electricity capacity (MegaWatt)


```

We can check what we obtain in total:

```{r}
#consump.total.p <-  consump.renew.p[2,1] +
                    #consump.oil.petr.p[2,1] +
                    #consump.fossils.p[2,1] +
                    #consump.gas.p[2,1]
                    # derived.heat +
                    # electricity 
#consump.total.p
```


To visualize the obtained data, we can plot European renewable and non renewable consumption levels:

```{r}
r_europe <- ggplot(data=as.data.frame(t(consump.renew.p)), aes(x=year, y=European_Union)) +
            labs(title="Renewable Energies Consumption Progression - European Union", 
                 subtitle="Inland Consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="blue", colour="darkblue", size=1)
r_europe
```

```{r}
# Example of European consumption of solid fossil fuels
f_europe <- ggplot(data=as.data.frame(t(consump.fossils.p)), aes(x=year, y=European_Union)) +
            labs(title="Consumption Solid Fossil Fuels - European Union", 
                 subtitle="Inland consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="red", colour="darkred", size=1)
f_europe

```

We will also create some auxiliary variables & datasets, so it is easier to follow what we are doing. 
```{r}
year.min       <- min(energy.balances.p[1,])
year.max       <- max(energy.balances.p[1,])
year.grid      <- seq(year.min, year.max)

countries.list <- rownames(consump.fossils.p[-c(1,2,3,4),])

# Construct datasets with and without total European values 
energy.balances.countries  <- energy.balances.p[-c(1,2,3,4),]
consump.fossils.countries  <- consump.fossils.p[-c(1,2,3,4),]
consump.oil.petr.countries <- consump.oil.petr.p[-c(1,2,3,4),]
consump.gas.countries      <- consump.gas.p[-c(1,2,3,4),]
consump.renew.countries    <- consump.renew.p[-c(1,2,3,4),]

consump.oil.petr.europe <- consump.oil.petr.p[3,]
consump.gas.europe <- consump.gas.p[3,]
consump.fossils.europe <- consump.fossils.p[3,]
consump.renew.europe <- consump.renew.p[3,]

colnames(energy.balances.countries) <- NULL
colnames(consump.fossils.countries) <- NULL
colnames(consump.oil.petr.countries) <- NULL
colnames(consump.gas.countries) <- NULL
colnames(consump.renew.countries) <- NULL
```

Since we are working with time series, by their nature data are yearly correlated.
To deal with this problem, let's construct year to year variations dataset:
```{r}
energy.balances.diff <- energy.balances.p[-1,-1] - energy.balances.p[-1,-length(energy.balances.p)]
consump.fossils.diff <- consump.fossils.p[-1,-1] - consump.fossils.p[-1,-length(consump.fossils.p)]
consump.oil.petr.diff <- consump.oil.petr.p[-1,-1] - consump.oil.petr.p[-1,-length(consump.oil.petr.p)]
consump.gas.diff <- consump.gas.p[-1,-1] - consump.gas.p[-1,-length(consump.gas.p)]
consump.renew.diff <- consump.renew.p[-1,-1] - consump.renew.p[-1,-length(consump.renew.p)]

energy.balances.diff <- rbind(year=seq(1991, 2019), energy.balances.diff)
consump.fossils.diff <- rbind(year=seq(1991, 2019), consump.fossils.diff)
consump.oil.petr.diff <- rbind(year=seq(1991, 2019), consump.oil.petr.diff)
consump.gas.diff <- rbind(year=seq(1991, 2019), consump.gas.diff)
consump.renew.diff <- rbind(year=seq(1991, 2019), consump.renew.diff)
```

The analysis of current European renewable transition is structured in three sections:

## 1. What is the trend of renewable and non-renewable consumptions.


We can visualize the consumption levels of all EU countries.

Via time series visualization of :
```{r}
#matplot(seq(year.min, year.max), t(energy.balances.countries), type="l", lty=1,
        #main="Energy Balances EU 1990 - 2019", xlab="Year", ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.fossils.countries), type="l", lty=1,
        main="Consumption of Solid Fossil Fuels EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.oil.petr.countries), type="l", lty=1,
        main="Consumption of Oil and Petroleum EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.gas.countries), type="l", lty=1,
        main="Consumption of Natural Gas EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.renew.countries), type="l", lty=1,
        main="Consumption of Renewables EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")
```

Via boxplot:
```{r}
#boxplot(energy.balances.countries, main="Boxplot Energy Balances", xlab="Countries", 
        #ylab="Terajoules")

boxplot(consump.fossils.countries, main="Boxplot of Consumption of Solid Fossil Fuels", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.oil.petr.countries, main="Boxplot of Consumption of Oil and Petroleum", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.gas.countries, main="Boxplot of Consumption of Natural Gas", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.renew.countries, main="Consumption of Renewables", xlab="Countries", 
        ylab="Terajoule")
```


First let us check for normality with a simple Shapiro-Wilk test.

Let us visualize a random country from the dataset and check whether it might be normally distributed:

```{r}

index.italy <- which(rownames(consump.renew.diff) == c("Italy"))
hist(t(consump.fossils.diff)[,index.italy])
hist(t(consump.oil.petr.diff)[,index.italy])
hist(t(consump.gas.diff)[,index.italy])
hist(t(consump.renew.diff)[,index.italy])

```

Now to check the distribution of p-values obtained with a Shapiro-Wilk test:
```{r}

p.values.ff <- numeric(length(countries.list)) # Fossil fuels
p.values.op <- numeric(length(countries.list)) # Oil&Petr.
p.values.ng <- numeric(length(countries.list)) # Natural gas 
p.values.re <- numeric(length(countries.list)) # RE
for(c in 1:length(countries.list)){
    p.values.ff[c] <- shapiro.test(t(consump.fossils.diff)[,c])$p.value
    p.values.op[c] <- shapiro.test(t(consump.oil.petr.diff)[,c])$p.value
    p.values.ng[c] <- shapiro.test(t(consump.gas.diff)[,c])$p.value # Ignore errors
    p.values.re[c] <- shapiro.test(t(consump.renew.diff)[,c])$p.value


    
}
hist(p.values.ff,breaks=20)
hist(p.values.op,breaks=20)
hist(p.values.ng,breaks=20)
hist(p.values.re,breaks=20)
```

### Permutational Two Population MV test - Comparing Consumption distributions

We want to compare the distributions of Non Renewable vs Renewable fuels for each country:
```{r}
consump.fossils.mean <- colMeans(consump.fossils.countries, na.rm=T)
consump.oil.petr.mean <- colMeans(consump.oil.petr.countries, na.rm=T)
consump.gas.mean <- colMeans(consump.gas.countries, na.rm=T)
consump.renew.mean <- colMeans(consump.renew.countries, na.rm=T)

matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean,
                                       consump.renew.mean)),
        type="l",main="Consumption means for each type of fuel",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(consump.fossils.mean)[2]+300000))

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas","Renewable Energies"), col=1:4, pch=2)


```
Plot of only non-renewables
```{r}
matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean)),
        type="l",main="Consumption means for each type of non renewable fuel",xlab="Years",ylab="Terajoules",lwd=2,lty=1,
        ylim=c(min(consump.fossils.mean)-30000,max(consump.fossils.mean)+30000))

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas"), col=1:3, pch=2)
```
We start with a permutational MANOVA to see whether the three



Renewable consumption and Fossil Fuels are very different from oil & petr. and natural gas consumption.
But do these last two follow the same distribution?


```{r}

# H0: Distributions are equal
# H1: Distributions are not equal

# NG vs OP ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.gas.countries))[1]
n2 <- dim(as.matrix(consump.oil.petr.countries))[1]
n  <- n1 + n2

# Test statistic
T10 <- as.numeric((consump.gas.mean-consump.oil.petr.mean) %*% (consump.gas.mean-consump.oil.petr.mean))
T10

# Permutational distribution
T1 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled = rbind(consump.gas.countries, consump.oil.petr.countries)
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm, na.rm = T)
    t2.mean_perm = colMeans(t2_perm, na.rm = T)
    T1[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T1,xlim=range(c(T1,T10)))
abline(v=T10,col=3,lwd=4)

plot(ecdf(T1))
abline(v=T10,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T1>=T10)/B
p_val

```

```{r}

# FF vs OP ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.fossils.mean))[1]
n2 <- dim(as.matrix(consump.oil.petr.mean))[1]
n  <- n1 + n2

# Test statistic
T20 <- as.numeric((consump.fossils.mean-consump.oil.petr.mean) %*% (consump.fossils.mean-consump.oil.petr.mean))
T20

# Permutational distribution
T2 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled = rbind(consump.fossils.countries, consump.oil.petr.countries)
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm, na.rm = T)
    t2.mean_perm = colMeans(t2_perm, na.rm = T)
    T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T2,xlim=range(c(T2,T20)))
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T2>=T20)/B
p_val

```


What about using year-to-year variates? Does the renew. consumption follow the same distribution as fossils or oil & petr. consumption?
```{r}

# RE vs OP ----------------------------------------------------------------
# Use year by year change of each energy (RE vs OP (or NG or FF))

mean.consump.nonrenew <- ( consump.fossils.countries[,]+consump.gas.countries[,]+consump.oil.petr.countries[,] )/3
mean.consump.nonrenew.mean=colMeans(mean.consump.nonrenew)

matplot(seq(year.min, year.max), t(rbind(mean.consump.nonrenew.mean,
                                         consump.renew.mean)),
        type="l",main="Consumption means renewables vs non-renewables",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(mean.consump.nonrenew.mean)[2]+300000),col=c(1,3),lty=c(1,1))
legend("topright",legend=c("Non-renewable sources","Renewable sources"),col=c(1,3),pch=2)


mean.consump.nonrenew.diff <- mean.consump.nonrenew[,-length(mean.consump.nonrenew)] - mean.consump.nonrenew[,-1] #"inverse" deltas for non renewables to obtain growing curve differences

consump.renew.diff <- consump.renew.countries[,-1] - consump.renew.countries[,-length(consump.renew.countries)]

mean.consump.nonrenew.diff.mean <- colMeans(mean.consump.nonrenew.diff, na.rm=T)
consump.renew.diff.mean <- colMeans(consump.renew.diff, na.rm=T)

matplot(seq(year.min+1,year.max), consump.renew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Renewable consumptions year to year average deltas",col="green")
matlines(seq(year.min+1,year.max), mean.consump.nonrenew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Mean non-renewable consumptions year to year inverse average deltas")


n1 <- dim(as.matrix(consump.renew.diff))[1]
n2 <- dim(as.matrix(mean.consump.nonrenew.diff))[1]
n  <- n1 + n2

# Test statistic
T30 <- as.numeric((consump.renew.diff.mean-mean.consump.nonrenew.diff.mean) %*% (consump.renew.diff.mean-mean.consump.nonrenew.diff.mean))
T30

# Permutational distribution
T3 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled <- cbind(consump.renew.diff,mean.consump.nonrenew.diff)
    permutation <- sample(n)
    t_perm <- t_pooled[permutation,]
    t1_perm <- t_perm[1:n1,]
    t2_perm <- t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm <- colMeans(t1_perm, na.rm = T)
    t2.mean_perm <- colMeans(t2_perm, na.rm = T)
    T3[perm]  <- (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T3,xlim=range(c(T3,T30)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T30,col=3,lwd=4)

plot(ecdf(T3),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T30,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T3>=T30)/B
p_val

```




## SECOND TARGET: investigate how electricity production coming from renewable sources is growing

Let's visualize the total electricity production trend by country

```{r}
tot_elec <- read.xlsx('data/total_electricity_use.xlsx')
# View(tot_elec)
tot_elec = preprocess(tot_elec)

colnames(tot_elec) <- tot_elec[1,] #use years as columns names
tot_elec <- tot_elec[-1,] #first row is now useless
tot_elec <- tot_elec[,-17] #don't consider 2020

matplot(colnames(tot_elec),t(tot_elec[4:39,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity production by country")
```

Let's visualize the production of electricity from renewables trend by country

```{r}
use_renew_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=1)
# View(use_renew_elec)
use_renew_elec = preprocess(use_renew_elec)

colnames(use_renew_elec) <- use_renew_elec[1,] #use years as columns names
use_renew_elec <- use_renew_elec[-1,] #first row now is useless


use_renew_elec <- use_renew_elec[!is.na(use_renew_elec[,16]),]
# View(use_renew_elec)



matplot(colnames(use_renew_elec),t(use_renew_elec[4:40,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from renewables by country")

```

Let's see which country is particularly above the others in total usage of renewables for electricity production

```{r}
rownames(use_renew_elec)[which.max(use_renew_elec[4:40,16])+3] #first three rows are total european statistics
```
Let's construct a dataset with percentage of electricity coming from renewables to visualize its evolution at a European level
```{r}
elec_percentage <- tot_elec

for (j in 1:16){
  elec_percentage[,j] <- use_renew_elec[-34,j]/elec_percentage[,j]
  #34th row is Montenegro, which didn't survive preprocessing in the total electricity production dataset
}
# View(elec_percentage)

years_04_19 <- as.numeric(colnames(elec_percentage))
plot(years_04_19,as.numeric(elec_percentage[2,]),main="Percentage of electricity coming from renewable sources - EU",xlab="Year",ylab="Percentage",type="l")
points(years_04_19,as.numeric(elec_percentage[2,]),col="Green",lwd=3)
```



### MANOVA to compare the distributions from the three main types of RE for electricity consumption

Getting and preprocessing electricity data
```{r}
use_hydro_elec <-read.xlsx('data/use_renew_elec.xlsx',sheet=2)
use_wind_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=4)
use_solar_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=6)

#clean hydro
use_hydro_elec=preprocess(use_hydro_elec)

colnames(use_hydro_elec) <- use_hydro_elec[1,]
use_hydro_elec <- use_hydro_elec[-1,]

use_hydro_elec <- use_hydro_elec[!is.na(use_hydro_elec[,16]),]

#clean wind
use_wind_elec=preprocess(use_wind_elec)

colnames(use_wind_elec) <- use_wind_elec[1,]
use_wind_elec <- use_wind_elec[-1,]

use_wind_elec <- use_wind_elec[!is.na(use_wind_elec[,16]),]

#clean solar
use_solar_elec=preprocess(use_solar_elec)

colnames(use_solar_elec) <- use_solar_elec[1,]
use_solar_elec <- use_solar_elec[-1,]

use_solar_elec <- use_solar_elec[!is.na(use_solar_elec[,16]),]

use_hydro_elec[] <- lapply(use_hydro_elec, as.numeric)
use_wind_elec[] <- lapply(use_wind_elec, as.numeric)
use_solar_elec[] <- lapply(use_solar_elec, as.numeric)


use_principal <- rbind(use_hydro_elec[4:40,],use_wind_elec[4:40,],use_solar_elec[4:40,])

#factor vector
source <- c(rep("Hydro",37),rep("Wind",37),rep("Solar",37))
source <- factor(source)
```

Obtain differences year to year from these datasets, as done before:

```{r}

tot_elec.diff        <- tot_elec[,-1] - tot_elec[,-length(tot_elec)]
colnames(tot_elec.diff) <- seq(2005,2019)

use_renew_elec.diff  <- use_renew_elec[,-1] - use_renew_elec[,-length(use_renew_elec)] 
colnames(use_renew_elec.diff) <- seq(2005,2019)

elec_percentage.diff <- elec_percentage[,-1] - elec_percentage[,-length(elec_percentage)]
colnames(elec_percentage.diff) <- seq(2005,2019)

use_hydro_elec.diff  <- use_hydro_elec[,-1] - use_hydro_elec[,-length(use_hydro_elec)]
use_solar_elec.diff  <- use_solar_elec[,-1] - use_solar_elec[,-length(use_solar_elec)]
use_wind_elec.diff   <- use_wind_elec[,-1] - use_wind_elec[,-length(use_wind_elec)]
colnames(use_hydro_elec.diff) <- seq(2005,2019)
colnames(use_solar_elec.diff) <- seq(2005,2019)
colnames(use_wind_elec.diff) <- seq(2005,2019)

use_principal.diff   <- rbind(use_hydro_elec.diff[4:40,], use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])     
colnames(use_principal.diff) <- seq(2005,2019)


```

Plot trends

```{r}
matplot(colnames(use_principal),t(use_principal),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity from Hydro-Wind-Solar",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```

```{r}
matplot(colnames(use_principal.diff),t(use_principal.diff),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity from Hydro-Wind-Solar",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```


Seems like Hydro is uniformly more used than the other two, let's proceed to statistically test this fact
Seems like Hydro has less variations than the other two, let's proceed to statistically test this fact

Observed statistic:
```{r}
#REVIEW
fit <- manova(as.matrix(use_principal.diff) ~ source)
print(summary.manova(fit,test="Wilks")) 
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
```

Run the test

```{r}
set.seed(seed)
T_stat <- numeric(B)
n=dim(use_principal.diff)[1]

for(perm in 1:B){
  # choose random permutation
  permutation <- sample(1:n)
  source.perm <- source[permutation]
  fit.perm <- manova(as.matrix(use_principal.diff) ~ source.perm)
  T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="Wilks stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-2,1),main="Wilk stat ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```

So here we have statistical evidence that the three main renewable sources have not the same distribution in terms of total generated electricity.

We can further investigate whether Solar and Wind are equally distributed (i.e. developing at the same rate) or not.
```{r}
wind.mean = colMeans(use_wind_elec.diff[4:40,])
solar.mean = colMeans(use_solar_elec.diff[4:40,])
years_04_19=as.numeric(colnames(use_wind_elec)) #years from 2004 to 2019
years_05_19=years_04_19[-1]

matplot(years_05_19,t(rbind(wind.mean,solar.mean)), type='l', col=c("green","red"), lty=1,xlab="Year",ylab="Gigawatt-hour",main="Mean electricity production")
legend("topleft",legend=c("Wind","Solar"),col=c(3,2),pch=1)
```


```{r}
n1 = n2=dim(use_wind_elec.diff[4:40,])[1]
n  = n1 + n2

T20 = as.numeric((wind.mean-solar.mean) %*% (wind.mean-solar.mean))
T20

# Estimating the permutational distribution under H0

T2 = numeric(B)
set.seed(seed)
t_pooled = rbind(use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])

for(perm in 1:B){
  # Random permutation of indexes
  permutation = sample(n)
  t_perm = t_pooled[permutation,]
  t1_perm = t_perm[1:n1,]
  t2_perm = t_perm[(n1+1):n,]
  
  # Evaluation of the test statistic on permuted data
  t1.mean_perm = colMeans(t1_perm)
  t2.mean_perm = colMeans(t2_perm)
  T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
}

hist(T2,xlim=range(c(T2,T20)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T20,col=3,lwd=4)

pvalue=sum(T2>=T20)/B
pvalue
```


### Conformal prediction on types of RE for electricity production 

The three conformal models will be:
    - derive DIFF_SOLAR ~ DIFF_GDP + DIFF_POPULATION
    - derive DIFF_WIND ~ DIFF_GDP + DIFF_POPULATION
    - derive DIFF_HIDRO ~ DIFF_GDP + DIFF_POPULATION
    
For this purpose, we will first have to import the SSP data from our dataset, which was obtained by retrieving the year to year values from the original data (more details in "src/preprocessing_SSP.Rmd").
We will also calculate the differences year to year.


```{r}
gdp <- read.xlsx("data/ssp_iiasa_YtY_gdp.xlsx", 1)
pop <- read.xlsx("data/ssp_iiasa_YtY_pop.xlsx", 1)

gdp.diff <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop.diff <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

rownames(gdp.diff) <- gdp$Country.Name
rownames(pop.diff) <- pop$Country.Name

gdp.diff <- gdp.diff[,-1] - gdp.diff[,-length(gdp.diff)]
pop.diff <- pop.diff[,-1] - pop.diff[,-length(pop.diff)]
years_90_40=colnames(pop)[-c(1,2,3,4)]

colnames(gdp.diff) <- years_90_40[-1]
colnames(pop.diff) <- years_90_40[-1]

gdp <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

colnames(gdp) <- years_90_40
colnames(pop) <- years_90_40

rownames(gdp) <- rownames(gdp.diff)
rownames(pop) <- rownames(pop.diff)
```

```{r}
gdp[is.na(gdp)] <- 0 #replace NA with 0
gdp.diff[is.na(gdp.diff)] <- 0 
```

EU totals - original data
For the moment we are trying to make CO2 predictions with total original data (there's also code for the differences, for the moment let's ignore it)
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp)
discard.pop.idx <- rownames(pop)%in%rownames(gdp)

# Take EU totals 
use_solar_elec.total <- use_solar_elec[2,]
use_wind_elec.total <- use_wind_elec[2,]
use_hydro_elec.total <- use_hydro_elec[2,]

pop <- pop[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp)%in%rownames(use_solar_elec[-c(1,2,3),])
discard.pop.idx <- rownames(pop)%in%rownames(use_solar_elec[-c(1,2,3),])

gdp <- gdp[discard.gdp.idx,]
pop <- pop[discard.pop.idx,]


rn <- rownames(gdp)
gdp <- gdp[rn,]
pop <- pop[rn,]

gdp.total <- as.numeric(colSums(gdp))
pop.total <- as.numeric(colSums(pop))
```

Montenegro and Albania should be discarded as they have NaN values or no information available for either population or GDP (see "preprocessing_SSP.Rmd"). Kosovo should be discarded as it is not recognized by the SSP predictions.

First order differences - ignore it for now
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We discard the countries which are not going to be used, as well as the EU totals 
use_solar_elec.diff.c <- use_solar_elec.diff[c(F,F,F,discard.idx),]
use_wind_elec.diff.c <- use_wind_elec.diff[c(F,F,F,discard.idx),]
use_hydro_elec.diff.c <- use_hydro_elec.diff[c(F,F,F,discard.idx),]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(use_solar_elec.diff.c)
discard.pop.idx <- rownames(pop.diff)%in%rownames(use_solar_elec.diff.c)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]


rn <- rownames(gdp.diff)
gdp.diff <- gdp.diff[rn,]
pop.diff <- pop.diff[rn,]

use_solar_elec.diff.c <- use_solar_elec.diff.c[rn,]
use_wind_elec.diff.c <- use_wind_elec.diff.c[rn,]
use_hydro_elec.diff.c <- use_hydro_elec.diff.c[rn,]
```


```{r}
#using EU total values
gdp.elec.train <- gdp[,as.character(seq(2004,2019))]
pop.elec.train <- pop[,as.character(seq(2004,2019))]
gdp.elec.train = colSums(gdp.elec.train)
pop.elec.train = colSums(pop.elec.train)

gdp.elec.pred  <- gdp[,as.character(seq(2020,2030))]
pop.elec.pred  <- pop[,as.character(seq(2020,2030))]
gdp.elec.pred = colSums(gdp.elec.pred)
pop.elec.pred = colSums(pop.elec.pred)
```



```{r}
#ignore it for now
gdp.elec.train <- gdp.diff[,as.character(seq(2005,2019))]
pop.elec.train <- pop.diff[,as.character(seq(2005,2019))]

gdp.elec.pred  <- gdp.diff[,as.character(seq(2020,2030))]
pop.elec.pred  <- pop.diff[,as.character(seq(2020,2030))]

```

Create dummy variables for countries (simply a numerical sequence) to deal with national production dependence ("Country Effect")

```{r}
#ignore it for now
dummy.country <- seq(1,dim(gdp.diff)[1])

vec_train <- cbind(gdp.elec.train[,1], pop.elec.train[,1], dummy.country)
for (j in 2:15){
    v <- cbind(gdp.elec.train[,j], pop.elec.train[,j], dummy.country)
    vec_train <- rbind(vec_train,v)
}
vec_train <- data.frame(vec_train)
colnames(vec_train) <- c("gdp","pop","country")


vec_test <- cbind(gdp.elec.pred[,1], pop.elec.pred[,1], dummy.country)
for (j in 2:11){
    v <- cbind(gdp.elec.pred[,j], pop.elec.pred[,j], dummy.country)
    vec_test <- rbind(vec_test,v)
}
vec_test <- data.frame(vec_test)
colnames(vec_test) <- c("gdp","pop","country")


vec_solar <- gather(use_solar_elec.diff.c,year,y)[,-1]
vec_hydro <- gather(use_hydro_elec.diff.c,year,y)[,-1]
vec_wind <- gather(use_wind_elec.diff.c,year,y)[,-1]
#vec_train$country=factor(vec_train$country)

```


```{r}
#vectors for EU total data
vec_train = cbind(gdp.elec.train, pop.elec.train)
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(gdp.elec.pred, pop.elec.pred)
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

Creation of models for train and for predictions, according to:
https://fromthebottomoftheheap.net/2021/02/02/random-effects-in-gams/

```{r}
#ignore it for now
train_gam <- function(x,y,out=NULL){
    colnames(x)=c("gdp", "pop", "country")
    train_data=data.frame(y,x)
    model_gam=gam(y ~ s(country,gdp,bs='re') + s(country,pop,bs='re'), data=train_data)
}


predict_gam <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop", "country")
    predict.gam(obj,new_x)
}

```

```{r}
train_gam <- function(x,y,out=NULL){ #total version
    colnames(x)=c("gdp", "pop")
    train_data=data.frame(y,x)
    model_gam=gam(y ~ s(gdp) + s(pop), data=train_data)
}


predict_gam <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop")
    predict.gam(obj,new_x)
}
```

```{r}
#Eu total predictions
c_preds.wind.total <- conformal.pred(
    as.matrix(vec_train), 
    use_wind_elec.total,
    as.matrix(vec_test),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam, 
    predict.fun = predict_gam)

#Error in gam(y ~ s(gdp) + s(pop), data = train_data) : Model has more coefficients than data

#More data are necessary to work with total values, can we apply smoothing, creating data each 3 months? We need this to predict wind, solar and hydro electricity production, so consequently also gdp and pop. This problem occurs only for electricity data, since they begin in 2004, while for the following models there should not be this problem.
#Using all the countries brings to ugly plots in conformal predictions.
```


```{r}
c_preds.wind <- conformal.pred(
    as.matrix(vec_train), 
    vec_wind,
    as.matrix(vec_test),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam, 
    predict.fun = predict_gam)

#c_preds.solar <- conformal.pred(
    #as.matrix(vec_train), 
    #vec_solar,
    #as.matrix(vec_test),
    #alpha=0.05, 
    #verbose=T, 
    #train.fun = train_gam, 
    #predict.fun = predict_gam)

#c_preds.hydro <- conformal.pred(
    #as.matrix(vec_train), 
    #vec_hydro,
    #as.matrix(vec_test),
    #alpha=0.05, 
    #verbose=T, 
    #train.fun = train_gam, 
    #predict.fun = predict_gam)
```

Plot predictions 2020-2030:
```{r}
with(data.frame(vec_wind=vec_wind, year=seq(2005,2019)), plot(year, vec_wind, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Wind Electricity Use'))

lines(rep(seq(2020,2030),34),c_preds.wind$pred,lwd =2, col ="green",lty=3)
matlines(rep(seq(2020,2030),34),c_preds.wind$up,lwd =1, col =" blue",lty =3)
matlines(rep(seq(2020,2030),34),c_preds.wind$lo, lwd =1, col =" blue",lty =3)

#ugly plot
```
```{r}
with(data.frame(vec_wind=vec_wind, year=seq(2005,2019)), plot(year, vec_wind, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Wind Electricity Use',ylim=c(-2000,15000)))

lines(rep(seq(2020,2030),34),c_preds.wind$pred,lwd =2, col ="green",lty=3)
matlines(rep(seq(2020,2030),34),c_preds.wind$up,lwd =1, col =" blue",lty =3)
matlines(rep(seq(2020,2030),34),c_preds.wind$lo, lwd =1, col =" blue",lty =3)
```
```{r}
with(data.frame(vec_hydro=vec_hydro, year=seq(2005,2019)), plot(year, vec_hydro, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Hydro Electricity Use'))

lines(rep(seq(2020,2030),34),c_preds.hydro$pred,lwd =2, col ="green",lty=3)
matlines(rep(seq(2020,2030),34),c_preds.hydro$up,lwd =1, col =" blue",lty =3)
matlines(rep(seq(2020,2030),34),c_preds.hydro$lo, lwd =1, col =" blue",lty =3)
```


## 3. Analysis of EU's current day renewable energy network.

### Regression on european electricity capacity

REVIEW: IS IT NECESSARY TO KEEP THIS? Let's make a step regression on total European values

```{r}
x=as.numeric(colnames(use_renew_elec)) #years from 2004 to 2019

plot(x,use_renew_elec[2,],main="Total electricity from renewables - Europe",xlab="Year",ylab="Gigawatt-hour")
```

```{r}
m_cut=lm(as.numeric(use_renew_elec[2,]) ~ cut(x,breaks=10))

years.grid=seq(range(x)[1],range(x)[2],by=0.1)
preds=predict(m_cut,list(x=years.grid),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(x ,as.numeric(use_renew_elec[2,]) ,xlim=range(years.grid) ,cex =.5, col =" darkgrey ",main='Custom cut Fit',xlab="Year",ylab="Gigawatt-hour")
lines(years.grid,preds$fit ,lwd =2, col =" blue")
matlines(years.grid ,se.bands ,lwd =1, col =" blue",lty =3)
```
Terrible...
Let's try with local regression

```{r}
a=data.frame(giga=as.numeric(use_renew_elec[2,]),years_a=x)
m_loc = npreg(giga ~ years_a,
              ckertype = 'uniform',
              bws = 2, # bandwidth
              data= a)
dat=data.frame(years_a=years.grid)
preds=predict(m_loc,newdata=dat,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(
    x,
    as.numeric(use_renew_elec[2,]) ,
    xlim = range(years.grid) ,
    cex = .5,
    col = " darkgrey ",
    main = 'Local Averaging - bws2 - Uniform kernel',
    xlab="Year",
    ylab="Gigawatt-hour"
  )
lines(years.grid,preds$fit ,lwd =2, col =" blue")
matlines(years.grid,se.bands ,lwd =1, col =" blue",lty =3)
```
Maybe gaussian kernel would be better?
```{r}
a=data.frame(giga=as.numeric(use_renew_elec[2,]),years_a=x)
m_loc = npreg(giga ~ years_a,
              ckertype = 'gaussian',
              bws = 1.5, # bandwidth
              data= a)
dat=data.frame(years_a=years.grid)
preds=predict(m_loc,newdata=dat,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(
    x,
    as.numeric(use_renew_elec[2,]) ,
    xlim = range(years.grid) ,
    cex = .5,
    col = " darkgrey ",
    main = 'Local Averaging - bws2 - Gaussian kernel',
    xlab="Year",
    ylab="Gigawatt-hour"
  )
lines(years.grid,preds$fit ,lwd =2, col =" blue")
matlines(years.grid,se.bands ,lwd =1, col =" blue",lty =3)
```

```{r}
list_vec=flatten(use_renew_elec[4:40,])
vec=cbind(list_vec[[1]],rep(2004,37))
for (j in 2:16){
  v=cbind(list_vec[[j]],rep(2004+j-1,37))
  vec=rbind(vec,v)
}
vec=data.frame(vec)
colnames(vec)=c("value","year")

m_loc = npreg(value ~ year,
              ckertype = 'gaussian',
              bws = 2, # bandwidth
              data= vec)
dat=data.frame(year=years.grid)
preds=predict(m_loc,newdata=dat,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(
    vec$year,
    vec$value ,
    xlim = range(years.grid) ,
    cex = .5,
    col = " darkgrey ",
    main = 'Local Averaging - bws2 - Gaussian kernel',
    xlab="Year",
    ylab="Gigawatt-hour"
  )
lines(years.grid,preds$fit ,lwd =2, col =" blue")
matlines(years.grid,se.bands ,lwd =1, col =" blue",lty =3)
```
Let's try with splines
```{r}
model_cubic_splines <-
  lm(value ~ bs(year, degree = 3,df = 10), data = vec)

preds=predict(model_cubic_splines,dat,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

with(vec, plot(year ,value ,xlim=range(dat$year) ,cex =.5, col =" darkgrey "))
lines(dat$year,preds$fit ,lwd =2, col =" blue")
matlines(dat$year, se.bands ,lwd =1, col =" blue",lty =3)
```


### ANOVA test on 2019 capacities, dividing Europe in four regions

Set a region-based analysis of electricity capacity

```{r}
countries=rownames(no_total_no_nuclear)# TODO: recompute this dataset, it's the sum of the capacities coming from different sources in prod.by.fuel dataset (discard combustible fuels and nuclear)

north_europe=c("Denmark","Estonia","Latvia","Lithuania","Finland","Sweden","Norway","Iceland","United Kingdom","Ireland")

east_europe=c("Bulgaria","Czechia","Hungary","Poland","Romania","Slovakia","Turkey","Ukraine")

south_europe=c("Greece","Spain","Italy","Cyprus","Malta","Portugal","Croatia","Slovenia","North Macedonia","Albania","Serbia")

central_europe=c("France","Belgium","Germany (until 1990 former territory of the FRG)","Luxembourg","Netherlands","Austria") #TODO: change Germany name

length(countries)==length(c(north_europe,south_europe,east_europe,central_europe))  #just to see correct division
```
Let's build the dataframe with groups attached, to perform an anova test on 2019 capacities
```{r}
north=no_total_no_nuclear[match(north_europe,countries),30]
east=no_total_no_nuclear[match(east_europe,countries),30]
south=no_total_no_nuclear[match(south_europe,countries),30]
central=no_total_no_nuclear[match(central_europe,countries),30]

north=cbind(north,rep("North",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("South",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_no_nuclear=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_no_nuclear)=c("cap_19","Region")
aov_no_nuclear$Region=factor(aov_no_nuclear$Region)
```

Proceed with anova test
```{r}
attach(aov_no_nuclear)
g=nlevels(aov_no_nuclear$Region)
g
boxplot(as.numeric(cap_19) ~ Region,col=rainbow(g),main="Electricity capacity by region",ylab="Megawatt")
```

```{r}
cap_19=as.numeric(cap_19)
fit <- aov(cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

B=10000
T_stat <- numeric(B) 
n <- dim(aov_no_nuclear)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20))
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```
With aovp?
```{r}
library(lmPerm)
lmp=aovp(cap_19 ~ Region,perm="Prob",Cp=1e-6)#cp is supposed to stop iterations when standard error is at that level...
summary(lmp)
detach(aov_no_nuclear)
#pretty much same result
```
Again, we don't have statistical evidence to say that electricity capacities from renewables have different distribution in the four regions of Europe.
This is not a meaningful result, since we are not taking into account the sizes of countries. It's better to analyze a relative quantity, like the ratio between renewable and total capacity!

Let's build the ad-hoc dataframe with relative capacities of 2019
```{r}
north=no_total_no_nuclear[match(north_europe,countries),30]/(total_capacity[4:38,][match(north_europe,countries),30])

east=no_total_no_nuclear[match(east_europe,countries),30]/(total_capacity[4:38,][match(east_europe,countries),30])

south=no_total_no_nuclear[match(south_europe,countries),30]/(total_capacity[4:38,][match(south_europe,countries),30])

central=no_total_no_nuclear[match(central_europe,countries),30]/(total_capacity[4:38,][match(central_europe,countries),30])

north=cbind(north,rep("Northern",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("Southern",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_ratio_cap=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_ratio_cap)=c("ratio_cap_19","Region")
aov_ratio_cap$Region=factor(aov_ratio_cap$Region)
```

```{r}
attach(aov_ratio_cap)
g=nlevels(aov_ratio_cap$Region)
g
boxplot(as.numeric(ratio_cap_19) ~ Region,col=c("cyan1","indianred1","cornflowerblue","chartreuse1"),main="Relative renewable electricity capacity by region",ylab="Percentage")
```
```{r}
ratio_cap_19=as.numeric(ratio_cap_19)
fit <- aov(ratio_cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

T_stat <- numeric(B) 
n <- dim(aov_ratio_cap)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- ratio_cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="F stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20),main="F stat permutational ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
detach(aov_ratio_cap)
```
Still no statistical evidence of different development in different regions


Let's find a 95% confidence interval for the median of electricity capacity from renewables of 2019
```{r}
median(aov_no_nuclear$cap_19)
```
```{r}
uni_t_perm=function(data,mu0,B=1000){

data_trans=data-mu0
T0=abs(median(data_trans))
T_perm=numeric(B)
n=length(data)

for(perm in 1:B){
  
  refl <- rbinom(n, 1, 0.5)*2 - 1
  T_perm[perm]=abs(median(data_trans*refl))

}
return(sum(T_perm>=T0)/B)
}
```

```{r}
grid=seq(3000,7400,by=0.5)
length(grid)
library(pbapply)
library(parallel)
```

```{r}
cores=detectCores()
cl=makeCluster(cores)
clusterExport(cl,varlist=list("data","uni_t_perm"))
```

```{r}
data=as.numeric(aov_no_nuclear$cap_19)
perm_wrapper=function(grid_point){uni_t_perm(data,grid_point,B=2000)}
pval_function=pbsapply(grid,perm_wrapper,cl=cl)
```

```{r}
plot(grid,pval_function,type='l')
range(grid[pval_function>0.05])
```




```{r}
matplot(colnames(capacity_renew_fuels_nuclear),t(capacity_renew_fuels_nuclear[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from renewables (with nuclear)")
```


Even if we include nuclear, Germany is still at the top
```{r}
rownames(capacity_renew_fuels_nuclear)[which.max(capacity_renew_fuels_nuclear[4:38,30])+3] #first three rows are total european statistics
```






# Core: Model to predict future european CO2


```{r}
# REVIEW: what to do with NA values?

# pay attention, this part is already done above

#gdp.diff <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
#pop.diff <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

#rownames(gdp.diff) <- gdp$Country.Name
#rownames(pop.diff) <- pop$Country.Name

#gdp.diff <- gdp.diff[,-1] - gdp.diff[,-length(gdp.diff)]
#pop.diff <- pop.diff[,-1] - pop.diff[,-length(pop.diff)]

#colnames(gdp.diff) <- colnames(gdp)[-c(1,2,3,4,5)]
#colnames(pop.diff) <- colnames(pop)[-c(1,2,3,4,5)]
```


```{r}
# Not in SSP GDP data and in EUstat data
discard.idx <- rownames(consump.oil.petr.diff[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We discard the countries which are not going to be used, as well as the EU totals 
consump.oil.petr.diff.c <- consump.oil.petr.diff[3,]
consump.gas.diff.c <- consump.gas.diff[3,]
consump.fossils.diff.c <- consump.fossils.diff[3,]
consump.renew.diff.c <- consump.renew.diff[3,]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in EUstat data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(consump.oil.petr.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(consump.oil.petr.diff)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]

gdp.diff.total<-as.numeric(colSums(gdp.diff,na.rm=T))[1:40] #we have data until 2100,                                                               so we keep only until 2030
pop.diff.total<-as.numeric(colSums(pop.diff,na.rm=T))[1:40]

```

```{r}
gdp.train <- gdp.total[1:30] #from 1990 until 2019
pop.train <- pop.total[1:30]

gdp.pred <- gdp.total[31:41]
pop.pred <- pop.total[31:41]
```

Ignore it for now
```{r}
gdp.train <- gdp.diff.total[1:29]
pop.train <- pop.diff.total[1:29]

gdp.pred  <- gdp.diff.total[30:40]
pop.pred  <- pop.diff.total[30:40]
```


## DIFF_NON_RENEWABLE CONSUMPTIONS ~ DIFF_TOTAL_GDP + DIFF_TOTAL_POPULATION

Includes three models, one for each non-renewable energy:
    - DIFF_TOTAL_PETROLEUM  ~ DIFF_TOTAL_GDP + DIFF_TOTAL_POPULATION
    - DIFF_TOTAL_SOLID FOSSIL FUELS ~ DIFF_TOTAL_GDP + DIFF_TOTAL_POPULATION
    - DIFF_TOTAL_NATURAL GAS ~ DIFF_TOTAL_GDP + DIFF_TOTAL_POPULATION

```{r}
#Eu total data
vec_oil <- t(rbind(consump.oil.petr.europe,gdp.train,pop.train))
vec_oil <- data.frame(vec_oil)
colnames(vec_oil)=c("oil_eu","gdp_eu","pop_eu")

vec_oil_pred <- cbind(gdp.pred, pop.pred)
vec_oil_pred <- data.frame(vec_oil_pred)

colnames(vec_oil_pred) <- c("gdp_eu","pop_eu")

vec_fossil <- t(rbind(consump.fossils.europe,gdp.train, pop.train))
vec_fossil <- data.frame(vec_fossil)
colnames(vec_fossil)=c("fossil_eu","gdp_eu","pop_eu")

vec_fossil_pred=vec_oil_pred

vec_gas <- t(rbind(consump.gas.europe,gdp.train, pop.train))
vec_gas <- data.frame(vec_gas)
colnames(vec_gas)=c("gas_eu","gdp_eu","pop_eu")

vec_gas_pred=vec_oil_pred
```



```{r}
#ignore it for now
# REVIEW: take into account country dummy variable??

vec_oil <- t(rbind(consump.oil.petr.diff.c,gdp.train,pop.train))
vec_oil <- data.frame(vec_oil)
colnames(vec_oil) <- c("dif_oil_eu","dif_gdp_eu","dif_pop_eu")


vec_oil_pred <- cbind(gdp.pred, pop.pred)
vec_oil_pred <- data.frame(vec_oil_pred)

colnames(vec_oil_pred) <- c("dif_gdp_eu","dif_pop_eu")

vec_fossil <- t(rbind(consump.fossils.diff.c,gdp.train, pop.train))
vec_fossil <- data.frame(vec_fossil)
colnames(vec_fossil) <- c("dif_fossil_eu","dif_gdp_eu","dif_pop_eu")


vec_fossil_pred <- cbind(gdp.pred, pop.pred)
vec_fossil_pred <- data.frame(vec_fossil_pred)

colnames(vec_fossil_pred) <- c("dif_gdp_eu","dif_pop_eu")

vec_gas <- t(rbind(consump.gas.diff.c,gdp.train, pop.train))
vec_gas <- data.frame(vec_gas)
colnames(vec_gas) <- c("dif_gas_eu","dif_gdp_eu","dif_pop_eu")


vec_gas_pred=vec_fossil_pred

```

Oil & Petr. total
```{r}
consump.oil.petr.gam <- gam(oil_eu ~ s(gdp_eu) + s(pop_eu),
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```


Oil & Petr.
```{r}
#ignore it for now
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu) + s(dif_pop_eu),
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```
```{r}
Acf(
  consump.oil.petr.gam$residuals
)
```
```{r}
Pacf(
  consump.oil.petr.gam$residuals
)
```
Fossils
```{r}
consump.fossils.gam <- gam(fossil_eu ~ s(gdp_eu) + s(pop_eu),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```


Fossils:
```{r}
#ignore it for now
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_gdp_eu) + s(dif_pop_eu),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
```{r}
Pacf( 
  consump.fossils.gam$residuals
)
```

Natural gas:
```{r}
consump.gas.gam <- gam(gas_eu ~ s(gdp_eu) + s(pop_eu),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```


```{r}
#ignore it for now
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_gdp_eu) + s(dif_pop_eu),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```

```{r}
Pacf(
  consump.gas.gam$residuals
)
```



Predict for 2020-2030
```{r}
# Preds (2020-2030)

consump.oil.petr.gam.preds <- predict(consump.oil.petr.gam, newdata=vec_oil_pred, se=T)

consump.fossils.gam.preds <- predict(consump.fossils.gam, newdata=vec_fossil_pred, se=T)

consump.gas.gam.preds <- predict(consump.gas.gam, newdata=vec_gas_pred, se=T)
```

Plot predictions
```{r}

# See graphs
with(vec_oil, plot(seq(1990,2019) ,oil_eu ,xlim=c(1990,2030),ylim=c(2e+7,2.8e+7),cex=.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Oil & Petr.'))
points(seq(2020,2030), consump.oil.petr.gam.preds$fit ,lwd =2, col ="red")

with(vec_fossil, plot(seq(1990,2019) ,fossil_eu ,xlim=c(1990,2030),ylim=c(0.3e+7,3.6e+7),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Fossil fuels'))
points(seq(2020,2030), consump.fossils.gam.preds$fit ,lwd =2, col ="red")

with(vec_gas, plot(seq(1990,2019) ,gas_eu ,xlim=c(1990,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Natural Gas'))
points(seq(2020,2030), consump.gas.gam.preds$fit ,lwd =2, col ="red")

```

```{r}
#ignore it for now
# See graphs
with(vec_oil, plot(seq(1991,2019) ,dif_oil_eu ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Oil & Petr.'))
points(seq(2020,2030), consump.oil.petr.gam.preds$fit ,lwd =2, col ="red")

with(vec_fossil, plot(seq(1991,2019) ,dif_fossil_eu ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Fossil fules.'))
points(seq(2020,2030), consump.fossils.gam.preds$fit ,lwd =2, col ="red")

with(vec_gas, plot(seq(1991,2019) ,dif_gas_eu ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Natural Gas'))
points(seq(2020,2030), consump.gas.gam.preds$fit ,lwd =2, col ="red")

```

## DIFF_TOTAL_RENEWABLE CONSUMPTIONS  ~ DIFF_TOTAL_PETROLEUM  + DIFF_TOTAL_SOLID FOSSILFUELS + DIFF_TOTAL_NATURAL GAS:

Let's try with original data, total values
```{r}
# Join all energies for common DF
vec_re <- cbind(as.numeric(consump.renew.europe[1,]),vec_oil$oil_eu,vec_fossil$fossil_eu, vec_gas$gas_eu)
vec_re <- data.frame(vec_re)
colnames(vec_re) <- c("value_re", "value_oil", "value_ff", "value_ng")
```

```{r}
#ignore it for now

# Join all energies for common DF
vec_re <- cbind(consump.renew.diff.c[,1],consump.oil.petr.diff.c[,1],consump.fossils.diff.c[,1], consump.gas.diff.c[,1])
for (j in 2:29){
    v <- cbind(consump.renew.diff.c[,j],consump.oil.petr.diff.c[,j],consump.fossils.diff.c[,j], consump.gas.diff.c[,j])
    vec_re <- rbind(vec_re,v)
}
vec_re <- data.frame(vec_re)
colnames(vec_re) <- c("value_re", "value_oil", "value_ff", "value_ng")
```


```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil) + s(value_ff) + s(value_ng), data=vec_re)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```
```{r}
Pacf(consump.renew.gam$residuals)
```

```{r}
vec_re_pred <- cbind(consump.oil.petr.gam.preds$fit,consump.fossils.gam.preds$fit, consump.gas.gam.preds$fit)
vec_re_pred <- data.frame(vec_re_pred)
colnames(vec_re_pred) <- c("value_oil", "value_ff", "value_ng")


consump.renew.gam.preds <- predict(consump.renew.gam, newdata=vec_re_pred, se=T)
```

```{r}
# See graphs
with(vec_re, plot(seq(1990,2019) ,value_re ,xlim=c(1990,2030),ylim=c(2e+6,7e+6),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Renewable Energy Consumption.'))
points(seq(2020,2030), consump.renew.gam.preds$fit ,lwd =2, col ="red")
```


## DIFF_TOTAL_CO2 ~  DIFF_TOTAL_RENEWABLE CONSUMPTION

```{r}
c02 <- read.xlsx("data/annual-co-emissions-by-region.xlsx", sheet=2)

# Check if all countries are present in other EU stats 
sum(!(unique(c02$Country) %in% rownames(gdp))) > 0
sum(!( rownames(gdp) %in% unique(c02$Country))) > 0
```
Import EU dataframe
```{r}
Co2=read.xlsx("data/owid-co2-data.xlsx",sheet=2,colNames=F)
colnames(Co2)=c("European Union","Year","ValueCo2")
head(Co2)
```

```{r}
plot(Co2$Year,Co2$ValueCo2)
```


Calculate differences:
```{r}
#ignore for now
c02.diff <- data.frame()
for(i in 1:34){
    for(j in 1:29){ # 1990-2019
        c02.diff <- rbind(c02.diff, c(c02$Country[(j+1)+(i-1)*31], 1990+j,
                                      c02[(j+1)+(i-1)*31, 4] - c02[j+(i-1)*31, 4]))
    }
}
colnames(c02.diff) <- colnames(c02)[c(-2,-5)]
```


```{r}
#ignore for now
vec_c02 <- rbind(c02.diff[,3], vec_re[,1]) #FIXME
vec_c02 <- lapply(vec_c02, as.numeric)
vec_c02 <- data.frame(vec_c02)
vec_c02_pred <- data.frame(consump.renew.gam.preds$fit)

colnames(vec_c02) <- c("value_c02", "value_re")
colnames(vec_c02_pred) <- c("value_re")

```


```{r}
vec_c02= cbind(Co2$ValueCo2,vec_re$value_re)
vec_c02 <- data.frame(vec_c02)
vec_c02_pred <- data.frame(consump.renew.gam.preds$fit)

colnames(vec_c02) <- c("value_c02", "value_re")
colnames(vec_c02_pred) <- c("value_re")

```


```{r}
c02.gam <- gam(value_c02 ~ s(value_re), data=vec_c02)

summary(c02.gam)

hist(c02.gam$residuals)
qqnorm(c02.gam$residuals)
shapiro.test(c02.gam$residuals)
```

```{r}
Pacf(c02.gam$residuals)
```

```{r}
c02.gam.preds <- predict(c02.gam, newdata=vec_c02_pred, se=T)

with(vec_c02, plot(seq(1990,2019) ,value_c02 ,xlim=c(1990,2030),ylim=c(2500,5000),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Co2 Emissions'))
points(seq(2020,2030),c02.gam.preds$fit ,lwd =2, col ="red")
```

How much is the predicted decrease?
```{r}
co2_original=vec_c02$value_c02[1]
co2_prediction=as.numeric(c02.gam.preds$fit[length(c02.gam.preds$fit)])

reduction=(co2_original-co2_prediction)/co2_original
reduction
```


```{r}
#ignore for now
c02.gam.preds <- predict(c02.gam, newdata=vec_c02_pred, se=T)

with(vec_c02, plot(rep(seq(1991,2019),34) ,value_c02 ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - c02 levels.'))
points(rep(seq(2020,2030),34), consump.renew.gam.preds$fit ,lwd =2, col ="red")
```




# Robustness

## TODO:




