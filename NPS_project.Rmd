---
title: "NPS_project"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TITLE
TODO: Rerun everything
Load necessary libraries:

```{r}
# General
library(openxlsx)
library(MASS)
library(progress)
library(np)
library(splines)
library(devtools)
library(tidyr)
library(jsonlite)
library(ISLR2)
library(pbapply)
# Depth
#library(DepthProc)
#library(robustbase)
# Functional data
library(roahd)
library(fda)
library(fdatest)
# Graphics packages
library(rgl)
library(hexbin)
library(ggplot2)
library(rgl)
library(corrplot)
# GAM
library(mgcv)
# Conformal
library(conformalInference)
library(forecast)


B=10000
seed=42
```

### Preprocessing of data

We implemented auxiliary functions for easy preprocessing of data:

```{r}

# 1000 Tons Of Oil Equivalent to Terajoules = 41.1868
tto_2_tj <- function(tto) {
    return(tto * 41.868)
}

# Function cleans df removing NAN rows, setting values as numeric...
preprocess <- function(df, start_nrows=6, end_nrows=2, tj=T) { 
    
    # Remove first rows not containing significant data
    df <- df[-c(1:start_nrows,(dim(df)[1]-(end_nrows-1)):dim(df)[1]),]
    
    rownames(df) <- df[,1] #use countries as rownames
    df <- df[,-1]
    
    rownames(df)[1] <- "year"
    rownames(df)[3] <- "European_Union" #we use 28 countries as European total value
    
    # Remove rows with NA values (in first column)
    df <- df[!df[,1]==':',]
    
    
    # 3 decimals
    df[] <- lapply(df, as.numeric)  
    
    if(!tj) # All data should be converted to Terajoules
        df[-1,] <- lapply(df[-1,], tto_2_tj)
    
    return(df)
}
```


In our script "preprocessing_SSP.rmd", we have additional code regarding the transformation of data of the SSP original data to fit our needs and located in "data/ssp_iiasa_YtY_gdp.xlsx" & "data/ssp_iiasa_YtY_pop.xlsx".



# Starting Point: Analysis of current European Renewable Transition


Loading necessary datasets. In energy balances we don't have the value Final Consumption (FC), but it can be estimated as sum of several.

```{r}
energy.balances.1  <- read.xlsx("data/complete_energy_balances.xlsx",sheet=1) # Gross available energy, first sheet should be the best

consump.fossils  <- read.xlsx("data/consumption_solid_fossil_fuels.xlsx",sheet=1) # Inland consumption
consump.gas      <- read.xlsx("data/consumption_gas.xlsx",sheet=1) # Inland consumption
consump.oil.petr <- read.xlsx("data/consumption_oil_petroleum.xlsx",sheet=1) # Inland consumption

consump.renew.1  <- read.xlsx("data/consumption_renewables.xlsx",sheet=1) # Geothermal, inland consump
consump.renew.2  <- read.xlsx("data/consumption_renewables.xlsx",sheet=2) # Solar thermal, inland consump.
consump.renew.3  <- read.xlsx("data/consumption_renewables.xlsx",sheet=3) # Biofuels, inland consump.
consump.renew.4  <- read.xlsx("data/consumption_renewables.xlsx",sheet=4) # Biogases, inland consump.
consump.renew.5  <- read.xlsx("data/consumption_renewables.xlsx",sheet=5) # Renewable waste, inland consump.

percent.renew <- read.xlsx("data/percentage_renewables.xlsx") 

prod.by.fuel.total <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=1)
prod.by.fuel.comb <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=2)
prod.by.fuel.nuclear <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=9)

```

We will now preprocess all datasets with our auxilary function. We will also compute the total Renewable energy's consumption levels by summing all the consumptions for all types of Renewable sources.

```{r}

energy.balances.p <- preprocess(energy.balances.1, tj=F)

consump.fossils.p <- preprocess(consump.fossils[,-32], tj=T) # without 2020 because of some missing data

consump.fossils.p[-1,] <- consump.fossils.p[-1,] * 25 #  Calorific power of Fossil Fuels
                                 
consump.oil.petr.p <- preprocess(consump.oil.petr[,-32], tj=F) # without 2020
consump.gas.p      <- preprocess(consump.gas[,-32], tj=T) # without 2020


consump.renew.1.p <- preprocess(consump.renew.1[,-32])
consump.renew.2.p <- preprocess(consump.renew.2[,-32])
consump.renew.3.p <- preprocess(consump.renew.3[,-32])
consump.renew.4.p <- preprocess(consump.renew.4[,-32])
consump.renew.5.p <- preprocess(consump.renew.5[,-32])

consump.renew.p <- consump.renew.1.p # Sum of all renewable energies
consump.renew.p[-1,] <- consump.renew.p[-1,] + consump.renew.2.p[-1,] + consump.renew.3.p[-1,] +consump.renew.4.p[-1,] + consump.renew.5.p[-1,]


prod.by.fuel.total.p = preprocess(prod.by.fuel.total)
prod.by.fuel.comb.p = preprocess(prod.by.fuel.comb)
prod.by.fuel.nuclear.p = preprocess(prod.by.fuel.nuclear)

prod.by.fuel.renew = prod.by.fuel.total.p
prod.by.fuel.renew[-1,] = prod.by.fuel.renew[-1,] - prod.by.fuel.comb.p[-1,] - prod.by.fuel.nuclear.p[-1,] #renewable electricity capacity (MegaWatt)

colnames(prod.by.fuel.total.p)= prod.by.fuel.total.p[1,]
prod.by.fuel.total.p=prod.by.fuel.total.p[-1,]

colnames(prod.by.fuel.comb.p)= prod.by.fuel.comb.p[1,]
prod.by.fuel.comb.p=prod.by.fuel.comb.p[-1,]

colnames(prod.by.fuel.renew)= prod.by.fuel.renew[1,]
prod.by.fuel.renew=prod.by.fuel.renew[-1,]

```


We can check what we obtain in total:

```{r}
#consump.total.p <-  consump.renew.p[2,1] +
                    #consump.oil.petr.p[2,1] +
                    #consump.fossils.p[2,1] +
                    #consump.gas.p[2,1]
                    # derived.heat +
                    # electricity 
#consump.total.p
```


To visualize the obtained data, we can plot European renewable and non renewable consumption levels:

```{r}
r_europe <- ggplot(data=as.data.frame(t(consump.renew.p)), aes(x=year, y=European_Union)) +
            labs(title="Renewable Energies Consumption Progression - European Union", 
                 subtitle="Inland Consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="blue", colour="darkblue", size=1)
r_europe
```

```{r}
# Example of European consumption of solid fossil fuels
f_europe <- ggplot(data=as.data.frame(t(consump.fossils.p)), aes(x=year, y=European_Union)) +
            labs(title="Consumption Solid Fossil Fuels - European Union", 
                 subtitle="Inland consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="red", colour="darkred", size=1)
f_europe

```

We will also create some auxiliary variables & datasets, so it is easier to follow what we are doing. 
```{r}
year.min       <- min(energy.balances.p[1,])
year.max       <- max(energy.balances.p[1,])
year.grid      <- seq(year.min, year.max)

countries.list <- rownames(consump.fossils.p[-c(1,2,3,4),])

# Construct datasets with and without total European values 
energy.balances.countries  <- energy.balances.p[-c(1,2,3,4),]
consump.fossils.countries  <- consump.fossils.p[-c(1,2,3,4),]
consump.oil.petr.countries <- consump.oil.petr.p[-c(1,2,3,4),]
consump.gas.countries      <- consump.gas.p[-c(1,2,3,4),]
consump.renew.countries    <- consump.renew.p[-c(1,2,3,4),]

consump.oil.petr.europe <- consump.oil.petr.p[3,]
consump.gas.europe <- consump.gas.p[3,]
consump.fossils.europe <- consump.fossils.p[3,]
consump.renew.europe <- consump.renew.p[3,]

colnames(energy.balances.countries) <- NULL
colnames(consump.fossils.countries) <- NULL
colnames(consump.oil.petr.countries) <- NULL
colnames(consump.gas.countries) <- NULL
colnames(consump.renew.countries) <- NULL
```

Since we are working with time series, by their nature data are yearly correlated.
To deal with this problem, let's construct year to year variations datasets:
```{r}
energy.balances.diff <- energy.balances.p[-1,-1] - energy.balances.p[-1,-length(energy.balances.p)]
consump.fossils.diff <- consump.fossils.p[-1,-1] - consump.fossils.p[-1,-length(consump.fossils.p)]
consump.oil.petr.diff <- consump.oil.petr.p[-1,-1] - consump.oil.petr.p[-1,-length(consump.oil.petr.p)]
consump.gas.diff <- consump.gas.p[-1,-1] - consump.gas.p[-1,-length(consump.gas.p)]
consump.renew.diff <- consump.renew.p[-1,-1] - consump.renew.p[-1,-length(consump.renew.p)]

energy.balances.diff <- rbind(year=seq(1991, 2019), energy.balances.diff)
consump.fossils.diff <- rbind(year=seq(1991, 2019), consump.fossils.diff)
consump.oil.petr.diff <- rbind(year=seq(1991, 2019), consump.oil.petr.diff)
consump.gas.diff <- rbind(year=seq(1991, 2019), consump.gas.diff)
consump.renew.diff <- rbind(year=seq(1991, 2019), consump.renew.diff)
```

The analysis of current European renewable transition is structured in three sections:

## First target: investigate how renewable and non-renewable consumptions are evolving.


We can visualize the consumption levels of all EU countries.

Via time series visualization of :
```{r}
#matplot(seq(year.min, year.max), t(energy.balances.countries), type="l", lty=1,
        #main="Energy Balances EU 1990 - 2019", xlab="Year", ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.fossils.countries), type="l", lty=1,
        main="Consumption of Solid Fossil Fuels EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.oil.petr.countries), type="l", lty=1,
        main="Consumption of Oil and Petroleum EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.gas.countries), type="l", lty=1,
        main="Consumption of Natural Gas EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.renew.countries), type="l", lty=1,
        main="Consumption of Renewables EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")
```

Via boxplot:
```{r}
#boxplot(energy.balances.countries, main="Boxplot Energy Balances", xlab="Countries", 
        #ylab="Terajoules")

boxplot(consump.fossils.countries, main="Boxplot of Consumption of Solid Fossil Fuels", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.oil.petr.countries, main="Boxplot of Consumption of Oil and Petroleum", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.gas.countries, main="Boxplot of Consumption of Natural Gas", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.renew.countries, main="Consumption of Renewables", xlab="Countries", 
        ylab="Terajoule")
```


First let us check for normality with a simple Shapiro-Wilk test.

Let us visualize a random country from the dataset and check whether it might be normally distributed:

```{r}

index.italy <- which(rownames(consump.renew.diff) == c("Italy"))
hist(t(consump.fossils.diff)[,index.italy])
hist(t(consump.oil.petr.diff)[,index.italy])
hist(t(consump.gas.diff)[,index.italy])
hist(t(consump.renew.diff)[,index.italy])

```

Now to check the distribution of p-values obtained with a Shapiro-Wilk test:
```{r}

p.values.ff <- numeric(length(countries.list)) # Fossil fuels
p.values.op <- numeric(length(countries.list)) # Oil&Petr.
p.values.ng <- numeric(length(countries.list)) # Natural gas 
p.values.re <- numeric(length(countries.list)) # RE
for(c in 1:length(countries.list)){
    p.values.ff[c] <- shapiro.test(t(consump.fossils.diff)[,c])$p.value
    p.values.op[c] <- shapiro.test(t(consump.oil.petr.diff)[,c])$p.value
    p.values.ng[c] <- shapiro.test(t(consump.gas.diff)[,c])$p.value # Ignore errors
    p.values.re[c] <- shapiro.test(t(consump.renew.diff)[,c])$p.value


    
}
hist(p.values.ff,breaks=20)
hist(p.values.op,breaks=20)
hist(p.values.ng,breaks=20)
hist(p.values.re,breaks=20)
```

### Permutational Two Population MV test - Comparing Consumption distributions

We want to compare the distributions of Non Renewable vs Renewable fuels for each country:
```{r}
consump.fossils.mean <- colMeans(consump.fossils.countries, na.rm=T)
consump.oil.petr.mean <- colMeans(consump.oil.petr.countries, na.rm=T)
consump.gas.mean <- colMeans(consump.gas.countries, na.rm=T)
consump.renew.mean <- colMeans(consump.renew.countries, na.rm=T)

matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean,
                                       consump.renew.mean)),
        type="l",main="Consumption means for each type of fuel",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(consump.fossils.mean)[2]+300000))

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas","Renewable Energies"), col=1:4, pch=2)


```
Plot of only non-renewables
```{r}
matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean)),
        type="l",main="Consumption means for each type of non renewable fuel",xlab="Years",ylab="Terajoules",lwd=2,lty=1,
        ylim=c(min(consump.fossils.mean)-30000,max(consump.fossils.mean)+30000))

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas"), col=1:3, pch=2)
```
We start with a permutational MANOVA to see whether the three #TODO: MANOVA



Renewable consumption and Fossil Fuels are very different from oil & petr. and natural gas consumption.
But do these last two follow the same distribution?


```{r}

# H0: Distributions are equal
# H1: Distributions are not equal

# NG vs OP ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.gas.countries))[1]
n2 <- dim(as.matrix(consump.oil.petr.countries))[1]
n  <- n1 + n2

# Test statistic
T10 <- as.numeric((consump.gas.mean-consump.oil.petr.mean) %*% (consump.gas.mean-consump.oil.petr.mean))
T10

# Permutational distribution
T1 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled = rbind(consump.gas.countries, consump.oil.petr.countries)
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm, na.rm = T)
    t2.mean_perm = colMeans(t2_perm, na.rm = T)
    T1[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T1,xlim=range(c(T1,T10)))
abline(v=T10,col=3,lwd=4)

plot(ecdf(T1))
abline(v=T10,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T1>=T10)/B
p_val

```

```{r}

# FF vs OP ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.fossils.mean))[1]
n2 <- dim(as.matrix(consump.oil.petr.mean))[1]
n  <- n1 + n2

# Test statistic
T20 <- as.numeric((consump.fossils.mean-consump.oil.petr.mean) %*% (consump.fossils.mean-consump.oil.petr.mean))
T20

# Permutational distribution
T2 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled = rbind(consump.fossils.countries, consump.oil.petr.countries)
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm, na.rm = T)
    t2.mean_perm = colMeans(t2_perm, na.rm = T)
    T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T2,xlim=range(c(T2,T20)))
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T2>=T20)/B
p_val

```


What about using year-to-year variates? Does the renewable consumption growth follow the same distribution as the non renewable decrease?
```{r}

# RE vs OP ----------------------------------------------------------------
# Use year by year change of each energy (RE vs OP (or NG or FF))

mean.consump.nonrenew <-(consump.fossils.countries[,]+consump.gas.countries[,]+consump.oil.petr.countries[,] )/3
mean.consump.nonrenew.mean=colMeans(mean.consump.nonrenew)

matplot(seq(year.min, year.max), t(rbind(mean.consump.nonrenew.mean,
                                         consump.renew.mean)),
        type="l",main="Consumption means renewables vs non-renewables",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(mean.consump.nonrenew.mean)[2]+300000),col=c(1,3),lty=c(1,1))
legend("topright",legend=c("Non-renewable sources","Renewable sources"),col=c(1,3),pch=2)


mean.consump.nonrenew.diff <- mean.consump.nonrenew[,-length(mean.consump.nonrenew)] - mean.consump.nonrenew[,-1] #"inverse" deltas for non renewables to obtain growing curve differences

consump.renew.diff <- consump.renew.countries[,-1] - consump.renew.countries[,-length(consump.renew.countries)]

mean.consump.nonrenew.diff.mean <- colMeans(mean.consump.nonrenew.diff, na.rm=T)
consump.renew.diff.mean <- colMeans(consump.renew.diff, na.rm=T)

matplot(seq(year.min+1,year.max), consump.renew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Renewable consumptions year to year average deltas",col="green")
matlines(seq(year.min+1,year.max), mean.consump.nonrenew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Mean non-renewable consumptions year to year inverse average deltas")


n1 <- dim(as.matrix(consump.renew.diff))[1]
n2 <- dim(as.matrix(mean.consump.nonrenew.diff))[1]
n  <- n1 + n2

# Test statistic
T30 <- as.numeric((consump.renew.diff.mean-mean.consump.nonrenew.diff.mean) %*% (consump.renew.diff.mean-mean.consump.nonrenew.diff.mean))
T30

# Permutational distribution
T3 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled <- cbind(consump.renew.diff,mean.consump.nonrenew.diff)
    permutation <- sample(n)
    t_perm <- t_pooled[permutation,]
    t1_perm <- t_perm[1:n1,]
    t2_perm <- t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm <- colMeans(t1_perm, na.rm = T)
    t2.mean_perm <- colMeans(t2_perm, na.rm = T)
    T3[perm]  <- (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T3,xlim=range(c(T3,T30)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T30,col=3,lwd=4)

plot(ecdf(T3),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T30,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T3>=T30)/B
p_val

```




## Second Target: Investigate how electricity production coming from renewable sources is growing

Let's visualize the total electricity production trend by country

```{r}
tot_elec <- read.xlsx('data/total_electricity_use.xlsx')
# View(tot_elec)
tot_elec = preprocess(tot_elec)

colnames(tot_elec) <- tot_elec[1,] #use years as columns names
tot_elec <- tot_elec[-1,] #first row is now useless
tot_elec <- tot_elec[,-17] #don't consider 2020

matplot(colnames(tot_elec),t(tot_elec[4:39,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity production by country")
```

Let's visualize the production of electricity from renewables trend by country

```{r}
use_renew_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=1)
# View(use_renew_elec)
use_renew_elec = preprocess(use_renew_elec)

colnames(use_renew_elec) <- use_renew_elec[1,] #use years as columns names
use_renew_elec <- use_renew_elec[-1,] #first row now is useless


use_renew_elec <- use_renew_elec[!is.na(use_renew_elec[,16]),]
# View(use_renew_elec)



matplot(colnames(use_renew_elec),t(use_renew_elec[4:40,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from renewables by country")

```

Let's see which country is particularly above the others in total usage of renewables for electricity production

```{r}
rownames(use_renew_elec)[which.max(use_renew_elec[4:40,16])+3] #first three rows are total european statistics
```
Let's construct a dataset with percentage of electricity coming from renewables to visualize its evolution at a European level
```{r}
elec_percentage <- tot_elec

for (j in 1:16){
  elec_percentage[,j] <- use_renew_elec[-34,j]/elec_percentage[,j]
  #34th row is Montenegro, which didn't survive preprocessing in the total electricity production dataset
}
# View(elec_percentage)

years_04_19 <- as.numeric(colnames(elec_percentage))
plot(years_04_19,as.numeric(elec_percentage[2,]),main="Percentage of electricity coming from renewable sources - EU",xlab="Year",ylab="Percentage",type="l")
points(years_04_19,as.numeric(elec_percentage[2,]),col="Green",lwd=3)
```



### MANOVA to compare the distributions from the three main types of RE for electricity consumption

Getting and preprocessing electricity data
```{r}
use_hydro_elec <-read.xlsx('data/use_renew_elec.xlsx',sheet=2)
use_wind_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=4)
use_solar_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=6)

#clean hydro
use_hydro_elec=preprocess(use_hydro_elec)

colnames(use_hydro_elec) <- use_hydro_elec[1,]
use_hydro_elec <- use_hydro_elec[-1,]

use_hydro_elec <- use_hydro_elec[!is.na(use_hydro_elec[,16]),]

#clean wind
use_wind_elec=preprocess(use_wind_elec)

colnames(use_wind_elec) <- use_wind_elec[1,]
use_wind_elec <- use_wind_elec[-1,]

use_wind_elec <- use_wind_elec[!is.na(use_wind_elec[,16]),]

#clean solar
use_solar_elec=preprocess(use_solar_elec)

colnames(use_solar_elec) <- use_solar_elec[1,]
use_solar_elec <- use_solar_elec[-1,]

use_solar_elec <- use_solar_elec[!is.na(use_solar_elec[,16]),]

use_hydro_elec[] <- lapply(use_hydro_elec, as.numeric)
use_wind_elec[] <- lapply(use_wind_elec, as.numeric)
use_solar_elec[] <- lapply(use_solar_elec, as.numeric)


use_principal <- rbind(use_hydro_elec[4:40,],use_wind_elec[4:40,],use_solar_elec[4:40,])

#factor vector
source <- c(rep("Hydro",37),rep("Wind",37),rep("Solar",37))
source <- factor(source)
```

Let's obtain year to year differences from these datasets, as done before:

```{r}

tot_elec.diff        <- tot_elec[,-1] - tot_elec[,-length(tot_elec)]
colnames(tot_elec.diff) <- seq(2005,2019)

use_renew_elec.diff  <- use_renew_elec[,-1] - use_renew_elec[,-length(use_renew_elec)] 
colnames(use_renew_elec.diff) <- seq(2005,2019)

elec_percentage.diff <- elec_percentage[,-1] - elec_percentage[,-length(elec_percentage)]
colnames(elec_percentage.diff) <- seq(2005,2019)

use_hydro_elec.diff  <- use_hydro_elec[,-1] - use_hydro_elec[,-length(use_hydro_elec)]
use_solar_elec.diff  <- use_solar_elec[,-1] - use_solar_elec[,-length(use_solar_elec)]
use_wind_elec.diff   <- use_wind_elec[,-1] - use_wind_elec[,-length(use_wind_elec)]
colnames(use_hydro_elec.diff) <- seq(2005,2019)
colnames(use_solar_elec.diff) <- seq(2005,2019)
colnames(use_wind_elec.diff) <- seq(2005,2019)

use_principal.diff   <- rbind(use_hydro_elec.diff[4:40,], use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])     
colnames(use_principal.diff) <- seq(2005,2019)


```

Plot electricity trends

```{r}
matplot(colnames(use_principal),t(use_principal),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from Hydro-Wind-Solar",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```

```{r}
matplot(colnames(use_principal.diff),t(use_principal.diff),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from Hydro-Wind-Solar, year to year variations",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```


Seems like Hydro is uniformly more used than the other two, let's proceed to statistically test this fact
Seems like Hydro has less variations than the other two, let's proceed to statistically test this fact

Observed statistic:
```{r}
#REVIEW
fit <- manova(as.matrix(use_principal.diff) ~ source)
print(summary.manova(fit,test="Wilks")) 
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
```

Run the test

```{r}
set.seed(seed)
T_stat <- numeric(B)
n=dim(use_principal.diff)[1]

for(perm in 1:B){
  # choose random permutation
  permutation <- sample(1:n)
  source.perm <- source[permutation]
  fit.perm <- manova(as.matrix(use_principal.diff) ~ source.perm)
  T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="Wilks stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-2,1),main="Wilk stat ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```

So here we have statistical evidence that the three main renewable sources have not the same growth distribution in terms of generated electricity.

We can further investigate whether Solar and Wind are equally distributed (i.e. developing at the same rate) or not.
```{r}
wind.mean = colMeans(use_wind_elec.diff[4:40,])
solar.mean = colMeans(use_solar_elec.diff[4:40,])
years_04_19=as.numeric(colnames(use_wind_elec)) #years from 2004 to 2019
years_05_19=years_04_19[-1]

matplot(years_05_19,t(rbind(wind.mean,solar.mean)), type='l', col=c("green","red"), lty=1,xlab="Year",ylab="Gigawatt-hour",main="Mean electricity production")
legend("topleft",legend=c("Wind","Solar"),col=c(3,2),pch=1)
```


```{r}
n1 = n2=dim(use_wind_elec.diff[4:40,])[1]
n  = n1 + n2

T20 = as.numeric((wind.mean-solar.mean) %*% (wind.mean-solar.mean))
T20

# Estimating the permutational distribution under H0

T2 = numeric(B)
set.seed(seed)
t_pooled = rbind(use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])

for(perm in 1:B){
  # Random permutation of indexes
  permutation = sample(n)
  t_perm = t_pooled[permutation,]
  t1_perm = t_perm[1:n1,]
  t2_perm = t_perm[(n1+1):n,]
  
  # Evaluation of the test statistic on permuted data
  t1.mean_perm = colMeans(t1_perm)
  t2.mean_perm = colMeans(t2_perm)
  T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
}

hist(T2,xlim=range(c(T2,T20)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T20,col=3,lwd=4)

pvalue=sum(T2>=T20)/B
pvalue
```


### Conformal prediction on types of RE for electricity production 

The three conformal models will be:
    - derive DIFF_SOLAR ~ DIFF_GDP + DIFF_POPULATION
    - derive DIFF_WIND ~ DIFF_GDP + DIFF_POPULATION
    - derive DIFF_HIDRO ~ DIFF_GDP + DIFF_POPULATION
    
For this purpose, we will first have to import the SSP data from our dataset, which was obtained by retrieving the year to year values from the original data (more details in "src/preprocessing_SSP.Rmd").
We will also calculate the differences year to year.


```{r}
gdp <- read.xlsx("data/ssp_iiasa_YtY_gdp.xlsx", 1)
pop <- read.xlsx("data/ssp_iiasa_YtY_pop.xlsx", 1)

gdp.diff <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop.diff <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

rownames(gdp.diff) <- gdp$Country.Name
rownames(pop.diff) <- pop$Country.Name

gdp.diff <- gdp.diff[,-1] - gdp.diff[,-length(gdp.diff)]
pop.diff <- pop.diff[,-1] - pop.diff[,-length(pop.diff)]
years_90_40=colnames(pop)[-c(1,2,3,4)]

colnames(gdp.diff) <- years_90_40[-1]
colnames(pop.diff) <- years_90_40[-1]

gdp <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

colnames(gdp) <- years_90_40
colnames(pop) <- years_90_40

rownames(gdp) <- rownames(gdp.diff)
rownames(pop) <- rownames(pop.diff)
```

```{r}
gdp[is.na(gdp)] <- 0 #replace NA with 0
gdp.diff[is.na(gdp.diff)] <- 0 
```

EU totals - original data
For the moment we are trying to make CO2 predictions with total original data (there's also code for the differences, for the moment let's ignore it)
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp)
discard.pop.idx <- rownames(pop)%in%rownames(gdp)

# Take EU totals 
use_solar_elec.total <- use_solar_elec[2,]
use_wind_elec.total <- use_wind_elec[2,]
use_hydro_elec.total <- use_hydro_elec[2,]

pop <- pop[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp)%in%rownames(use_solar_elec[-c(1,2,3),])
discard.pop.idx <- rownames(pop)%in%rownames(use_solar_elec[-c(1,2,3),])

gdp <- gdp[discard.gdp.idx,]
pop <- pop[discard.pop.idx,]


rn <- rownames(gdp)
gdp <- gdp[rn,]
pop <- pop[rn,]

gdp.total <- as.numeric(colSums(gdp))
pop.total <- as.numeric(colSums(pop))
```

Montenegro and Albania should be discarded as they have NaN values or no information available for either population or GDP (see "preprocessing_SSP.Rmd"). Kosovo should be discarded as it is not recognized by the SSP predictions.

First order differences - ignore it for now
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We discard the countries which are not going to be used, as well as the EU totals 
use_solar_elec.diff.c <- use_solar_elec.diff[c(F,F,F,discard.idx),]
use_wind_elec.diff.c <- use_wind_elec.diff[c(F,F,F,discard.idx),]
use_hydro_elec.diff.c <- use_hydro_elec.diff[c(F,F,F,discard.idx),]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(use_solar_elec.diff.c)
discard.pop.idx <- rownames(pop.diff)%in%rownames(use_solar_elec.diff.c)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]


rn <- rownames(gdp.diff)
gdp.diff <- gdp.diff[rn,]
pop.diff <- pop.diff[rn,]

use_solar_elec.diff.c <- use_solar_elec.diff.c[rn,]
use_wind_elec.diff.c <- use_wind_elec.diff.c[rn,]
use_hydro_elec.diff.c <- use_hydro_elec.diff.c[rn,]
```


```{r}
#using EU total values
gdp.elec.train <- gdp[,as.character(seq(2004,2019))]
pop.elec.train <- pop[,as.character(seq(2004,2019))]
gdp.elec.train = colSums(gdp.elec.train)
pop.elec.train = colSums(pop.elec.train)

gdp.elec.pred  <- gdp[,as.character(seq(2020,2030))]
pop.elec.pred  <- pop[,as.character(seq(2020,2030))]
gdp.elec.pred = colSums(gdp.elec.pred)
pop.elec.pred = colSums(pop.elec.pred)
```



```{r}
#ignore it for now
gdp.elec.train <- gdp.diff[,as.character(seq(2005,2019))]
pop.elec.train <- pop.diff[,as.character(seq(2005,2019))]

gdp.elec.pred  <- gdp.diff[,as.character(seq(2020,2030))]
pop.elec.pred  <- pop.diff[,as.character(seq(2020,2030))]

```

Create dummy variables for countries (simply a numerical sequence) to deal with national production dependence ("Country Effect")

```{r}
#ignore it for now
dummy.country <- seq(1,dim(gdp.diff)[1])

vec_train <- cbind(gdp.elec.train[,1], pop.elec.train[,1], dummy.country)
for (j in 2:15){
    v <- cbind(gdp.elec.train[,j], pop.elec.train[,j], dummy.country)
    vec_train <- rbind(vec_train,v)
}
vec_train <- data.frame(vec_train)
colnames(vec_train) <- c("gdp","pop","country")


vec_test <- cbind(gdp.elec.pred[,1], pop.elec.pred[,1], dummy.country)
for (j in 2:11){
    v <- cbind(gdp.elec.pred[,j], pop.elec.pred[,j], dummy.country)
    vec_test <- rbind(vec_test,v)
}
vec_test <- data.frame(vec_test)
colnames(vec_test) <- c("gdp","pop","country")


vec_solar <- gather(use_solar_elec.diff.c,year,y)[,-1]
vec_hydro <- gather(use_hydro_elec.diff.c,year,y)[,-1]
vec_wind <- gather(use_wind_elec.diff.c,year,y)[,-1]
#vec_train$country=factor(vec_train$country)

```


```{r}
#vectors for EU total data
vec_train = cbind(gdp.elec.train, pop.elec.train)
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(gdp.elec.pred, pop.elec.pred)
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

Creation of models for train and for predictions, according to:
https://fromthebottomoftheheap.net/2021/02/02/random-effects-in-gams/

```{r}
#ignore it for now
train_gam <- function(x,y,out=NULL){
    colnames(x)=c("gdp", "pop", "country")
    train_data=data.frame(y,x)
    model_gam=gam(y ~ s(country,gdp,bs='re') + s(country,pop,bs='re'), data=train_data)
}


predict_gam <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop", "country")
    predict.gam(obj,new_x)
}

```

```{r}
train_gam <- function(x,y,out=NULL){ #total version
    colnames(x)=c("gdp", "pop")
    train_data=data.frame(y,x)
    model_gam=gam(y ~ s(gdp) + s(pop), data=train_data)
}


predict_gam <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop")
    predict.gam(obj,new_x)
}
```

```{r}
#Eu total predictions
c_preds.wind.total <- conformal.pred(
    as.matrix(vec_train), 
    use_wind_elec.total,
    as.matrix(vec_test),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam, 
    predict.fun = predict_gam)

#Error in gam(y ~ s(gdp) + s(pop), data = train_data) : Model has more coefficients than data

#More data are necessary to work with total values, can we apply smoothing, creating data each 3 months? We need this to predict wind, solar and hydro electricity production, so consequently also gdp and pop. This problem occurs only for electricity data, since they begin in 2004, while for the following models there should not be this problem.
#Using all the countries brings to ugly plots in conformal predictions, so we worked with total EU values
```


```{r}
c_preds.wind <- conformal.pred(
    as.matrix(vec_train), 
    vec_wind,
    as.matrix(vec_test),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam, 
    predict.fun = predict_gam)

#c_preds.solar <- conformal.pred(
    #as.matrix(vec_train), 
    #vec_solar,
    #as.matrix(vec_test),
    #alpha=0.05, 
    #verbose=T, 
    #train.fun = train_gam, 
    #predict.fun = predict_gam)

#c_preds.hydro <- conformal.pred(
    #as.matrix(vec_train), 
    #vec_hydro,
    #as.matrix(vec_test),
    #alpha=0.05, 
    #verbose=T, 
    #train.fun = train_gam, 
    #predict.fun = predict_gam)
```

Plot predictions 2020-2030:
```{r}
with(data.frame(vec_wind=vec_wind, year=seq(2005,2019)), plot(year, vec_wind, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Wind Electricity Use'))

lines(rep(seq(2020,2030),34),c_preds.wind$pred,lwd =2, col ="green",lty=3)
matlines(rep(seq(2020,2030),34),c_preds.wind$up,lwd =1, col =" blue",lty =3)
matlines(rep(seq(2020,2030),34),c_preds.wind$lo, lwd =1, col =" blue",lty =3)

#ugly plot
```

```{r}
with(data.frame(vec_wind=vec_wind, year=seq(2005,2019)), plot(year, vec_wind, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Wind Electricity Use',ylim=c(-2000,15000)))

lines(rep(seq(2020,2030),34),c_preds.wind$pred,lwd =2, col ="green",lty=3)
matlines(rep(seq(2020,2030),34),c_preds.wind$up,lwd =1, col =" blue",lty =3)
matlines(rep(seq(2020,2030),34),c_preds.wind$lo, lwd =1, col =" blue",lty =3)
```


```{r}
with(data.frame(vec_hydro=vec_hydro, year=seq(2005,2019)), plot(year, vec_hydro, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Hydro Electricity Use'))

lines(rep(seq(2020,2030),34),c_preds.hydro$pred,lwd =2, col ="green",lty=3)
matlines(rep(seq(2020,2030),34),c_preds.hydro$up,lwd =1, col =" blue",lty =3)
matlines(rep(seq(2020,2030),34),c_preds.hydro$lo, lwd =1, col =" blue",lty =3)
```


## Third Target: Analyse the current European renewable energy network.

### Regression on european electricity capacity

Let's plot some trends
```{r}
matplot(colnames(prod.by.fuel.total.p),t(prod.by.fuel.total.p[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Total electricity capacities")
```

```{r}
matplot(colnames(prod.by.fuel.comb.p),t(prod.by.fuel.comb.p[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from non-renewables")
```


```{r}
matplot(colnames(prod.by.fuel.renew.countries),t(prod.by.fuel.renew.countries),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from renewables")
```

Now let's perform different kinds of nonparametric regression to compare European trends of renewable vs non renewable electricity capacity
```{r}
years_90_19=as.numeric(colnames(prod.by.fuel.comb.p))
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European non-renewable electricity capacity",xlab="Year",ylab="Megawatt")
```

```{r}
m_list=lapply(1:10,function(degree){lm(as.numeric(prod.by.fuel.comb.p[2,]) ~ poly(as.numeric(years_90_19),degree=degree))})
do.call(anova,m_list)
```


```{r}
summary(m_list[[2]])
```

```{r}
summary(m_list[[3]])

```

```{r}
summary(m_list[[6]])

```


```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[2]]$fitted.values,col="red")

```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[3]]$fitted.values,col="red")
```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[6]]$fitted.values,col="red")
```

Third grade polynomial regression seems reasonable (theorethically we should choose grade 9, since it's the last significant model: 10th grade regression is not significant)

```{r}
comb_model=m_list[[3]]
```


Now let's move to renewables
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
```

```{r}
m_list=lapply(1:10,function(degree){lm(as.numeric(prod.by.fuel.renew[2,]) ~ poly(as.numeric(years_90_19),degree=degree))})
do.call(anova,m_list)
```
```{r}
summary(m_list[[2]])

```
```{r}
summary(m_list[[4]])

```
```{r}
summary(m_list[[7]])

```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[2]]$fitted.values,col="green")
```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[4]]$fitted.values,col="green")
```

```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[7]]$fitted.values,col="green")
```
Since by passing to fourth grade we only add one parameter w.r.t second grade (third grade coefficient is considered zero), we can consider the fourth grade regression.

But we can notice that the coefficient of fourth grade is negative! It's not really reasonable for future predictions, so we stick to second grade


```{r}
ren_model=m_list[[2]]
```


```{r}
anni=seq(range(years_90_19)[1],range(years_90_19)[2],by=0.25)
preds=predict(comb_model,list(years_90_19=anni),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(years_90_19 ,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni), ylim=range(as.numeric(prod.by.fuel.renew[2,]))+5000,cex =.5, col =" darkgrey ",main='Polynomial regression on european electricity capacity',xlab="Year",ylab="Megawatt")
lines(anni,preds$fit ,lwd =2, col =" red")
matlines (anni ,se.bands ,lwd =1, col =" red",lty =3)

preds=predict(ren_model,list(years_90_19=anni),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ",pch=2)
lines(anni,preds$fit ,lwd =2, col =" green")
matlines (anni ,se.bands ,lwd =1, col =" green",lty =3)

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)
```

Let's try with spline regression
```{r}
#combustible fuels
b=data.frame(cap=as.numeric(prod.by.fuel.comb.p[2,]),years_b=years_90_19)
comb_model_spline <- lm(cap ~ bs(years_b, df=7,degree=2), data=b )
dat_b=data.frame(years_b=anni)

preds=predict(comb_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni),
    ylim=range(as.numeric(prod.by.fuel.renew[2,]))+5000,cex =.5, col =" darkgrey ",
    main="Splines regression on european electricity capacity",xlab="Year",ylab="Megawatt")

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)

lines(anni,preds$fit ,lwd =2, col =" red")
matlines(anni, se.bands ,lwd =1, col =" red",lty =3)

#renewables
c=data.frame(cap=as.numeric(prod.by.fuel.renew[2,]),years_b=years_90_19)
ren_model_spline <- lm(cap ~ bs(years_b, df=7,degree=2), data=c )
dat_b=data.frame(years_b=anni)

preds=predict(ren_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ")
lines(anni,preds$fit ,lwd =2, col =" green")
matlines(anni, se.bands ,lwd =1, col =" green",lty =3)
```

Natural splines
```{r}
comb_model_spline <- lm(cap ~ ns(years_b, df=8), data=b )
dat_b=data.frame(years_b=anni)

preds=predict(comb_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

plot(years_90_19 ,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni) ,ylim=range(as.numeric(prod.by.fuel.renew[2,]))+3000,cex =.5, col =" darkgrey ",
     main="Natural Splines regression on european electricity capacity",xlab="Year",ylab="Megawatt")

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)

lines(anni,preds$fit ,lwd =2, col =" red")
matlines(anni, se.bands ,lwd =1, col =" red",lty =3)

ren_model_spline <- lm(cap ~ ns(years_b, df=7), data=c )
dat_b=data.frame(years_b=anni)

preds=predict(ren_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ")
lines(anni,preds$fit ,lwd =2, col =" green")
matlines(anni, se.bands ,lwd =1, col =" green",lty =3)
```

Natural cubic splines seems the best approach, it better captures all the local variations.


### ANOVA test on 2019 capacities, dividing Europe in four regions

Set a region-based analysis of electricity capacity

```{r}
prod.by.fuel.renew.countries=prod.by.fuel.renew[-c(1,2,3),]
countries=rownames(prod.by.fuel.renew.countries)# TODO: recompute this dataset, it's the sum of the capacities coming from different sources in prod.by.fuel dataset (discard combustible fuels and nuclear)

north_europe=c("Denmark","Estonia","Latvia","Lithuania","Finland","Sweden","Norway","Iceland","United Kingdom","Ireland")

east_europe=c("Bulgaria","Czechia","Hungary","Poland","Romania","Slovakia","Turkey","Ukraine")

south_europe=c("Greece","Spain","Italy","Cyprus","Malta","Portugal","Croatia","Slovenia","North Macedonia","Albania","Serbia")

central_europe=c("France","Belgium","Germany (until 1990 former territory of the FRG)","Luxembourg","Netherlands","Austria") #TODO: change Germany name

length(countries)==length(c(north_europe,south_europe,east_europe,central_europe))  #just to see correct division
```
Let's build the dataframe with groups attached, to perform an anova test on 2019 capacities
```{r}
north=prod.by.fuel.renew.countries[match(north_europe,countries),30]
east=prod.by.fuel.renew.countries[match(east_europe,countries),30]
south=prod.by.fuel.renew.countries[match(south_europe,countries),30]
central=prod.by.fuel.renew.countries[match(central_europe,countries),30]

north=cbind(north,rep("North",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("South",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_no_nuclear=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_no_nuclear)=c("cap_19","Region")
aov_no_nuclear$Region=factor(aov_no_nuclear$Region)
```

Proceed with anova test
```{r}
attach(aov_no_nuclear)
g=nlevels(aov_no_nuclear$Region)
g
boxplot(as.numeric(cap_19) ~ Region,col=rainbow(g),main="Electricity capacity by region",ylab="Megawatt")
```

```{r}
cap_19=as.numeric(cap_19)
fit <- aov(cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

B=10000
T_stat <- numeric(B) 
n <- dim(aov_no_nuclear)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20))
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```
With aovp?
```{r}
library(lmPerm)
lmp=aovp(cap_19 ~ Region,perm="Prob",Cp=1e-6)#cp is supposed to stop iterations when standard error is at that level...
summary(lmp)
detach(aov_no_nuclear)
#pretty much same result
```
Again, we don't have statistical evidence to say that electricity capacities from renewables have different distribution in the four regions of Europe.
This is not a meaningful result, since we are not taking into account the sizes of countries. It's better to analyze a relative quantity, like the ratio between renewable and total capacity!

Let's build the ad-hoc dataframe with relative capacities of 2019
```{r}
north=prod.by.fuel.renew.countries[match(north_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(north_europe,countries),30])

east=prod.by.fuel.renew.countries[match(east_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(east_europe,countries),30])

south=prod.by.fuel.renew.countries[match(south_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(south_europe,countries),30])

central=prod.by.fuel.renew.countries[match(central_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(central_europe,countries),30])

north=cbind(north,rep("Northern",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("Southern",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_ratio_cap=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_ratio_cap)=c("ratio_cap_19","Region")
aov_ratio_cap$Region=factor(aov_ratio_cap$Region)
```

```{r}
attach(aov_ratio_cap)
g=nlevels(aov_ratio_cap$Region)
g
boxplot(as.numeric(ratio_cap_19) ~ Region,col=c("cyan1","indianred1","cornflowerblue","chartreuse1"),main="Relative renewable electricity capacity by region",ylab="Percentage")
```
```{r}
ratio_cap_19=as.numeric(ratio_cap_19)
fit <- aov(ratio_cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

T_stat <- numeric(B) 
n <- dim(aov_ratio_cap)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- ratio_cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="F stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20),main="F stat permutational ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
detach(aov_ratio_cap)
```
Still no statistical evidence of different development in different regions


Let's find a 95% confidence interval for the median of electricity capacity from renewables of 2019
```{r}
median(aov_no_nuclear$cap_19)
```

```{r}
uni_t_perm=function(data,mu0,B=1000){

data_trans=data-mu0
T0=abs(median(data_trans))
T_perm=numeric(B)
n=length(data)

for(perm in 1:B){
  
  refl <- rbinom(n, 1, 0.5)*2 - 1
  T_perm[perm]=abs(median(data_trans*refl))

}
return(sum(T_perm>=T0)/B)
}
```

```{r}
grid=seq(3000,7400,by=0.5)
length(grid)
library(pbapply)
library(parallel)
```

```{r}
cores=detectCores()
cl=makeCluster(cores)
clusterExport(cl,varlist=list("data","uni_t_perm"))
```

```{r}
data=as.numeric(aov_no_nuclear$cap_19)
perm_wrapper=function(grid_point){uni_t_perm(data,grid_point,B=2000)}
pval_function=pbsapply(grid,perm_wrapper,cl=cl)
```

```{r}
plot(grid,pval_function,type='l')
range(grid[pval_function>0.05])
```

# Core: Model to predict future european CO2 emissions
We have set ourselves the goal of predicting whether the Green Deal target of a 55% cut in greenhouse gases (CO2) emissions by 2030 with respect to 1990 levels is feasible.

With the target to develop a model to predict future CO2 emissions as a function of the other energy indicators we had to previously construct a variety of auxiliar models to predict covariates values to be used in the final model.


Keeping only European countries for which we have complete data of Gdp, Population and Energy consumptions.
```{r}
# Not in SSP GDP data and in EUstat data
discard.idx <- rownames(consump.oil.petr.diff[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We discard the countries which are not going to be used, as well as the EU totals 
consump.oil.petr.diff.total <- consump.oil.petr.diff[3,]
consump.gas.diff.total <- consump.gas.diff[3,]
consump.fossils.diff.total <- consump.fossils.diff[3,]
consump.renew.diff.total <- consump.renew.diff[3,]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in EUstat data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(consump.oil.petr.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(consump.oil.petr.diff)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]

gdp.diff.total<-as.numeric(colSums(gdp.diff,na.rm=T))[1:40] #we have data until 2100,                                                               so we keep only until 2030
pop.diff.total<-as.numeric(colSums(pop.diff,na.rm=T))[1:40]

```


```{r}
gdp.train <- gdp.total[1:30] #from 1990 until 2019
pop.train <- pop.total[1:30]

gdp.pred <- gdp.total[31:41]
pop.pred <- pop.total[31:41]
```


Since we are working with time series, where there is a strong temporal dependence, from now on each time we are constructing a model we check the correlation of the residuals using the (partial) autocorrelation function. This is important to understand whether the model is able to capture the relations in original data or whether it is better to perform a first order differentiation to mitigate the natural collinearity problem of these datasets. With this idea in mind, we initially fit the models with original data and then saw whether it is necessary or not to switch to the yearly variations.


## EU_NON_RENEWABLE CONSUMPTIONS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION

Includes three models, one for each non-renewable energy:
    - EU_PETROLEUM  ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
    - EU_SOLID FOSSIL FUELS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
    - EU_NATURAL GAS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION

```{r}
#Eu total data
vec_oil <- t(rbind(consump.oil.petr.europe,gdp.train,pop.train))
vec_oil <- data.frame(vec_oil)
colnames(vec_oil)=c("oil_eu","gdp_eu","pop_eu")

vec_oil_pred <- cbind(gdp.pred, pop.pred)
vec_oil_pred <- data.frame(vec_oil_pred)

colnames(vec_oil_pred) <- c("gdp_eu","pop_eu")

vec_fossil <- t(rbind(consump.fossils.europe,gdp.train, pop.train))
vec_fossil <- data.frame(vec_fossil)
colnames(vec_fossil)=c("fossil_eu","gdp_eu","pop_eu")

vec_fossil_pred=vec_oil_pred

vec_gas <- t(rbind(consump.gas.europe,gdp.train, pop.train))
vec_gas <- data.frame(vec_gas)
colnames(vec_gas)=c("gas_eu","gdp_eu","pop_eu")

vec_gas_pred=vec_oil_pred
```

Oil & Petr. total
```{r}
consump.oil.petr.gam <- gam(oil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') +s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```
We can discard the gdp
```{r}
consump.oil.petr.gam <- gam(oil_eu ~ s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

```{r}
Acf(
  consump.oil.petr.gam$residuals
)
```


```{r}
Pacf(
  consump.oil.petr.gam$residuals
)
```

Fossils
```{r}
consump.fossils.gam <- gam(fossil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
Population in this case is not significant

```{r}
consump.fossils.gam <- gam(fossil_eu ~ s(gdp_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
```{r}
consump.fossils.gam <- gam(fossil_eu ~ s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```



```{r}
Acf( 
  consump.fossils.gam$residuals
)
```

```{r}
Pacf( 
  consump.fossils.gam$residuals
)
```

Natural gas:
```{r}
consump.gas.gam <- gam(gas_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)

```
Let's start quitting gdp

```{r}
consump.gas.gam <- gam(gas_eu ~ s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```

Discard population as well

```{r}
consump.gas.gam <- gam(gas_eu ~ s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```


```{r}
Acf(
  consump.gas.gam$residuals
)
```

```{r}
Pacf(
  consump.gas.gam$residuals
)
```
Since the correlations are not negligible, we pass to first order differences

## DIFF_NON_RENEWABLE CONSUMPTIONS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION

Includes three models, one for each non-renewable energy:
    - DIFF_EU_PETROLEUM  ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION
    - DIFF_EU_SOLID FOSSIL FUELS ~ DIFF_EU_GDP + DIFF_EU_POPULATION +                                                                            DIFF_EU_GDP:DIFF_EU_POPULATION
    - DIFF_EU_NATURAL GAS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION

```{r}
gdp.train <- gdp.diff.total[1:29]
pop.train <- pop.diff.total[1:29]

gdp.pred  <- gdp.diff.total[30:40]
pop.pred  <- pop.diff.total[30:40]
```




```{r}

vec_oil <- t(rbind(consump.oil.petr.diff.total,gdp.train,pop.train))
vec_oil <- data.frame(vec_oil)
colnames(vec_oil) <- c("dif_oil_eu","dif_gdp_eu","dif_pop_eu")


vec_oil_pred <- cbind(gdp.pred, pop.pred)
vec_oil_pred <- data.frame(vec_oil_pred)

colnames(vec_oil_pred) <- c("dif_gdp_eu","dif_pop_eu")

vec_fossil <- t(rbind(consump.fossils.diff.total,gdp.train, pop.train))
vec_fossil <- data.frame(vec_fossil)
colnames(vec_fossil) <- c("dif_fossil_eu","dif_gdp_eu","dif_pop_eu")


vec_fossil_pred = vec_oil_pred

colnames(vec_fossil_pred) <- c("dif_gdp_eu","dif_pop_eu")

vec_gas <- t(rbind(consump.gas.diff.total,gdp.train, pop.train))
vec_gas <- data.frame(vec_gas)
colnames(vec_gas) <- c("dif_gas_eu","dif_gdp_eu","dif_pop_eu")


vec_gas_pred=vec_fossil_pred

```




Oil & Petr.
```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_oil) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```
We quit the interaction term

```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_oil) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```
Quit pop as well


```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') ,data = vec_oil) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

We now test whether the smooth function is needed for the two covariates or if it is sufficient (or even better...) to consider a linear relationship

```{r}
consump.oil.petr.gam.1 <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + dif_pop_eu,data = vec_oil) 

summary(consump.oil.petr.gam.1)

hist(consump.oil.petr.gam.1$residuals)
qqnorm(consump.oil.petr.gam.1$residuals)
shapiro.test(consump.oil.petr.gam.1$residuals)
```
```{r}
consump.oil.petr.gam.2 <- gam(dif_oil_eu ~ dif_gdp_eu + s(dif_pop_eu,bs='cr'),data = vec_oil) 

summary(consump.oil.petr.gam.2)

hist(consump.oil.petr.gam.2$residuals)
qqnorm(consump.oil.petr.gam.2$residuals)
shapiro.test(consump.oil.petr.gam.2$residuals)
```

```{r}
consump.oil.petr.gam.3 <- gam(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu,data = vec_oil) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```
The last two very similar, we stick with number 2


```{r}
consump.oil.petr.gam=consump.oil.petr.gam.2
Acf(
  consump.oil.petr.gam$residuals
)
```

```{r}
Pacf(
  consump.oil.petr.gam$residuals
)
```



Fossils:
```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_fossil) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
Quit the interaction

```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_fossil) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
Quit gdp as well

```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_pop_eu,bs='cr'),data = vec_fossil) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```

```{r}
Acf( 
  consump.fossils.gam$residuals
)
```

```{r}
Pacf( 
  consump.fossils.gam$residuals
)
```




```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```
Quit gdp

```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```
Quit interaction as well
```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```
Let's try again with some linear contributions

```{r}
consump.gas.gam.1 <- gam(dif_gas_eu ~ dif_pop_eu + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam.1)

hist(consump.gas.gam.1$residuals)
qqnorm(consump.gas.gam.1$residuals)
shapiro.test(consump.gas.gam.1$residuals)
```

```{r}
consump.gas.gam.2 <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas) 
summary(consump.gas.gam.2)

hist(consump.gas.gam.2$residuals)
qqnorm(consump.gas.gam.2$residuals)
shapiro.test(consump.gas.gam.2$residuals)
```

```{r}
consump.gas.gam.3 <- gam(dif_gas_eu ~ dif_pop_eu + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```
We select model number 3

```{r}
consump.gas.gam=consump.gas.gam.3
```


Predict for 2020-2030
```{r}
# Preds (2020-2030)

consump.oil.petr.gam.preds <- predict(consump.oil.petr.gam, newdata=vec_oil_pred, se=T)

consump.fossils.gam.preds <- predict(consump.fossils.gam, newdata=vec_fossil_pred, se=T)

consump.gas.gam.preds <- predict(consump.gas.gam, newdata=data.frame(vec_gas_pred,inter=vec_gas_pred$dif_gdp_eu*vec_gas_pred$dif_pop_eu), se=T)
```


Plot predictions
```{r}
# See graphs
with(vec_oil, plot(seq(1991,2019) ,dif_oil_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Oil & Petr.'))
points(seq(2020,2030), consump.oil.petr.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.oil.petr.gam$fitted.values,lwd=1,col="blue")


with(vec_fossil, plot(seq(1991,2019) ,dif_fossil_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Fossil fuels'))
points(seq(2020,2030), consump.fossils.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.fossils.gam$fitted.values,lwd=1,col="blue")


with(vec_gas, plot(seq(1991,2019) ,dif_gas_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Natural Gas'))
points(seq(2020,2030), consump.gas.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.gas.gam$fitted.values,lwd=1,col="blue")

```

We proceeded with yearly variations framework also for the following models

Core ok until here!!!!

## DIFF_EU_RENEWABLE CONSUMPTIONS  ~ DIFF_EU_PETROLEUM  + DIFF_EU_SOLID FOSSILFUELS + DIFF_EU_NATURAL GAS:

Let's try with original data, total values
```{r}
# Join all energies for common DF
vec_re <- cbind(as.numeric(consump.renew.europe[1,]),vec_oil$oil_eu,vec_fossil$fossil_eu, vec_gas$gas_eu)
vec_re <- data.frame(vec_re)
colnames(vec_re) <- c("value_re", "value_oil", "value_ff", "value_ng")
```

```{r}
#ignore it for now

# Join all energies for common DF
vec_re <- cbind(consump.renew.diff.c[,1],consump.oil.petr.diff.c[,1],consump.fossils.diff.c[,1], consump.gas.diff.c[,1])
for (j in 2:29){
    v <- cbind(consump.renew.diff.c[,j],consump.oil.petr.diff.c[,j],consump.fossils.diff.c[,j], consump.gas.diff.c[,j])
    vec_re <- rbind(vec_re,v)
}
vec_re <- data.frame(vec_re)
colnames(vec_re) <- c("value_re", "value_oil", "value_ff", "value_ng")
```


```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil) + s(value_ff) + s(value_ng), data=vec_re)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```
```{r}
Pacf(consump.renew.gam$residuals)
```

```{r}
vec_re_pred <- cbind(consump.oil.petr.gam.preds$fit,consump.fossils.gam.preds$fit, consump.gas.gam.preds$fit)
vec_re_pred <- data.frame(vec_re_pred)
colnames(vec_re_pred) <- c("value_oil", "value_ff", "value_ng")


consump.renew.gam.preds <- predict(consump.renew.gam, newdata=vec_re_pred, se=T)
```

```{r}
# See graphs
with(vec_re, plot(seq(1990,2019) ,value_re ,xlim=c(1990,2030),ylim=c(2e+6,7e+6),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Renewable Energy Consumption.'))
points(seq(2020,2030), consump.renew.gam.preds$fit ,lwd =2, col ="red")
```


## DIFF_TOTAL_CO2 ~  DIFF_TOTAL_RENEWABLE CONSUMPTION

```{r}
c02 <- read.xlsx("data/annual-co-emissions-by-region.xlsx", sheet=2)

# Check if all countries are present in other EU stats 
sum(!(unique(c02$Country) %in% rownames(gdp))) > 0
sum(!( rownames(gdp) %in% unique(c02$Country))) > 0
```
Import EU dataframe
```{r}
Co2=read.xlsx("data/owid-co2-data.xlsx",sheet=2,colNames=F)
colnames(Co2)=c("European Union","Year","ValueCo2")
head(Co2)
```

```{r}
plot(Co2$Year,Co2$ValueCo2)
```


Calculate differences:
```{r}
#ignore for now
c02.diff <- data.frame()
for(i in 1:34){
    for(j in 1:29){ # 1990-2019
        c02.diff <- rbind(c02.diff, c(c02$Country[(j+1)+(i-1)*31], 1990+j,
                                      c02[(j+1)+(i-1)*31, 4] - c02[j+(i-1)*31, 4]))
    }
}
colnames(c02.diff) <- colnames(c02)[c(-2,-5)]
```


```{r}
#ignore for now
vec_c02 <- rbind(c02.diff[,3], vec_re[,1]) #FIXME
vec_c02 <- lapply(vec_c02, as.numeric)
vec_c02 <- data.frame(vec_c02)
vec_c02_pred <- data.frame(consump.renew.gam.preds$fit)

colnames(vec_c02) <- c("value_c02", "value_re")
colnames(vec_c02_pred) <- c("value_re")

```


```{r}
vec_c02= cbind(Co2$ValueCo2,vec_re$value_re)
vec_c02 <- data.frame(vec_c02)
vec_c02_pred <- data.frame(consump.renew.gam.preds$fit)

colnames(vec_c02) <- c("value_c02", "value_re")
colnames(vec_c02_pred) <- c("value_re")

```


```{r}
c02.gam <- gam(value_c02 ~ s(value_re), data=vec_c02)

summary(c02.gam)

hist(c02.gam$residuals)
qqnorm(c02.gam$residuals)
shapiro.test(c02.gam$residuals)
```

```{r}
Pacf(c02.gam$residuals)
```

```{r}
c02.gam.preds <- predict(c02.gam, newdata=vec_c02_pred, se=T)

with(vec_c02, plot(seq(1990,2019) ,value_c02 ,xlim=c(1990,2030),ylim=c(2500,5000),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Co2 Emissions'))
points(seq(2020,2030),c02.gam.preds$fit ,lwd =2, col ="red")
```

How much is the predicted decrease?
```{r}
co2_original=vec_c02$value_c02[1]
co2_prediction=as.numeric(c02.gam.preds$fit[length(c02.gam.preds$fit)])

reduction=(co2_original-co2_prediction)/co2_original
reduction
```


```{r}
#ignore for now
c02.gam.preds <- predict(c02.gam, newdata=vec_c02_pred, se=T)

with(vec_c02, plot(rep(seq(1991,2019),34) ,value_c02 ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - c02 levels.'))
points(rep(seq(2020,2030),34), consump.renew.gam.preds$fit ,lwd =2, col ="red")
```




# Robustness

## TODO:




