---
title: "NPS_project"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TITLE
Load necessary libraries:

```{r}
# General
library(openxlsx)
library(MASS)
library(progress)
library(np)
library(splines)
library(devtools)
library(tidyr)
library(jsonlite)
library(ISLR2)
library(pbapply)
# Depth
#library(DepthProc)
#library(robustbase)
# Functional data
library(roahd)
library(fda)
library(fdatest)
# Graphics packages
library(rgl)
library(hexbin)
library(ggplot2)
library(rgl)
library(corrplot)
# GAM
library(mgcv)
# Conformal
library(conformalInference)
library(forecast)


B=10000
seed=42
set.seed(seed)
```

### Preprocessing of data

We implemented auxiliary functions for easy preprocessing of data:

```{r}

# 1000 Tons Of Oil Equivalent to Terajoules = 41.1868
tto_2_tj <- function(tto) {
    return(tto * 41.868)
}

# Function cleans df removing NAN rows, setting values as numeric...
preprocess <- function(df, start_nrows=6, end_nrows=2, tj=T) { 
    
    # Remove first rows not containing significant data
    df <- df[-c(1:start_nrows,(dim(df)[1]-(end_nrows-1)):dim(df)[1]),]
    
    rownames(df) <- df[,1] #use countries as rownames
    df <- df[,-1]
    
    rownames(df)[1] <- "year"
    rownames(df)[3] <- "European_Union" #we use 28 countries as European total value
    
    # Remove rows with NA values (in first column)
    df <- df[!df[,1]==':',]
    
    
    # 3 decimals
    df[] <- lapply(df, as.numeric)  
    
    if(!tj) # All data should be converted to Terajoules
        df[-1,] <- lapply(df[-1,], tto_2_tj)
    
    return(df)
}


# REVIEW: Function for creating a smoothing procedure for any data given an interval:
# Interval corresponds to the frequency in each year: 2 each 6 months
smoothing_procedure <- function (data, from, to, write_to=NA, interval=3, row_names=NULL){
    
    new.data <- data.frame(matrix(ncol =length(from:to), nrow = 0))
    
    comb.year.grid <- seq(from, to, 1)
    
    for(c in 1:dim(data)[1]){ # For each country
        
        data.data <- as.numeric(data[c, as.character(from:to)]) 
        data.data.nans <- is.na(data.data)
        n.comb.year.grid <- comb.year.grid[!data.data.nans]
        
        times_basis <- n.comb.year.grid 
        knots       <- c(n.comb.year.grid) # Location of knots
        n_knots     <- length(knots) # Number of knots
        n_order     <- 2 # order of basis functions: cubic bspline: order = 3 + 1
        n_basis     <- length(knots) + n_order - 2;
        
        basis <- create.bspline.basis(c(min(times_basis),max(times_basis)),n_basis,n_order,knots)
        
        ys <- smooth.basis(argvals=times_basis, y=data.data[!data.data.nans], fdParobj = basis)
        
        xfd <- ys$fd
        
        data.yby <- eval.fd(seq(min(n.comb.year.grid),max(n.comb.year.grid), 1/interval), xfd) # Obtain data year by year
        
        new.data <- rbind(new.data, c( rep(NA, ((to-from) + 1 - length(n.comb.year.grid))*interval),
                                       data.yby))
    }

    # Rename columns
    colnames(new.data) <- c(seq(from, to, 1/interval))   
    
    rownames(new.data) <- row_names
    
    
    if(!is.na(write_to)){
        write.xlsx(new.data, write_to, overwrite = T)
    }
    return(new.data)
}

```


In our script "preprocessing_SSP.rmd", we have additional code regarding the transformation of data of the SSP original data to fit our needs and located in "data/ssp_iiasa_YtY_gdp.xlsx" & "data/ssp_iiasa_YtY_pop.xlsx".



# Starting Point: Analysis of current European Renewable Transition


Loading necessary datasets. In energy balances we don't have the value Final Consumption (FC), but it can be estimated as sum of several.

```{r}
energy.balances.1  <- read.xlsx("data/complete_energy_balances.xlsx",sheet=1) # Gross available energy, first sheet should be the best

consump.fossils  <- read.xlsx("data/consumption_solid_fossil_fuels.xlsx",sheet=1) # Inland consumption
consump.gas      <- read.xlsx("data/consumption_gas.xlsx",sheet=1) # Inland consumption
consump.oil.petr <- read.xlsx("data/consumption_oil_petroleum.xlsx",sheet=1) # Inland consumption

consump.renew.1  <- read.xlsx("data/consumption_renewables.xlsx",sheet=1) # Geothermal, inland consump
consump.renew.2  <- read.xlsx("data/consumption_renewables.xlsx",sheet=2) # Solar thermal, inland consump.
consump.renew.3  <- read.xlsx("data/consumption_renewables.xlsx",sheet=3) # Biofuels, inland consump.
consump.renew.4  <- read.xlsx("data/consumption_renewables.xlsx",sheet=4) # Biogases, inland consump.
consump.renew.5  <- read.xlsx("data/consumption_renewables.xlsx",sheet=5) # Renewable waste, inland consump.

percent.renew <- read.xlsx("data/percentage_renewables.xlsx") 

prod.by.fuel.total <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=1)
prod.by.fuel.comb <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=2)
prod.by.fuel.nuclear <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=9)

```

We will now preprocess all datasets with our auxilary function. We will also compute the total Renewable energy's consumption levels by summing all the consumptions for all types of Renewable sources.

```{r}

energy.balances.p <- preprocess(energy.balances.1, tj=F)

consump.fossils.p <- preprocess(consump.fossils[,-32], tj=T) # without 2020 because of some missing data

consump.fossils.p[-1,] <- consump.fossils.p[-1,] * 25 #  Calorific power of Fossil Fuels
                                 
consump.oil.petr.p <- preprocess(consump.oil.petr[,-32], tj=F) # without 2020
consump.gas.p      <- preprocess(consump.gas[,-32], tj=T) # without 2020

consump.renew.1.p <- preprocess(consump.renew.1[,-32])
consump.renew.2.p <- preprocess(consump.renew.2[,-32])
consump.renew.3.p <- preprocess(consump.renew.3[,-32])
consump.renew.4.p <- preprocess(consump.renew.4[,-32])
consump.renew.5.p <- preprocess(consump.renew.5[,-32])

consump.renew.p <- consump.renew.1.p # Sum of all renewable energies
consump.renew.p[-1,] <- consump.renew.p[-1,] + consump.renew.2.p[-1,] + consump.renew.3.p[-1,] +consump.renew.4.p[-1,] + consump.renew.5.p[-1,]


prod.by.fuel.total.p = preprocess(prod.by.fuel.total)
prod.by.fuel.comb.p = preprocess(prod.by.fuel.comb)
prod.by.fuel.nuclear.p = preprocess(prod.by.fuel.nuclear)

prod.by.fuel.renew = prod.by.fuel.total.p
prod.by.fuel.renew[-1,] = prod.by.fuel.renew[-1,] - prod.by.fuel.comb.p[-1,] - prod.by.fuel.nuclear.p[-1,] #renewable electricity capacity (MegaWatt)

colnames(prod.by.fuel.total.p)= prod.by.fuel.total.p[1,]
prod.by.fuel.total.p=prod.by.fuel.total.p[-1,]

colnames(prod.by.fuel.comb.p)= prod.by.fuel.comb.p[1,]
prod.by.fuel.comb.p=prod.by.fuel.comb.p[-1,]

colnames(prod.by.fuel.renew)= prod.by.fuel.renew[1,]
prod.by.fuel.renew=prod.by.fuel.renew[-1,]

```


We can check what we obtain in total:

```{r}
#consump.total.p <-  consump.renew.p[2,1] +
                    #consump.oil.petr.p[2,1] +
                    #consump.fossils.p[2,1] +
                    #consump.gas.p[2,1]
                    # derived.heat +
                    # electricity 
#consump.total.p
```


To visualize the obtained data, we can plot European renewable and non renewable consumption levels:

```{r}
r_europe <- ggplot(data=as.data.frame(t(consump.renew.p)), aes(x=year, y=European_Union)) +
            labs(title="Renewable Energies Consumption Progression - European Union", 
                 subtitle="Inland Consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="blue", colour="darkblue", size=1)
r_europe
```

```{r}
# Example of European consumption of solid fossil fuels
f_europe <- ggplot(data=as.data.frame(t(consump.fossils.p)), aes(x=year, y=European_Union)) +
            labs(title="Consumption Solid Fossil Fuels - European Union", 
                 subtitle="Inland consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="red", colour="darkred", size=1)
f_europe

```

We will also create some auxiliary variables & datasets, so it is easier to follow what we are doing. 
```{r}
year.min       <- min(energy.balances.p[1,])
year.max       <- max(energy.balances.p[1,])
year.grid      <- seq(year.min, year.max)

countries.list <- rownames(consump.fossils.p[-c(1,2,3,4),])

# Construct datasets with and without total European values 
energy.balances.countries  <- energy.balances.p[-c(1,2,3,4),]
consump.fossils.countries  <- consump.fossils.p[-c(1,2,3,4),]
consump.oil.petr.countries <- consump.oil.petr.p[-c(1,2,3,4),]
consump.gas.countries      <- consump.gas.p[-c(1,2,3,4),]
consump.renew.countries    <- consump.renew.p[-c(1,2,3,4),]

consump.oil.petr.europe <- consump.oil.petr.p[3,]
consump.gas.europe <- consump.gas.p[3,]
consump.fossils.europe <- consump.fossils.p[3,]
consump.renew.europe <- consump.renew.p[3,]

colnames(energy.balances.countries) <- NULL
colnames(consump.fossils.countries) <- NULL
colnames(consump.oil.petr.countries) <- NULL
colnames(consump.gas.countries) <- NULL
colnames(consump.renew.countries) <- NULL
```

Since we are working with time series, by their nature data are yearly correlated.
To deal with this problem, let's construct year to year variations datasets:
```{r}
energy.balances.diff <- energy.balances.p[-1,-1] - energy.balances.p[-1,-length(energy.balances.p)]
consump.fossils.diff <- consump.fossils.p[-1,-1] - consump.fossils.p[-1,-length(consump.fossils.p)]
consump.oil.petr.diff <- consump.oil.petr.p[-1,-1] - consump.oil.petr.p[-1,-length(consump.oil.petr.p)]
consump.gas.diff <- consump.gas.p[-1,-1] - consump.gas.p[-1,-length(consump.gas.p)]
consump.renew.diff <- consump.renew.p[-1,-1] - consump.renew.p[-1,-length(consump.renew.p)]

energy.balances.diff <- rbind(year=seq(1991, 2019), energy.balances.diff)
consump.fossils.diff <- rbind(year=seq(1991, 2019), consump.fossils.diff)
consump.oil.petr.diff <- rbind(year=seq(1991, 2019), consump.oil.petr.diff)
consump.gas.diff <- rbind(year=seq(1991, 2019), consump.gas.diff)
consump.renew.diff <- rbind(year=seq(1991, 2019), consump.renew.diff)
```

The analysis of current European renewable transition is structured in three sections:

## First target: investigate how renewable and non-renewable consumptions are evolving.


We can visualize the consumption levels of all EU countries.

Via time series visualization of :
```{r}
#matplot(seq(year.min, year.max), t(energy.balances.countries), type="l", lty=1,
        #main="Energy Balances EU 1990 - 2019", xlab="Year", ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.fossils.countries), type="l", lty=1,
        main="Consumption of Solid Fossil Fuels EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.oil.petr.countries), type="l", lty=1,
        main="Consumption of Oil and Petroleum EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.gas.countries), type="l", lty=1,
        main="Consumption of Natural Gas EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.renew.countries), type="l", lty=1,
        main="Consumption of Renewables EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")
```

Via boxplot:
```{r}
#boxplot(energy.balances.countries, main="Boxplot Energy Balances", xlab="Countries", 
        #ylab="Terajoules")

boxplot(consump.fossils.countries, main="Boxplot of Consumption of Solid Fossil Fuels", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.oil.petr.countries, main="Boxplot of Consumption of Oil and Petroleum", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.gas.countries, main="Boxplot of Consumption of Natural Gas", xlab="Countries", 
        ylab="Terajoule")

boxplot(consump.renew.countries, main="Consumption of Renewables", xlab="Countries", 
        ylab="Terajoule")
```


First let us check for normality with a simple Shapiro-Wilk test.

Let us visualize a random country from the dataset and check whether it might be normally distributed:

```{r}

index.italy <- which(rownames(consump.renew.diff) == c("Italy"))
hist(t(consump.fossils.diff)[,index.italy])
hist(t(consump.oil.petr.diff)[,index.italy])
hist(t(consump.gas.diff)[,index.italy])
hist(t(consump.renew.diff)[,index.italy])

```

Now to check the distribution of p-values obtained with a Shapiro-Wilk test:
```{r}

p.values.ff <- numeric(length(countries.list)) # Fossil fuels
p.values.op <- numeric(length(countries.list)) # Oil&Petr.
p.values.ng <- numeric(length(countries.list)) # Natural gas 
p.values.re <- numeric(length(countries.list)) # RE
# FIXME: Error in shapiro.test(t(consump.gas.diff)[, c]) :  all 'x' values are identical
for(c in 1:length(countries.list)){
    p.values.ff[c] <- shapiro.test(t(consump.fossils.diff)[,c])$p.value
    p.values.op[c] <- shapiro.test(t(consump.oil.petr.diff)[,c])$p.value
    p.values.ng[c] <- shapiro.test(t(consump.gas.diff)[,c])$p.value # Ignore errors
    p.values.re[c] <- shapiro.test(t(consump.renew.diff)[,c])$p.value

}
hist(p.values.ff,breaks=20)
hist(p.values.op,breaks=20)
hist(p.values.ng,breaks=20)
hist(p.values.re,breaks=20)
```

### Permutational Two Population MV test - Comparing Consumption distributions

We want to compare the distributions of Non Renewable vs Renewable fuels for each country:
```{r}
consump.fossils.mean <- colMeans(consump.fossils.countries, na.rm=T)
consump.oil.petr.mean <- colMeans(consump.oil.petr.countries, na.rm=T)
consump.gas.mean <- colMeans(consump.gas.countries, na.rm=T)
consump.renew.mean <- colMeans(consump.renew.countries, na.rm=T)

matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean,
                                       consump.renew.mean)),
        type="l",main="Consumption means for each type of fuel",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(consump.fossils.mean)[2]+300000))

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas","Renewable Energies"), col=1:4, pch=2)


```
Plot of only non-renewables
```{r}
matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean)),
        type="l",main="Consumption means for each type of non renewable fuel",xlab="Years",ylab="Terajoules",lwd=2,lty=1,
        ylim=c(min(consump.fossils.mean)-30000,max(consump.fossils.mean)+30000))

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas"), col=1:3, pch=2)
```
We start with a permutational MANOVA to see whether the three non renewable sources have the same distribution #TODO: MANOVA

```{r}

consump.nonrenew.countries=rbind(consump.oil.petr.p[5:39,],
                                 consump.fossils.p[5:39,],consump.gas.p[5:39,])

nonrenew.source <- c(rep("Oil_Petr",35),rep("Fossil_Fuels",35),rep("Natural_Gas",35))
nonrenew.source <- factor(nonrenew.source)
```



```{r}
fit <- manova(as.matrix(consump.nonrenew.countries) ~ nonrenew.source)
print(summary.manova(fit,test="Wilks")) 
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
```


```{r}
set.seed(seed)
T_stat <- numeric(B)
n=dim(consump.nonrenew.countries)[1]

for(perm in 1:B){
  # choose random permutation
  permutation <- sample(1:n)
  source.perm <- nonrenew.source[permutation]
  fit.perm <- manova(as.matrix(consump.nonrenew.countries) ~ source.perm)
  T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="Wilks stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-2,1),main="Wilk stat ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```

```{r}

# H0: Distributions are equal
# H1: Distributions are not equal

# NG vs OP ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.gas.countries))[1]
n2 <- dim(as.matrix(consump.oil.petr.countries))[1]
n  <- n1 + n2

# Test statistic
T10 <- as.numeric((consump.gas.mean-consump.oil.petr.mean) %*% (consump.gas.mean-consump.oil.petr.mean))
T10

# Permutational distribution
T1 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

#FIXME: Error in pi[[j]] : subscript out of bounds
for(perm in 1:B){
    t_pooled = rbind(consump.gas.countries, consump.oil.petr.countries)
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm, na.rm = T)
    t2.mean_perm = colMeans(t2_perm, na.rm = T)
    T1[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T1,xlim=range(c(T1,T10)))
abline(v=T10,col=3,lwd=4)

plot(ecdf(T1))
abline(v=T10,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T1>=T10)/B
p_val

```

```{r}

# FF vs OP ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.fossils.mean))[1]
n2 <- dim(as.matrix(consump.oil.petr.mean))[1]
n  <- n1 + n2

# Test statistic
T20 <- as.numeric((consump.fossils.mean-consump.oil.petr.mean) %*% (consump.fossils.mean-consump.oil.petr.mean))
T20

# Permutational distribution
T2 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

#FIXME: Error in pi[[j]] : subscript out of bounds

for(perm in 1:B){
    t_pooled = rbind(consump.fossils.countries, consump.oil.petr.countries)
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm, na.rm = T)
    t2.mean_perm = colMeans(t2_perm, na.rm = T)
    T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T2,xlim=range(c(T2,T20)))
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T2>=T20)/B
p_val

```


What about using year-to-year variates? Does the renewable consumption growth follow the same distribution as the non renewable decrease?
```{r}

# RE vs OP ----------------------------------------------------------------
# Use year by year change of each energy (RE vs OP (or NG or FF))

#FIXME: Error in Ops.data.frame(consump.fossils.countries[, ] + consump.gas.countries[,  : ‘+’ only defined for equally-sized data frames
mean.consump.nonrenew <-(consump.fossils.countries[,]+consump.gas.countries[,]+consump.oil.petr.countries[,] )/3
mean.consump.nonrenew.mean=colMeans(mean.consump.nonrenew)

matplot(seq(year.min, year.max), t(rbind(mean.consump.nonrenew.mean,
                                         consump.renew.mean)),
        type="l",main="Consumption means renewables vs non-renewables",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(mean.consump.nonrenew.mean)[2]+300000),col=c(1,3),lty=c(1,1))
legend("topright",legend=c("Non-renewable sources","Renewable sources"),col=c(1,3),pch=2)


mean.consump.nonrenew.diff <- mean.consump.nonrenew[,-length(mean.consump.nonrenew)] - mean.consump.nonrenew[,-1] #"inverse" deltas for non renewables to obtain growing curve differences

consump.renew.diff <- consump.renew.countries[,-1] - consump.renew.countries[,-length(consump.renew.countries)]

mean.consump.nonrenew.diff.mean <- colMeans(mean.consump.nonrenew.diff, na.rm=T)
consump.renew.diff.mean <- colMeans(consump.renew.diff, na.rm=T)

matplot(seq(year.min+1,year.max), consump.renew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Renewable consumptions year to year average deltas",col="green")
matlines(seq(year.min+1,year.max), mean.consump.nonrenew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Mean non-renewable consumptions year to year inverse average deltas")


n1 <- dim(as.matrix(consump.renew.diff))[1]
n2 <- dim(as.matrix(mean.consump.nonrenew.diff))[1]
n  <- n1 + n2

# Test statistic
T30 <- as.numeric((consump.renew.diff.mean-mean.consump.nonrenew.diff.mean) %*% (consump.renew.diff.mean-mean.consump.nonrenew.diff.mean))
T30

# Permutational distribution
T3 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

for(perm in 1:B){
    t_pooled <- cbind(consump.renew.diff,mean.consump.nonrenew.diff)
    permutation <- sample(n)
    t_perm <- t_pooled[permutation,]
    t1_perm <- t_perm[1:n1,]
    t2_perm <- t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm <- colMeans(t1_perm, na.rm = T)
    t2.mean_perm <- colMeans(t2_perm, na.rm = T)
    T3[perm]  <- (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T3,xlim=range(c(T3,T30)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T30,col=3,lwd=4)

plot(ecdf(T3),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T30,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T3>=T30)/B
p_val

```




## Second Target: Investigate how electricity production coming from renewable sources is growing

Let's visualize the total electricity production trend by country

```{r}
tot_elec <- read.xlsx('data/total_electricity_use.xlsx')
# View(tot_elec)
tot_elec = preprocess(tot_elec)

colnames(tot_elec) <- tot_elec[1,] #use years as columns names
tot_elec <- tot_elec[-1,] #first row is now useless
tot_elec <- tot_elec[,-17] #don't consider 2020

matplot(colnames(tot_elec),t(tot_elec[4:39,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity production by country")
```

Let's visualize the production of electricity from renewables trend by country

```{r}
use_renew_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=1)
# View(use_renew_elec)
use_renew_elec = preprocess(use_renew_elec)

colnames(use_renew_elec) <- use_renew_elec[1,] #use years as columns names
use_renew_elec <- use_renew_elec[-1,] #first row now is useless


use_renew_elec <- use_renew_elec[!is.na(use_renew_elec[,16]),]
# View(use_renew_elec)



matplot(colnames(use_renew_elec),t(use_renew_elec[4:40,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from renewables by country")

```

Let's see which country is particularly above the others in total usage of renewables for electricity production

```{r}
rownames(use_renew_elec)[which.max(use_renew_elec[4:40,16])+3] #first three rows are total european statistics
```
Let's construct a dataset with percentage of electricity coming from renewables to visualize its evolution at a European level
```{r}
elec_percentage <- tot_elec

for (j in 1:16){
  elec_percentage[,j] <- use_renew_elec[-34,j]/elec_percentage[,j]
  #34th row is Montenegro, which didn't survive preprocessing in the total electricity production dataset
}
# View(elec_percentage)

years_04_19 <- as.numeric(colnames(elec_percentage))
plot(years_04_19,as.numeric(elec_percentage[2,]),main="Percentage of electricity coming from renewable sources - EU",xlab="Year",ylab="Percentage",type="l")
points(years_04_19,as.numeric(elec_percentage[2,]),col="Green",lwd=3)
```



### MANOVA to compare the distributions from the three main types of RE for electricity consumption

Getting and preprocessing electricity data
```{r}
use_hydro_elec <-read.xlsx('data/use_renew_elec.xlsx',sheet=2)
use_wind_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=4)
use_solar_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=6)

#clean hydro
use_hydro_elec=preprocess(use_hydro_elec)

colnames(use_hydro_elec) <- use_hydro_elec[1,]
use_hydro_elec <- use_hydro_elec[-1,]

use_hydro_elec <- use_hydro_elec[!is.na(use_hydro_elec[,16]),]

#clean wind
use_wind_elec=preprocess(use_wind_elec)

colnames(use_wind_elec) <- use_wind_elec[1,]
use_wind_elec <- use_wind_elec[-1,]

use_wind_elec <- use_wind_elec[!is.na(use_wind_elec[,16]),]

#clean solar
use_solar_elec=preprocess(use_solar_elec)

colnames(use_solar_elec) <- use_solar_elec[1,]
use_solar_elec <- use_solar_elec[-1,]

use_solar_elec <- use_solar_elec[!is.na(use_solar_elec[,16]),]

use_hydro_elec[] <- lapply(use_hydro_elec, as.numeric)
use_wind_elec[] <- lapply(use_wind_elec, as.numeric)
use_solar_elec[] <- lapply(use_solar_elec, as.numeric)


use_principal <- rbind(use_hydro_elec[4:40,],use_wind_elec[4:40,],use_solar_elec[4:40,])

#factor vector
source <- c(rep("Hydro",37),rep("Wind",37),rep("Solar",37))
source <- factor(source)
```

Let's obtain year to year differences from these datasets, as done before:

```{r}

tot_elec.diff        <- tot_elec[,-1] - tot_elec[,-length(tot_elec)]
colnames(tot_elec.diff) <- seq(2005,2019)

use_renew_elec.diff  <- use_renew_elec[,-1] - use_renew_elec[,-length(use_renew_elec)] 
colnames(use_renew_elec.diff) <- seq(2005,2019)

elec_percentage.diff <- elec_percentage[,-1] - elec_percentage[,-length(elec_percentage)]
colnames(elec_percentage.diff) <- seq(2005,2019)

use_hydro_elec.diff  <- use_hydro_elec[,-1] - use_hydro_elec[,-length(use_hydro_elec)]
use_solar_elec.diff  <- use_solar_elec[,-1] - use_solar_elec[,-length(use_solar_elec)]
use_wind_elec.diff   <- use_wind_elec[,-1] - use_wind_elec[,-length(use_wind_elec)]
colnames(use_hydro_elec.diff) <- seq(2005,2019)
colnames(use_solar_elec.diff) <- seq(2005,2019)
colnames(use_wind_elec.diff) <- seq(2005,2019)

use_principal.diff   <- rbind(use_hydro_elec.diff[4:40,], use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])     
colnames(use_principal.diff) <- seq(2005,2019)


```

Plot electricity trends

```{r}
matplot(colnames(use_principal),t(use_principal),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from Hydro-Wind-Solar",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```

```{r}
matplot(colnames(use_principal.diff),t(use_principal.diff),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from Hydro-Wind-Solar, year to year variations",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```


Seems like Hydro is uniformly more used than the other two, let's proceed to statistically test this fact
Seems like Hydro has less variations than the other two, let's proceed to statistically test this fact

Observed statistic:
```{r}
fit <- manova(as.matrix(use_principal.diff) ~ source)
print(summary.manova(fit,test="Wilks")) 
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
```

Run the test

```{r}
set.seed(seed)
T_stat <- numeric(B)
n=dim(use_principal.diff)[1]

for(perm in 1:B){
  # choose random permutation
  permutation <- sample(1:n)
  source.perm <- source[permutation]
  fit.perm <- manova(as.matrix(use_principal.diff) ~ source.perm)
  T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="Wilks stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-2,1),main="Wilk stat ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```

So here we have statistical evidence that the three main renewable sources have not the same growth distribution in terms of generated electricity.

We can further investigate whether Solar and Wind are equally distributed (i.e. developing at the same rate) or not.
```{r}
wind.mean = colMeans(use_wind_elec.diff[4:40,])
solar.mean = colMeans(use_solar_elec.diff[4:40,])
years_04_19=as.numeric(colnames(use_wind_elec)) #years from 2004 to 2019
years_05_19=years_04_19[-1]

matplot(years_05_19,t(rbind(wind.mean,solar.mean)), type='l', col=c("green","red"), lty=1,xlab="Year",ylab="Gigawatt-hour",main="Mean yearly variations of electricity production")
legend("topleft",legend=c("Wind","Solar"),col=c(3,2),pch=1)
```


```{r}
n1 = n2=dim(use_wind_elec.diff[4:40,])[1]
n  = n1 + n2

T20 = as.numeric((wind.mean-solar.mean) %*% (wind.mean-solar.mean))
T20

# Estimating the permutational distribution under H0

T2 = numeric(B)
set.seed(seed)
t_pooled = rbind(use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])

for(perm in 1:B){
  # Random permutation of indexes
  permutation = sample(n)
  t_perm = t_pooled[permutation,]
  t1_perm = t_perm[1:n1,]
  t2_perm = t_perm[(n1+1):n,]
  
  # Evaluation of the test statistic on permuted data
  t1.mean_perm = colMeans(t1_perm)
  t2.mean_perm = colMeans(t2_perm)
  T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
}

hist(T2,xlim=range(c(T2,T20)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T20,col=3,lwd=4)

pvalue=sum(T2>=T20)/B
pvalue
```


### Conformal prediction on types of RE for electricity production 

To understand how Hydro, Wind and Solar sources of electricity will grow with time we proceeded with some prediction of the amount of electricity coming from each of them, in function of Gdp, population and their interaction. 
    
For this purpose, we will first have to import the SSP data from our dataset, which was obtained by retrieving the year to year values from the original data (more details in "src/preprocessing_SSP.Rmd").

We also construct variations datasets that will prove to be useful in the near future.

```{r}
gdp <- read.xlsx("data/ssp_iiasa_YtY_gdp.xlsx", 1)
pop <- read.xlsx("data/ssp_iiasa_YtY_pop.xlsx", 1)

gdp.diff <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop.diff <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

rownames(gdp.diff) <- gdp$Country.Name
rownames(pop.diff) <- pop$Country.Name

gdp.diff <- gdp.diff[,-1] - gdp.diff[,-length(gdp.diff)]
pop.diff <- pop.diff[,-1] - pop.diff[,-length(pop.diff)]
years_90_40=colnames(pop)[-c(1,2,3,4)]

colnames(gdp.diff) <- years_90_40[-1]
colnames(pop.diff) <- years_90_40[-1]

gdp <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

colnames(gdp) <- years_90_40
colnames(pop) <- years_90_40

rownames(gdp) <- rownames(gdp.diff)
rownames(pop) <- rownames(pop.diff)
```

```{r}
gdp[is.na(gdp)] <- 0 #replace NA with 0
gdp.diff[is.na(gdp.diff)] <- 0 
```

EU totals - original data
For the moment we are trying to make predictions for the three renewable electricity sources with original data
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp)
discard.pop.idx <- rownames(pop)%in%rownames(gdp)

# Take EU totals 
use_solar_elec.total <- use_solar_elec[2,]
use_wind_elec.total <- use_wind_elec[2,]
use_hydro_elec.total <- use_hydro_elec[2,]

pop <- pop[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp)%in%rownames(use_solar_elec[-c(1,2,3),])
discard.pop.idx <- rownames(pop)%in%rownames(use_solar_elec[-c(1,2,3),])

gdp <- gdp[discard.gdp.idx,]
pop <- pop[discard.pop.idx,]


rn <- rownames(gdp)
gdp <- gdp[rn,]
pop <- pop[rn,]

gdp.total <- as.numeric(colSums(gdp))
pop.total <- as.numeric(colSums(pop))
```

Montenegro and Albania should be discarded as they have NaN values or no information available for either population or GDP (see "preprocessing_SSP.Rmd"). Kosovo should be discarded as it is not recognized by the SSP predictions.



Since we have data only from 2004 (instead of 1990) to 2019, more points are needed to construct predicting models. We generate these points through a smoothing procedure, obtaining monthly data.


Smoothing for solar, wind and hydro to obtain data for each month (total values)
```{r}
use_solar_elec.total.s <- smoothing_procedure(use_solar_elec.total, 2004, 2019, interval=2, row_names = rownames(use_solar_elec.total))
use_wind_elec.total.s <- smoothing_procedure(use_wind_elec.total, 2004, 2019, interval=2, row_names = rownames(use_wind_elec.total))
use_hydro_elec.total.s <- smoothing_procedure(use_hydro_elec.total, 2004, 2019, interval=2, row_names = rownames(use_hydro_elec.total))
```



```{r}
#using EU total values
gdp.elec.train <- gdp[,as.character(seq(2004,2019))]
pop.elec.train <- pop[,as.character(seq(2004,2019))]
gdp.elec.train = colSums(gdp.elec.train)
pop.elec.train = colSums(pop.elec.train)

gdp.elec.pred  <- gdp[,as.character(seq(2020,2030))]
pop.elec.pred  <- pop[,as.character(seq(2020,2030))]
gdp.elec.pred = colSums(gdp.elec.pred)
pop.elec.pred = colSums(pop.elec.pred)
```


Smoothing on Gdp and Population (total values)
```{r}

gdp.elec.train.s <- smoothing_procedure(t(data.frame(gdp.elec.train)), 2004, 2019, interval=2)
pop.elec.train.s <- smoothing_procedure(t(data.frame(pop.elec.train)), 2004, 2019, interval=2)

gdp.elec.pred.s <- smoothing_procedure(t(data.frame(gdp.elec.pred)), 2020, 2030, interval=2)
pop.elec.pred.s <- smoothing_procedure(t(data.frame(pop.elec.pred)), 2020, 2030, interval=2)

```


```{r}
#vectors for EU total data
vec_train = cbind(as.numeric(gdp.elec.train.s), as.numeric(pop.elec.train.s))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(as.numeric(gdp.elec.pred.s), as.numeric(pop.elec.pred.s))
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

We first tried to construct models using original data and checked the correlation of the residuals using the (partial) autocorrelation function, obtaining as we will see high correlation values.


Let's find the adequate models to use for conformal prediction

#### Wind model - original data
```{r}
tr_data=data.frame(t(use_wind_elec.total.s),vec_train)
colnames(tr_data)[1]="European_Union"
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
Pacf(model_gam$residuals)
```

#### Solar model - original data
```{r}
tr_data=data.frame(t(use_solar_elec.total.s),vec_train)
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's quit the interaction

```{r}
tr_data=data.frame(t(use_solar_elec.total.s),vec_train)
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```


```{r}
Pacf(model_gam$residuals)
```


#### Hydro model - original data
```{r}
tr_data=data.frame(t(use_hydro_elec.total.s),vec_train)
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's quit the interaction

```{r}
tr_data=data.frame(t(use_hydro_elec.total.s),vec_train)
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
We should quit population as well

```{r}
tr_data=data.frame(t(use_hydro_elec.total.s),vec_train)
model_gam=gam(European_Union ~ s(gdp,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```


```{r}
Pacf(model_gam$residuals)
```

Differences are much needed...

Since working with original data gave us residuals with high correlations, we decided to fit models using the year to year variations. We construct some GAM models on which we perform conformal prediction.
Each time we search for the best GAM model by looking at the significance of the covariates and the adjusted R squared.

First order differences
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We discard the countries which are not going to be used 
use_solar_elec.diff.c <- use_solar_elec.diff[c(F,F,F,discard.idx),]
use_wind_elec.diff.c <- use_wind_elec.diff[c(F,F,F,discard.idx),]
use_hydro_elec.diff.c <- use_hydro_elec.diff[c(F,F,F,discard.idx),]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(use_solar_elec.diff.c)
discard.pop.idx <- rownames(pop.diff)%in%rownames(use_solar_elec.diff.c)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]


rn <- rownames(gdp.diff)
gdp.diff <- gdp.diff[rn,]
pop.diff <- pop.diff[rn,]

use_solar_elec.diff.c <- use_solar_elec.diff.c[rn,]
use_wind_elec.diff.c <- use_wind_elec.diff.c[rn,]
use_hydro_elec.diff.c <- use_hydro_elec.diff.c[rn,]

```


Smoothing for solar, wind and hydro to obtain data for each month (variations)
```{r}
use_solar_elec.diff.s <- smoothing_procedure(use_solar_elec.diff.c, 2005, 2019, interval=2, row_names = rownames(use_solar_elec.diff.c))
use_wind_elec.diff.s <- smoothing_procedure(use_wind_elec.diff.c, 2005, 2019, interval=2, row_names = rownames(use_wind_elec.diff.c))
use_hydro_elec.diff.s <- smoothing_procedure(use_hydro_elec.diff.c, 2005, 2019, interval=2, row_names = rownames(use_hydro_elec.diff.c))
```

```{r}
#obtaining EU values
gdp.diff.total=t(data.frame(colSums(gdp.diff)))
pop.diff.total=t(data.frame(colSums(pop.diff)))

use_solar_elec.diff.total=t(data.frame(colSums(use_solar_elec.diff.s)))
use_wind_elec.diff.total=t(data.frame(colSums(use_wind_elec.diff.s)))
use_hydro_elec.diff.total=t(data.frame(colSums(use_hydro_elec.diff.s)))

```


```{r}
#using EU yearly variations
gdp.elec.diff.train <- gdp.diff.total[,as.character(seq(2005,2019))]
pop.elec.diff.train <- pop.diff.total[,as.character(seq(2005,2019))]

gdp.elec.diff.pred  <- gdp.diff.total[,as.character(seq(2020,2030))]
pop.elec.diff.pred  <- pop.diff.total[,as.character(seq(2020,2030))]
```

```{r}
gdp.elec.diff.train.s <- smoothing_procedure(t(data.frame(gdp.elec.diff.train)), 2005, 2019, interval=2)
pop.elec.diff.train.s <- smoothing_procedure(t(data.frame(pop.elec.diff.train)), 2005, 2019, interval=2)

gdp.elec.diff.pred.s <- smoothing_procedure(t(data.frame(gdp.elec.diff.pred)), 2020, 2030, interval=2)
pop.elec.diff.pred.s <- smoothing_procedure(t(data.frame(pop.elec.diff.pred)), 2020, 2030, interval=2)

```


```{r}
#vectors for EU yearly variations
vec_train = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(as.numeric(gdp.elec.diff.pred.s), as.numeric(pop.elec.diff.pred.s))
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

#### Wind model - First order differences

```{r}
tr_data=data.frame(t(use_wind_elec.diff.total),vec_train)
colnames(tr_data)[1]="European_Union"
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's try quitting one covariate at a time. We start quitting population
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's put back population and quit gdp

```{r}
model_gam=gam(European_Union ~ s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's put back gdp and quit the interaction term


```{r}
model_gam=gam(European_Union ~ s(pop,bs='cr') + s(gdp,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's try quitting the smooth terms, one at a time
```{r}
model_gam=gam(European_Union ~ gdp + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~  s(gdp,bs='cr') + pop + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```


```{r}
model_gam=gam(European_Union ~ s(gdp, bs='cr') + s(pop,bs='cr') + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ gdp + s(pop, bs='cr') + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's try quitting population term

```{r}
model_gam=gam(European_Union ~ gdp + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ s(gdp, bs='cr') + pop + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ gdp + pop + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's try quitting gdp term

```{r}
model_gam_wind=gam(European_Union ~ pop + gdp:pop,data=tr_data)

summary(model_gam_wind)

hist(model_gam_wind$residuals)
qqnorm(model_gam_wind$residuals)
shapiro.test(model_gam_wind$residuals)
```
We stick with this last model that considers linear contribution from population and their interaction


```{r}
Pacf(model_gam_wind$residuals)
```
Unfortunately there is again a bit of correlation at 1 step but this could be due to the smoothing that we had to apply in order to construct the models (as mentioned before). Anyway it is clearly better than the corresponding best model constructed with original data.


#### Hydro model - First order differences

Let's go on constructing hydro model

```{r}
tr_data=data.frame(t(use_hydro_elec.diff.total),vec_train)
colnames(tr_data)[1]="European_Union"
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's try quitting one covariate at a time

```{r}
model_gam=gam(European_Union ~ s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') ,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's try quitting the smooth terms, one at a time

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + gdp:pop ,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
```{r}
model_gam=gam(European_Union ~ pop + s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
```{r}
model_gam=gam(European_Union ~ s(pop,bs='cr')+ gdp + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ pop + gdp + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ s(pop,bs='cr') + gdp + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~  gdp + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + pop + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```


```{r}
model_gam=gam(European_Union ~ pop + gdp + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ pop + pop:gdp,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
```{r}
model_gam=gam(European_Union ~ pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's try to explain the differences of hydro usage with original data of EU gdp and population

```{r}
#vectors for EU total data
vec_train = cbind(as.numeric(gdp.elec.train.s[,3:31]), as.numeric(pop.elec.train.s[,3:31]))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(as.numeric(gdp.elec.pred.s), as.numeric(pop.elec.pred.s))
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```
```{r}
tr_data=data.frame(t(use_hydro_elec.diff.total),vec_train)
colnames(tr_data)[1]="European_Union"
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's quit the interaction
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's quit gdp as well
```{r}
model_gam=gam(European_Union ~ s(pop,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's quit smooth terms one at a time
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's quit gdp
```{r}
model_gam=gam(European_Union ~ s(pop,bs='cr') + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ gdp + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's quit the interaction term
```{r}
model_gam=gam(European_Union ~ gdp+ s(pop,bs='cr') ,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + pop + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's quit gdp
```{r}
model_gam=gam(European_Union ~ pop + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's quit the interaction
```{r}
model_gam=gam(European_Union ~ pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's continue to search for a more complete model
```{r}
model_gam=gam(European_Union ~ gdp+ pop+ s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's quit population

```{r}
model_gam=gam(European_Union ~ gdp+  s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Quit the interaction
```{r}
model_gam=gam(European_Union ~ gdp,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + pop + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Quit gdp
```{r}
model_gam=gam(European_Union ~ pop + gdp:pop ,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Better...


```{r}
Pacf(model_gam$residuals)
```

```{r}
model_gam_hydro=model_gam
```


#### Solar model - First order differences

Let's go back to yearly variation datasets
```{r}
#vectors for EU yearly variations
vec_train = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(as.numeric(gdp.elec.diff.pred.s), as.numeric(pop.elec.diff.pred.s))
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

```{r}
tr_data=data.frame(t(use_solar_elec.diff.total),vec_train)
colnames(tr_data)[1]="European_Union"
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Quit one at a time
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Quit smooth terms, one at a time
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ gdp + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + pop + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ gdp + pop +  s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + pop + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
model_gam=gam(European_Union ~ gdp+ s(pop,bs='cr') + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's quit population

```{r}
model_gam=gam(European_Union ~ gdp + gdp:pop,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Quit the interaction

```{r}
model_gam=gam(European_Union ~ gdp,data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's move again to original data of gdp and population to construct this model
```{r}
#vectors for EU total data
vec_train = cbind(as.numeric(gdp.elec.train.s[,3:31]), as.numeric(pop.elec.train.s[,3:31]))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_test = cbind(as.numeric(gdp.elec.pred.s), as.numeric(pop.elec.pred.s))
vec_test=data.frame(vec_test)
colnames(vec_test)=c("gdp","pop")

vec_train
```

```{r}
tr_data=data.frame(t(use_solar_elec.diff.total),vec_train)
colnames(tr_data)[1]="European_Union"
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```


```{r}
Pacf(model_gam$residuals)
```
Some high correlations in residuals but we stick with this model
```{r}
model_gam_solar=model_gam
```

Little review of the selected models
```{r}
summary(model_gam_wind)

```

```{r}
summary(model_gam_hydro)

```

```{r}
summary(model_gam_solar)

```



### Predictions

Creation of models for train and for predictions, according to:
https://fromthebottomoftheheap.net/2021/02/02/random-effects-in-gams/

```{r}
train_gam_wind <- function(x,y,out=NULL){
    colnames(x)=c("gdp", "pop")
    train_data=data.frame(y,x)
    model_gam=gam(y ~ pop + gdp:pop, data=train_data)
}


predict_gam_wind <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop")
    predict.gam(obj,new_x)
}
```

```{r}
vec_train_wind = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train_wind=data.frame(vec_train_wind)
colnames(vec_train_wind)=c("gdp","pop")

vec_test_wind = cbind(as.numeric(gdp.elec.diff.pred.s), as.numeric(pop.elec.diff.pred.s))
vec_test_wind=data.frame(vec_test_wind)
colnames(vec_test_wind)=c("gdp","pop")
```

```{r}
train_gam_hydro <- function(x,y,out=NULL){
    colnames(x)=c("gdp", "pop")
    train_data=data.frame(y,x)
    model_gam=gam(y ~ pop + gdp:pop, data=train_data)
}


predict_gam_hydro <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop")
    predict.gam(obj,new_x)
}
```

```{r}
vec_train_hydro = cbind(as.numeric(gdp.elec.train.s[,3:31]), as.numeric(pop.elec.train.s[,3:31]))
vec_train_hydro=data.frame(vec_train_hydro)
colnames(vec_train_hydro)=c("gdp","pop")

vec_test_hydro = cbind(as.numeric(gdp.elec.pred.s), as.numeric(pop.elec.pred.s))
vec_test_hydro=data.frame(vec_test_hydro)
colnames(vec_test_hydro)=c("gdp","pop")
```

```{r}
train_gam_solar <- function(x,y,out=NULL){
    colnames(x)=c("gdp", "pop")
    train_data=data.frame(y,x)
    model_gam=gam(y ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'), data=train_data)
}


predict_gam_solar <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("gdp", "pop")
    predict.gam(obj,new_x)
}
```

```{r}
vec_train_solar = cbind(as.numeric(gdp.elec.train.s[,3:31]), as.numeric(pop.elec.train.s[,3:31]))
vec_train_solar=data.frame(vec_train_solar)
colnames(vec_train_solar)=c("gdp","pop")

vec_test_solar = cbind(as.numeric(gdp.elec.pred.s), as.numeric(pop.elec.pred.s))
vec_test_solar=data.frame(vec_test_solar)
colnames(vec_test_solar)=c("gdp","pop")
```


```{r}
#Eu total predictions
c_preds.wind.total <- conformal.pred(
    as.matrix(vec_train_wind), 
    use_wind_elec.diff.total,
    as.matrix(vec_test_wind),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam_wind, 
    predict.fun = predict_gam_wind)

c_preds.solar.total <- conformal.pred(
    as.matrix(vec_train_solar), 
    use_solar_elec.diff.total,
    as.matrix(vec_test_solar),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam_solar, 
    predict.fun = predict_gam_solar)

c_preds.hydro.total <- conformal.pred(
    as.matrix(vec_train_hydro), 
    use_hydro_elec.diff.total,
    as.matrix(vec_test_hydro),
    alpha=0.05, 
    verbose=T, 
    train.fun = train_gam_hydro, 
    predict.fun = predict_gam_hydro)

#Error in gam(y ~ s(gdp) + s(pop), data = train_data) : Model has more coefficients than data

#FIXME: More data are necessary to work with total values, can we apply smoothing, creating data each 3 months? We need this to predict wind, solar and hydro electricity production, so consequently also gdp and pop. This problem occurs only for electricity data, since they begin in 2004, while for the following models there should not be this problem.
#Using all the countries brings to ugly plots in conformal predictions, so we worked with total EU values
```

Plot predictions 2020-2030:

```{r}
plot(seq(2005,2019,0.5), use_wind_elec.diff.total, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Wind Electricity Use',ylim=c(9000,60000))

lines(seq(2020,2030,0.5),c_preds.wind.total$pred,lwd =2, col ="green",lty=3)
lines(seq(2020,2030,0.5),c_preds.wind.total$up,lwd =1, col =" blue",lty =3)
lines(seq(2020,2030,0.5),c_preds.wind.total$lo, lwd =1, col =" blue",lty =3)

```

```{r}
plot(seq(2005,2019,0.5), use_hydro_elec.diff.total, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Hydro Electricity Use',ylim=c(-10000,10000))

lines(seq(2020,2030,0.5),c_preds.hydro.total$pred,lwd =2, col ="green",lty=3)
lines(seq(2020,2030,0.5),c_preds.hydro.total$up,lwd =1, col =" blue",lty =3)
lines(seq(2020,2030,0.5),c_preds.hydro.total$lo, lwd =1, col =" blue",lty =3)
lines(seq(2005,2019,0.5),c_preds.hydro.total$fit, lwd =1, col =" green",lty =1)


```

```{r}
plot(seq(2005,2019,0.5), use_solar_elec.diff.total, xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Solar Electricity Use',ylim=c(-100000,40000))

lines(seq(2020,2030,0.5),c_preds.solar.total$pred,lwd =2, col ="green",lty=3)
lines(seq(2020,2030,0.5),c_preds.solar.total$up,lwd =1, col =" blue",lty =3)
lines(seq(2020,2030,0.5),c_preds.solar.total$lo, lwd =1, col =" blue",lty =3)
lines(seq(2005,2019,0.5),c_preds.solar.total$fit, lwd =1, col =" green",lty =1)


```
```{r}
wind.predictions=use_wind_elec.total[,16]+cumsum(c_preds.wind.total$pred)
wind.predictions.up=use_wind_elec.total[,16]+cumsum(c_preds.wind.total$up)
wind.predictions.low=use_wind_elec.total[,16]+cumsum(c_preds.wind.total$lo)

plot(seq(2004,2019),use_wind_elec.total,xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Wind Electricity Use',ylim=c(min(use_wind_elec.total-1000),max(wind.predictions.up+1000)))
points(seq(2020,2030,0.5),wind.predictions,col="green",cex=0.5)
lines(seq(2020,2030,0.5),wind.predictions.up,col="blue",lwd=1,lty=3)
lines(seq(2020,2030,0.5),wind.predictions.low,col="blue",lwd=1,lty=3)

```

```{r}
hydro.predictions=use_hydro_elec.total[,16]+cumsum(c_preds.hydro.total$pred)
hydro.predictions.up=use_hydro_elec.total[,16]+cumsum(c_preds.hydro.total$up)
hydro.predictions.low=use_hydro_elec.total[,16]+cumsum(c_preds.hydro.total$lo)

plot(seq(2004,2019),use_hydro_elec.total,xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Hydro Electricity Use',ylim=c(min(hydro.predictions.low-1000),max(hydro.predictions.up+1000)))
points(seq(2020,2030,0.5),hydro.predictions,col="green",cex=0.5)
lines(seq(2020,2030,0.5),hydro.predictions.up,col="blue",lwd=1,lty=3)
lines(seq(2020,2030,0.5),hydro.predictions.low,col="blue",lwd=1,lty=3)

```
```{r}
solar.predictions=use_solar_elec.total[,16]+cumsum(c_preds.solar.total$pred)
solar.predictions.up=use_solar_elec.total[,16]+cumsum(c_preds.solar.total$up)
solar.predictions.low=use_solar_elec.total[,16]+cumsum(c_preds.solar.total$lo)

plot(seq(2004,2019),use_solar_elec.total,xlim=range(c(2005,2030)),cex =.5,xlab="Year",ylab="Terajoule",col =" darkgrey ",main='GAM conformal prediction - Solar Electricity Use',ylim=c(min(solar.predictions.low-1000),max(solar.predictions.up+1000)))
points(seq(2020,2030,0.5),solar.predictions,col="green",cex=0.5)
lines(seq(2020,2030,0.5),solar.predictions.up,col="blue",lwd=1,lty=3)
lines(seq(2020,2030,0.5),solar.predictions.low,col="blue",lwd=1,lty=3)
```


## Third Target: Analyse the current European renewable energy network.

### Regression on european electricity capacity

Let's plot some trends
```{r}
matplot(colnames(prod.by.fuel.total.p),t(prod.by.fuel.total.p[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Total electricity capacities")
```

```{r}
matplot(colnames(prod.by.fuel.comb.p),t(prod.by.fuel.comb.p[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from non-renewables")
```


```{r}
prod.by.fuel.renew.countries=prod.by.fuel.renew[-c(1,2,3),]
matplot(colnames(prod.by.fuel.renew.countries),t(prod.by.fuel.renew.countries),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from renewables")
```

Now let's perform different kinds of nonparametric regression to compare European trends of renewable vs non renewable electricity capacity
```{r}
years_90_19=as.numeric(colnames(prod.by.fuel.comb.p))
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European non-renewable electricity capacity",xlab="Year",ylab="Megawatt")
```

```{r}
m_list=lapply(1:10,function(degree){lm(as.numeric(prod.by.fuel.comb.p[2,]) ~ poly(as.numeric(years_90_19),degree=degree))})
do.call(anova,m_list)
```


```{r}
summary(m_list[[2]])
```

```{r}
summary(m_list[[3]])

```

```{r}
summary(m_list[[6]])

```


```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[2]]$fitted.values,col="red")

```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[3]]$fitted.values,col="red")
```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[6]]$fitted.values,col="red")
```

Third grade polynomial regression seems reasonable (theorethically we should choose grade 9, since it's the last significant model: 10th grade regression is not significant)

```{r}
comb_model=m_list[[3]]
```


Now let's move to renewables
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
```

```{r}
m_list=lapply(1:10,function(degree){lm(as.numeric(prod.by.fuel.renew[2,]) ~ poly(as.numeric(years_90_19),degree=degree))})
do.call(anova,m_list)
```
```{r}
summary(m_list[[2]])

```
```{r}
summary(m_list[[4]])

```
```{r}
summary(m_list[[7]])

```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[2]]$fitted.values,col="green")
```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[4]]$fitted.values,col="green")
```

```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[7]]$fitted.values,col="green")
```
Since by passing to fourth grade we only add one parameter w.r.t second grade (third grade coefficient is considered zero), we can consider the fourth grade regression.

But we can notice that the coefficient of fourth grade is negative! It's not really reasonable for future predictions, so we stick to second grade


```{r}
ren_model=m_list[[2]]
```


```{r}
anni=seq(range(years_90_19)[1],range(years_90_19)[2],by=0.25)
preds=predict(comb_model,list(years_90_19=anni),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(years_90_19 ,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni), ylim=range(as.numeric(prod.by.fuel.renew[2,]))+5000,cex =.5, col =" darkgrey ",main='Polynomial regression on european electricity capacity',xlab="Year",ylab="Megawatt")
lines(anni,preds$fit ,lwd =2, col =" red")
matlines (anni ,se.bands ,lwd =1, col =" red",lty =3)

preds=predict(ren_model,list(years_90_19=anni),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ",pch=2)
lines(anni,preds$fit ,lwd =2, col =" green")
matlines (anni ,se.bands ,lwd =1, col =" green",lty =3)

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)
```

Let's try with spline regression
```{r}
#combustible fuels
b=data.frame(cap=as.numeric(prod.by.fuel.comb.p[2,]),years_b=years_90_19)
comb_model_spline <- lm(cap ~ bs(years_b, df=7,degree=2), data=b )
dat_b=data.frame(years_b=anni)

preds=predict(comb_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni),
    ylim=range(as.numeric(prod.by.fuel.renew[2,]))+5000,cex =.5, col =" darkgrey ",
    main="Splines regression on european electricity capacity",xlab="Year",ylab="Megawatt")

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)

lines(anni,preds$fit ,lwd =2, col =" red")
matlines(anni, se.bands ,lwd =1, col =" red",lty =3)

#renewables
c=data.frame(cap=as.numeric(prod.by.fuel.renew[2,]),years_b=years_90_19)
ren_model_spline <- lm(cap ~ bs(years_b, df=7,degree=2), data=c )
dat_b=data.frame(years_b=anni)

preds=predict(ren_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ")
lines(anni,preds$fit ,lwd =2, col =" green")
matlines(anni, se.bands ,lwd =1, col =" green",lty =3)
```

Natural splines
```{r}
comb_model_spline <- lm(cap ~ ns(years_b, df=8), data=b )
dat_b=data.frame(years_b=anni)

preds=predict(comb_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

plot(years_90_19 ,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni) ,ylim=range(as.numeric(prod.by.fuel.renew[2,]))+3000,cex =.5, col =" darkgrey ",
     main="Natural Splines regression on european electricity capacity",xlab="Year",ylab="Megawatt")

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)

lines(anni,preds$fit ,lwd =2, col =" red")
matlines(anni, se.bands ,lwd =1, col =" red",lty =3)

ren_model_spline <- lm(cap ~ ns(years_b, df=7), data=c )
dat_b=data.frame(years_b=anni)

preds=predict(ren_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ")
lines(anni,preds$fit ,lwd =2, col =" green")
matlines(anni, se.bands ,lwd =1, col =" green",lty =3)
```

Natural cubic splines seems the best approach, it better captures all the local variations.


### ANOVA test on 2019 capacities, dividing Europe in four regions

Set a region-based analysis of electricity capacity

```{r}

countries=rownames(prod.by.fuel.renew.countries)# TODO: recompute this dataset, it's the sum of the capacities coming from different sources in prod.by.fuel dataset (discard combustible fuels and nuclear)

north_europe=c("Denmark","Estonia","Latvia","Lithuania","Finland","Sweden","Norway","Iceland","United Kingdom","Ireland")

east_europe=c("Bulgaria","Czechia","Hungary","Poland","Romania","Slovakia","Turkey","Ukraine")

south_europe=c("Greece","Spain","Italy","Cyprus","Malta","Portugal","Croatia","Slovenia","North Macedonia","Albania","Serbia")

central_europe=c("France","Belgium","Germany (until 1990 former territory of the FRG)","Luxembourg","Netherlands","Austria") #TODO: change Germany name

length(countries)==length(c(north_europe,south_europe,east_europe,central_europe))  #just to see correct division
```
Let's build the dataframe with groups attached, to perform an anova test on 2019 capacities
```{r}
north=prod.by.fuel.renew.countries[match(north_europe,countries),30]
east=prod.by.fuel.renew.countries[match(east_europe,countries),30]
south=prod.by.fuel.renew.countries[match(south_europe,countries),30]
central=prod.by.fuel.renew.countries[match(central_europe,countries),30]

north=cbind(north,rep("North",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("South",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_no_nuclear=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_no_nuclear)=c("cap_19","Region")
aov_no_nuclear$Region=factor(aov_no_nuclear$Region)
```

Proceed with anova test
```{r}
attach(aov_no_nuclear)
g=nlevels(aov_no_nuclear$Region)
g
boxplot(as.numeric(cap_19) ~ Region,col=rainbow(g),main="Electricity capacity by region",ylab="Megawatt")
```

```{r}
cap_19=as.numeric(cap_19)
fit <- aov(cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

B=10000
T_stat <- numeric(B) 
n <- dim(aov_no_nuclear)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20))
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```
With aovp?
```{r}
library(lmPerm)
lmp=aovp(cap_19 ~ Region,perm="Prob",Cp=1e-6)#cp is supposed to stop iterations when standard error is at that level...
summary(lmp)
detach(aov_no_nuclear)
#pretty much same result
```
Again, we don't have statistical evidence to say that electricity capacities from renewables have different distribution in the four regions of Europe.
This is not a meaningful result, since we are not taking into account the sizes of countries. It's better to analyze a relative quantity, like the ratio between renewable and total capacity!

Let's build the ad-hoc dataframe with relative capacities of 2019
```{r}
north=prod.by.fuel.renew.countries[match(north_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(north_europe,countries),30])

east=prod.by.fuel.renew.countries[match(east_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(east_europe,countries),30])

south=prod.by.fuel.renew.countries[match(south_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(south_europe,countries),30])

central=prod.by.fuel.renew.countries[match(central_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(central_europe,countries),30])

north=cbind(north,rep("Northern",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("Southern",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_ratio_cap=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_ratio_cap)=c("ratio_cap_19","Region")
aov_ratio_cap$Region=factor(aov_ratio_cap$Region)
```

```{r}
attach(aov_ratio_cap)
g=nlevels(aov_ratio_cap$Region)
g
boxplot(as.numeric(ratio_cap_19) ~ Region,col=c("cyan1","indianred1","cornflowerblue","chartreuse1"),main="Relative renewable electricity capacity by region",ylab="Percentage")
```
```{r}
ratio_cap_19=as.numeric(ratio_cap_19)
fit <- aov(ratio_cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

T_stat <- numeric(B) 
n <- dim(aov_ratio_cap)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- ratio_cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="F stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20),main="F stat permutational ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
detach(aov_ratio_cap)
```
Still no statistical evidence of different development in different regions

# Core: Model to predict future european GHG emissions
We have set ourselves the goal of predicting whether the Green Deal target of a 55% cut in greenhouse gases emissions by 2030 with respect to 1990 levels is feasible.

With the target to develop a model to predict future Greenhouse gases emissions as a function of the other energy indicators we had to previously construct a variety of auxiliar models to predict covariates values to be used in the final model.


Keeping only European countries for which we have complete data of Gdp, Population and Energy consumptions.
```{r}
# Not in SSP GDP data and in EUstat data
discard.idx <- rownames(consump.oil.petr.diff[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# REVIEW: We smooth the non-renewable data to obtain values for each month of each year
consump.oil.petr.diff.s <- consump.oil.petr.diff[-1,]
consump.fossils.diff.s <- consump.fossils.diff[-1,]
consump.gas.diff.s <- consump.gas.diff[-1,]

colnames(consump.oil.petr.diff.s) <- consump.oil.petr.diff[1,]
colnames(consump.fossils.diff.s) <- consump.fossils.diff[1,]
colnames(consump.gas.diff.s) <- consump.gas.diff[1,]

consump.oil.petr.diff.s <- smoothing_procedure(consump.oil.petr.diff.s, 1991, 2019,interval=1, row_names = rownames(consump.oil.petr.diff.s))
consump.gas.diff.s <- smoothing_procedure(consump.gas.diff.s, 1991, 2019,interval=1, row_names = rownames(consump.gas.diff.s))
consump.fossils.diff.s <- smoothing_procedure(consump.fossils.diff.s, 1991, 2019, interval=1,row_names = rownames(consump.fossils.diff.s))

# We discard the countries which are not going to be used, as well as the EU totals 
consump.oil.petr.diff.total <- consump.oil.petr.diff[3,]
consump.gas.diff.total <- consump.gas.diff[3,]
consump.fossils.diff.total <- consump.fossils.diff[3,]
consump.renew.diff.total <- consump.renew.diff[3,]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in EUstat data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(consump.oil.petr.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(consump.oil.petr.diff)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]

gdp.diff.total<-as.numeric(colSums(gdp.diff,na.rm=T))[1:40] #we have data until 2100,                                                               so we keep only until 2030
pop.diff.total<-as.numeric(colSums(pop.diff,na.rm=T))[1:40]

```


```{r}
gdp.train <- gdp.total[1:30] #from 1990 until 2019
pop.train <- pop.total[1:30]

gdp.pred <- gdp.total[31:41]
pop.pred <- pop.total[31:41]
```


Since we are working with time series, where there is a strong temporal dependence, from now on each time we are constructing a model we check the correlation of the residuals using the (partial) autocorrelation function. This is important to understand whether the model is able to capture the relations in original data or whether it is better to perform a first order differentiation to mitigate the natural collinearity problem of these datasets. With this idea in mind, we initially fit the models with original data and then saw whether it is necessary or not to switch to the yearly variations.


## EU_NON_RENEWABLE CONSUMPTIONS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION

Includes three models, one for each non-renewable energy:
    - EU_PETROLEUM  ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
    - EU_SOLID FOSSIL FUELS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
    - EU_NATURAL GAS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION

```{r}
#Eu total data
vec_oil <- t(rbind(consump.oil.petr.europe,gdp.train,pop.train))
vec_oil <- data.frame(vec_oil)
colnames(vec_oil)=c("oil_eu","gdp_eu","pop_eu")

vec_oil_pred <- cbind(gdp.pred, pop.pred)
vec_oil_pred <- data.frame(vec_oil_pred)

colnames(vec_oil_pred) <- c("gdp_eu","pop_eu")

vec_fossil <- t(rbind(consump.fossils.europe,gdp.train, pop.train))
vec_fossil <- data.frame(vec_fossil)
colnames(vec_fossil)=c("fossil_eu","gdp_eu","pop_eu")

vec_fossil_pred=vec_oil_pred

vec_gas <- t(rbind(consump.gas.europe,gdp.train, pop.train))
vec_gas <- data.frame(vec_gas)
colnames(vec_gas)=c("gas_eu","gdp_eu","pop_eu")

vec_gas_pred=vec_oil_pred
```

Oil & Petr. total
```{r}
consump.oil.petr.gam <- gam(oil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') +s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```
We can discard the gdp
```{r}
consump.oil.petr.gam <- gam(oil_eu ~ s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

```{r}
Acf(
  consump.oil.petr.gam$residuals
)
```


```{r}
Pacf(
  consump.oil.petr.gam$residuals
)
```

Fossils
```{r}
consump.fossils.gam <- gam(fossil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
Population in this case is not significant

```{r}
consump.fossils.gam <- gam(fossil_eu ~ s(gdp_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
```{r}
consump.fossils.gam <- gam(fossil_eu ~ s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```



```{r}
Acf( 
  consump.fossils.gam$residuals
)
```

```{r}
Pacf( 
  consump.fossils.gam$residuals
)
```

Natural gas:
```{r}
consump.gas.gam <- gam(gas_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)

```
Let's start quitting the interaction

```{r}
consump.gas.gam <- gam(gas_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```


```{r}
Acf(
  consump.gas.gam$residuals
)
```

```{r}
Pacf(
  consump.gas.gam$residuals
)
```
Since the correlations are not negligible, we pass to first order differences

## DIFF_NON_RENEWABLE CONSUMPTIONS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION

Includes three models, one for each non-renewable energy:
    - DIFF_EU_PETROLEUM  ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION
    - DIFF_EU_SOLID FOSSIL FUELS ~ DIFF_EU_GDP + DIFF_EU_POPULATION +                                                                            DIFF_EU_GDP:DIFF_EU_POPULATION
    - DIFF_EU_NATURAL GAS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION

```{r}
gdp.train <- gdp.diff.total[1:29]
pop.train <- pop.diff.total[1:29]

gdp.pred  <- gdp.diff.total[30:40]
pop.pred  <- pop.diff.total[30:40]
```




```{r}

vec_oil <- t(rbind(consump.oil.petr.diff.total,gdp.train,pop.train))
vec_oil <- data.frame(vec_oil)
colnames(vec_oil) <- c("dif_oil_eu","dif_gdp_eu","dif_pop_eu")


vec_oil_pred <- cbind(gdp.pred, pop.pred)
vec_oil_pred <- data.frame(vec_oil_pred)

colnames(vec_oil_pred) <- c("dif_gdp_eu","dif_pop_eu")

vec_fossil <- t(rbind(consump.fossils.diff.total,gdp.train, pop.train))
vec_fossil <- data.frame(vec_fossil)
colnames(vec_fossil) <- c("dif_fossil_eu","dif_gdp_eu","dif_pop_eu")


vec_fossil_pred = vec_oil_pred

colnames(vec_fossil_pred) <- c("dif_gdp_eu","dif_pop_eu")

vec_gas <- t(rbind(consump.gas.diff.total,gdp.train, pop.train))
vec_gas <- data.frame(vec_gas)
colnames(vec_gas) <- c("dif_gas_eu","dif_gdp_eu","dif_pop_eu")


vec_gas_pred=vec_fossil_pred

```




Oil & Petr.
```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_oil) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```
We quit the interaction term

```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_oil) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```
Quit pop as well


```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') ,data = vec_oil) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

We now test whether the smooth function is needed for the two covariates or if it is sufficient (or even better...) to consider a linear relationship

```{r}
consump.oil.petr.gam.1 <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + dif_pop_eu,data = vec_oil) 

summary(consump.oil.petr.gam.1)

hist(consump.oil.petr.gam.1$residuals)
qqnorm(consump.oil.petr.gam.1$residuals)
shapiro.test(consump.oil.petr.gam.1$residuals)
```
```{r}
consump.oil.petr.gam.2 <- gam(dif_oil_eu ~ dif_gdp_eu + s(dif_pop_eu,bs='cr'),data = vec_oil) 

summary(consump.oil.petr.gam.2)

hist(consump.oil.petr.gam.2$residuals)
qqnorm(consump.oil.petr.gam.2$residuals)
shapiro.test(consump.oil.petr.gam.2$residuals)
```

```{r}
consump.oil.petr.gam.3 <- gam(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu,data = vec_oil) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```
The last two very similar, we stick with number 2


```{r}
consump.oil.petr.gam=consump.oil.petr.gam.2
Acf(
  consump.oil.petr.gam$residuals
)
```

```{r}
Pacf(
  consump.oil.petr.gam$residuals
)
```



Fossils:
```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_fossil) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
Quit the interaction

```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_fossil) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```
Quit gdp as well

```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_pop_eu,bs='cr'),data = vec_fossil) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```

```{r}
Acf( 
  consump.fossils.gam$residuals
)
```

```{r}
Pacf( 
  consump.fossils.gam$residuals
)
```




```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```
Quit gdp

```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```
Quit interaction as well
```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```
Let's try again with some linear contributions

```{r}
consump.gas.gam.1 <- gam(dif_gas_eu ~ dif_pop_eu + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam.1)

hist(consump.gas.gam.1$residuals)
qqnorm(consump.gas.gam.1$residuals)
shapiro.test(consump.gas.gam.1$residuals)
```

```{r}
consump.gas.gam.2 <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas) 
summary(consump.gas.gam.2)

hist(consump.gas.gam.2$residuals)
qqnorm(consump.gas.gam.2$residuals)
shapiro.test(consump.gas.gam.2$residuals)
```

```{r}
consump.gas.gam.3 <- gam(dif_gas_eu ~ dif_pop_eu + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```
We select model number 3

```{r}
consump.gas.gam=consump.gas.gam.3
```


Predict for 2020-2030
```{r}
# Preds (2020-2030)

consump.oil.petr.gam.preds <- predict(consump.oil.petr.gam, newdata=vec_oil_pred, se=T)

consump.fossils.gam.preds <- predict(consump.fossils.gam, newdata=vec_fossil_pred, se=T)

consump.gas.gam.preds <- predict(consump.gas.gam, newdata=data.frame(vec_gas_pred,inter=vec_gas_pred$dif_gdp_eu*vec_gas_pred$dif_pop_eu), se=T)
```


Plot predictions
```{r}
# See graphs
with(vec_oil, plot(seq(1991,2019) ,dif_oil_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Oil & Petr.'))
points(seq(2020,2030), consump.oil.petr.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.oil.petr.gam$fitted.values,lwd=1,col="blue")


with(vec_fossil, plot(seq(1991,2019) ,dif_fossil_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Fossil fuels'))
points(seq(2020,2030), consump.fossils.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.fossils.gam$fitted.values,lwd=1,col="blue")


with(vec_gas, plot(seq(1991,2019) ,dif_gas_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Natural Gas'))
points(seq(2020,2030), consump.gas.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.gas.gam$fitted.values,lwd=1,col="blue")

```

We proceeded with yearly variations framework also for the following models


## DIFF_EU_RENEWABLE CONSUMPTIONS  ~ DIFF_EU_PETROLEUM  + DIFF_EU_SOLID FOSSILFUELS + DIFF_EU_NATURAL GAS:

Let's try with original data, total values
```{r}
# Join all energies for common DF
#vec_re <- cbind(as.numeric(consump.renew.europe[1,]),vec_oil$oil_eu,vec_fossil$fossil_eu, vec_gas$gas_eu)
#vec_re <- data.frame(vec_re)
#colnames(vec_re) <- c("value_re", "value_oil", "value_ff", "value_ng")
```

Variations version
```{r}
# Join all energies for common DF
vec_re <- cbind(as.numeric(consump.renew.diff.total[1,]),vec_oil$dif_oil_eu,vec_fossil$dif_fossil_eu, vec_gas$dif_gas_eu)

vec_re <- data.frame(vec_re)
colnames(vec_re) <- c("value_re", "value_oil", "value_ff", "value_ng")
```

We need smoothing also on oil,fossil fuels and natural gas differences, to  fit a more complex mode with interactions

```{r}
rownames(vec_re)=years_90_19[2:30]
vec_re.temp=t(vec_re)
vec_re.s=smoothing_procedure(vec_re.temp,1991,2019,interval=3)
rownames(vec_re.s)=rownames(vec_re.temp)
vec_re.s=data.frame(t(vec_re.s))
```


```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil,bs='cr') + s(value_ff,bs='cr') + s(value_ng,bs='cr') + s(I(value_oil*value_ff),bs='cr') + s(I(value_ff*value_ng),bs='cr') + s(I(value_oil*value_ng),bs='cr') + s(I(value_oil*value_ff*value_ng),bs='cr'), data=vec_re.s)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```
Quit fossil fuels and fossil fuels-natural gas interaction
```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil,bs='cr') +  s(value_ng,bs='cr') + s(I(value_oil*value_ff),bs='cr') + s(I(value_oil*value_ng),bs='cr') + s(I(value_oil*value_ff*value_ng),bs='cr'), data=vec_re.s)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```
Quit oil-fossil fuel interaction as well

```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil,bs='cr') +  s(value_ng,bs='cr') + s(I(value_oil*value_ng),bs='cr') + s(I(value_oil*value_ff*value_ng),bs='cr'), data=vec_re.s)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```


```{r}
Pacf(consump.renew.gam$residuals)
```

```{r}
oil.preds.s=data.frame(t(consump.oil.petr.gam.preds$fit))
colnames(oil.preds.s)=seq(2020,2030)
oil.preds.s=smoothing_procedure(oil.preds.s,2020,2030,interval=3)

ff.preds.s=data.frame(t(consump.fossils.gam.preds$fit))
colnames(ff.preds.s)=seq(2020,2030)
ff.preds.s=smoothing_procedure(ff.preds.s,2020,2030,interval=3)

gas.preds.s=data.frame(t(consump.gas.gam.preds$fit))
colnames(gas.preds.s)=seq(2020,2030)
gas.preds.s=smoothing_procedure(gas.preds.s,2020,2030,interval=3)
```



```{r}
vec_re_pred <- t(rbind(oil.preds.s,ff.preds.s, gas.preds.s))
vec_re_pred <- data.frame(vec_re_pred)
colnames(vec_re_pred) <- c("value_oil", "value_ff", "value_ng")


consump.renew.gam.preds <- predict(consump.renew.gam, newdata=vec_re_pred, se=T)
```

```{r}
# See graphs
with(vec_re, plot(seq(1991,2019) ,value_re ,xlim=c(1991,2030),cex=.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Renewable Energy Consumption'))
points(seq(2020,2030,1/3), consump.renew.gam.preds$fit ,cex=1, col ="red")
lines(seq(1991,2019,1/3),consump.renew.gam$fitted.values,col="blue",lwd=1)
```
```{r}
renew.predictions=data.frame(t(consump.renew.gam.preds$fit))
colnames(renew.predictions)=seq(2020,2030,1/3)
renew.predictions=renew.predictions[1,as.character(seq(2020,2030))]
```

```{r}
renew.predictions.total=consump.renew.europe[,30]+cumsum(renew.predictions)
```


## DIFF_TOTAL_GHG ~  DIFF_TOTAL_RENEWABLE CONSUMPTION

```{r}
c02 <- read.xlsx("data/annual-co-emissions-by-region.xlsx", sheet=2)

# Check if all countries are present in other EU stats 
sum(!(unique(c02$Country) %in% rownames(gdp))) > 0
sum(!( rownames(gdp) %in% unique(c02$Country))) > 0
```
Import EU dataframe
```{r}
#Co2=read.xlsx("data/owid-co2-data.xlsx",sheet=2,colNames=F)
#Co2=data.frame(Co2[,3])
#rownames(Co2)=years_90_19
#colnames(Co2)="ValueCo2"
#head(Co2)
```

```{r}
ghg=read.xlsx("data/ghg_emissions.xlsx",sheet=3,colNames=F)
ghg=data.frame(t(ghg))
rownames(ghg)=years_90_19
colnames(ghg)="ValueGhg"
head(ghg)

```



```{r}
plot(years_90_19,ghg$ValueGhg)
```


Core ok until here!!!
```{r}
ghg.diff=data.frame(ghg[-1,]-ghg[-30,])
colnames(ghg.diff)="diff_ghg"
```

```{r}
plot(seq(1991,2019),ghg.diff$diff_ghg)
```


```{r}
#using differences for covariates
vec_ghg= cbind(ghg.diff$diff_ghg,vec_re$value_re,vec_oil$dif_gdp_eu,vec_oil$dif_pop_eu)
vec_ghg <- data.frame(vec_ghg)
vec_ghg_pred <- data.frame(t(renew.predictions),vec_oil_pred$dif_gdp_eu,vec_oil_pred$dif_pop_eu)

colnames(vec_ghg) <- c("value_ghg", "value_re","value_gdp","value_pop")
colnames(vec_ghg_pred) <- c("value_re","value_gdp","value_pop")

```

```{r}
#using original data for covariates (Greenhouse gases still in differences)
vec_c02= cbind(Co2.diff$diff_co2,t(consump.renew.europe[,2:30]),gdp.total[2:30],pop.total[2:30])
vec_c02 <- data.frame(vec_c02)
vec_c02_pred <- data.frame(t(renew.predictions.total),gdp.total[31:41],pop.total[31:41])

colnames(vec_c02) <- c("value_c02", "value_re","value_gdp","value_pop")
colnames(vec_c02_pred) <- c("value_re","value_gdp","value_pop")

```



```{r}
rownames(vec_ghg)=years_90_19[2:30]
vec_ghg.temp=t(vec_ghg)
vec_ghg.s=smoothing_procedure(vec_ghg.temp,1991,2019,interval=3)
rownames(vec_ghg.s)=rownames(vec_ghg.temp)
vec_ghg.s=data.frame(t(vec_ghg.s))
View(vec_ghg.s)
```

```{r}
vec_ghg_pred.temp=t(vec_ghg_pred)
vec_ghg_pred.s=smoothing_procedure(vec_ghg_pred.temp,2020,2030,interval=3)
rownames(vec_ghg_pred.s)=rownames(vec_ghg_pred.temp)
vec_ghg_pred.s=data.frame(t(vec_ghg_pred.s))
```


```{r}
c02.gam <- gam(value_c02 ~ s(value_re,bs='cr') + s(value_gdp,bs='cr') + s(value_pop,bs='cr') + s(I(value_re*value_gdp),bs='cr') + s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr'), data=vec_c02.s)

summary(c02.gam)

hist(c02.gam$residuals)
qqnorm(c02.gam$residuals)
shapiro.test(c02.gam$residuals)
```

Let's quit gdp and renewables-gdp interaction

```{r}
c02.gam <- gam(value_c02 ~ s(value_re,bs='cr') +  s(value_pop,bs='cr') +  s(I(value_gdp*value_pop),bs='cr') + s(I(value_re*value_pop),bs='cr'), data=vec_c02.s)

summary(c02.gam)

hist(c02.gam$residuals)
qqnorm(c02.gam$residuals)
shapiro.test(c02.gam$residuals)
```
With original data as covariates stop here
```{r}
Pacf(c02.gam$residuals)

```


Let's quit the triple interaction
```{r}
c02.gam <- gam(value_c02 ~ s(value_re,bs='cr')  + s(value_pop,bs='cr') + s(I(value_re*value_gdp),bs='cr')  + s(I(value_re*value_pop),bs='cr'), data=vec_c02.s)

summary(c02.gam)

hist(c02.gam$residuals)
qqnorm(c02.gam$residuals)
shapiro.test(c02.gam$residuals)
```
Quit renewables-pop interaction as well
```{r}
c02.gam <- gam(value_c02 ~ s(value_re,bs='cr')  + s(value_pop,bs='cr') + s(I(value_re*value_gdp),bs='cr')  , data=vec_c02.s)

summary(c02.gam)

hist(c02.gam$residuals)
qqnorm(c02.gam$residuals)
shapiro.test(c02.gam$residuals)
```


```{r}
Pacf(c02.gam$residuals)
```
```{r}
#simple baseline model
ghg.gam <- gam(value_ghg ~ s(value_re,bs='cr'), data=vec_ghg)

summary(ghg.gam)

hist(ghg.gam$residuals)
qqnorm(ghg.gam$residuals)
shapiro.test(ghg.gam$residuals)
```

```{r}
Pacf(ghg.gam$residuals)
```


```{r}
#predictions with simple model
ghg.gam.preds <- predict(ghg.gam, newdata=vec_ghg_pred, se=T)

with(vec_ghg, plot(seq(1991,2019) ,value_ghg ,xlim=c(1990,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Ghg Emissions'))
points(seq(2020,2030),ghg.gam.preds$fit ,cex=0.5, col ="red")
lines(seq(1991,2019),ghg.gam$fitted.values,lwd=1,col="blue")
```
We should increase the level of significance to 6.6% in order to not reject this model.
So we also try to remove the smooth term

```{r}
#linear model
ghg.gam.linear <- gam(value_ghg ~ value_re, data=vec_ghg)

summary(ghg.gam.linear)

hist(ghg.gam.linear$residuals)
qqnorm(ghg.gam.linear$residuals)
shapiro.test(ghg.gam.linear$residuals)
```

Same situation so we stick with the previous model

## Predicted decrease
How much is the predicted decrease?

```{r}
Percentage_emissions=ghg[30,1]+cumsum(ghg.gam.preds$fit)
Percentage_decrease=as.numeric(100-Percentage_emissions[11])

Percentage_emissions
Percentage_decrease
```
A cut of 39.42% is expected with the actual rhythm, so more effort is needed in order to comply with the Green Deal objective!


```{r}
#predictions with more complete model
c02.gam.preds <- predict(c02.gam,newdata=data.frame(vec_c02_pred.s,inter1=vec_c02_pred.s$value_gdp*vec_c02_pred.s$value_pop,inter2=vec_c02_pred.s$value_re*vec_c02_pred.s$value_pop) , se=T)

with(vec_c02.s, plot(seq(1991,2019,1/3) ,value_c02 ,xlim=c(1990,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - Ghg Emissions'))
points(seq(2020,2030,1/3),c02.gam.preds$fit ,cex=0.5, col ="red")
lines(seq(1991,2019,1/3),c02.gam$fitted.values,lwd=1,col="blue")


#newdata=data.frame(vec_c02_pred.s,inter1=vec_c02_pred.s$value_re*vec_c02_pred.s$value_gdp,inter2=vec_c02_pred.s$value_re*vec_c02_pred.s$value_pop)
#ylim=c(-1000,20)
#inter3=vec_c02_pred.s$value_re*vec_c02_pred.s$value_gdp*vec_c02_pred.s$value_pop
```

How much is the predicted decrease?
```{r}
co2_original=vec_c02$value_c02[1]
co2_prediction=as.numeric(c02.gam.preds$fit[length(c02.gam.preds$fit)])

reduction=(co2_original-co2_prediction)/co2_original
reduction
```


```{r}
#ignore for now
c02.gam.preds <- predict(c02.gam, newdata=vec_c02_pred, se=T)

with(vec_c02, plot(rep(seq(1991,2019),34) ,value_c02 ,xlim=c(1991,2030),cex =.5,xlab="Year",ylab="Terajoule" , col =" darkgrey ",main='GAM Prediction - c02 levels.'))
points(rep(seq(2020,2030),34), consump.renew.gam.preds$fit ,lwd =2, col ="red")
```

# Robustness

## TODO:




