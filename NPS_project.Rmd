---
title: "NPS_project"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning=F)
```

# TITLE
Load necessary libraries:

```{r}
# General
library(openxlsx)
library(MASS)
library(progress)
library(np)
library(splines)
library(devtools)
library(tidyr)
library(jsonlite)
library(ISLR2)
library(pbapply)
# Depth
#library(robustbase)
# Functional data
library(roahd)
library(fda)
library(fdatest)
# Graphics packages
library(rgl)
library(hexbin)
library(ggplot2)
library(corrplot)
# GAM
library(mgcv)
# Conformal
#devtools::install_github(repo="ryantibs/conformal", subdir="conformalInference")
library(conformalInference)
library(forecast)


B=10000
seed=42
set.seed(seed)
```

### Preprocessing of data

We implemented auxiliary functions for easy preprocessing of data:

```{r}

# 1000 Tons Of Oil Equivalent to Terajoules = 41.1868
tto_2_tj <- function(tto) {
    return(tto * 41.868)
}

# Function cleans df removing NAN rows, setting values as numeric...
preprocess <- function(df, start_nrows=6, end_nrows=2, tj=T) { 
    
    # Remove first rows not containing significant data
    df <- df[-c(1:start_nrows,(dim(df)[1]-(end_nrows-1)):dim(df)[1]),]
    
    rownames(df) <- df[,1] #use countries as rownames
    df <- df[,-1]
    
    rownames(df)[1] <- "year"
    rownames(df)[3] <- "European_Union" #we use 28 countries as European total value
    
    # Remove rows with NA values (in first column)
    df <- df[!df[,1]==':',]
    
    
    # 3 decimals
    df[] <- lapply(df, as.numeric)  
    
    if(!tj) # All data should be converted to Terajoules
        df[-1,] <- lapply(df[-1,], tto_2_tj)
    
    return(df)
}


# Function for creating a smoothing procedure for any data given an interval:
# Interval corresponds to the frequency in each year: 2 =each 6 months, 3=each 4 months...
smoothing_procedure <- function (data, from, to, write_to=NA, interval=3, row_names=NULL){
    
    new.data <- data.frame(matrix(ncol =length(from:to), nrow = 0))
    
    comb.year.grid <- seq(from, to, 1)
    
    for(c in 1:dim(data)[1]){ # For each country
        
        data.data <- as.numeric(data[c, as.character(from:to)]) 
        data.data.nans <- is.na(data.data)
        n.comb.year.grid <- comb.year.grid[!data.data.nans]
        
        times_basis <- n.comb.year.grid 
        knots       <- c(n.comb.year.grid) # Location of knots
        n_knots     <- length(knots) # Number of knots
        n_order     <- 2 # order of basis functions: cubic bspline: order = 3 + 1
        n_basis     <- length(knots) + n_order - 2;
        
        basis <- create.bspline.basis(c(min(times_basis),max(times_basis)),n_basis,n_order,knots)
        
        ys <- smooth.basis(argvals=times_basis, y=data.data[!data.data.nans], fdParobj = basis)
        
        xfd <- ys$fd
        
        data.yby <- eval.fd(seq(min(n.comb.year.grid),max(n.comb.year.grid), 1/interval), xfd) #                    Obtain data year by year
        
        new.data <- rbind(new.data, c( rep(NA, ((to-from) + 1 - length(n.comb.year.grid))*interval),
                                       data.yby))
    }

    # Rename columns
    colnames(new.data) <- c(seq(from, to, 1/interval))   
    
    rownames(new.data) <- row_names
    
    
    if(!is.na(write_to)){
        write.xlsx(new.data, write_to, overwrite = T)
    }
    return(new.data)
}

```


In our script "preprocessing_SSP.rmd", we have additional code regarding the transformation of data of the SSP original data to fit our needs and located in "data/ssp_iiasa_YtY_gdp.xlsx" & "data/ssp_iiasa_YtY_pop.xlsx".


Loading necessary datasets

```{r}
energy.balances.1  <- read.xlsx("data/complete_energy_balances.xlsx",sheet=1) # Gross available energy, first sheet should be the best

consump.fossils  <- read.xlsx("data/consumption_solid_fossil_fuels.xlsx",sheet=1) # Inland consumption
consump.gas      <- read.xlsx("data/consumption_gas.xlsx",sheet=1) # Inland consumption
consump.oil.petr <- read.xlsx("data/consumption_oil_petroleum.xlsx",sheet=1) # Inland consumption

consump.renew.1  <- read.xlsx("data/consumption_renewables.xlsx",sheet=1) # Geothermal, inland consump
consump.renew.2  <- read.xlsx("data/consumption_renewables.xlsx",sheet=2) # Solar thermal, inland consump.
consump.renew.3  <- read.xlsx("data/consumption_renewables.xlsx",sheet=3) # Biofuels, inland consump.
consump.renew.4  <- read.xlsx("data/consumption_renewables.xlsx",sheet=4) # Biogases, inland consump.
consump.renew.5  <- read.xlsx("data/consumption_renewables.xlsx",sheet=5) # Renewable waste, inland consump.

percent.renew <- read.xlsx("data/percentage_renewables.xlsx") 

prod.by.fuel.total <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=1) # Electricity capacity
prod.by.fuel.comb <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=2)
prod.by.fuel.nuclear <- read.xlsx("data/production_capacities_by_fuel.xlsx", sheet=9)

```

We will now preprocess all datasets with our auxilary function. We will also compute the total Renewable energy's consumption levels by summing all the consumptions for all types of Renewable sources.

```{r}

energy.balances.p <- preprocess(energy.balances.1, tj=F)

consump.fossils.p <- preprocess(consump.fossils[,-32], tj=T) # without 2020 because of some missing data

consump.fossils.p[-1,] <- consump.fossils.p[-1,] * 25 #  Calorific power of Fossil Fuels
                                 
consump.oil.petr.p <- preprocess(consump.oil.petr[,-32], tj=F) # without 2020
consump.gas.p      <- preprocess(consump.gas[,-32], tj=T) # without 2020

consump.renew.1.p <- preprocess(consump.renew.1[,-32])
consump.renew.2.p <- preprocess(consump.renew.2[,-32])
consump.renew.3.p <- preprocess(consump.renew.3[,-32])
consump.renew.4.p <- preprocess(consump.renew.4[,-32])
consump.renew.5.p <- preprocess(consump.renew.5[,-32])

consump.renew.p <- consump.renew.1.p # Sum of all renewable energies
consump.renew.p[-1,] <- consump.renew.p[-1,] + consump.renew.2.p[-1,] + consump.renew.3.p[-1,] +consump.renew.4.p[-1,] + consump.renew.5.p[-1,]


prod.by.fuel.total.p = preprocess(prod.by.fuel.total)
prod.by.fuel.comb.p = preprocess(prod.by.fuel.comb)
prod.by.fuel.nuclear.p = preprocess(prod.by.fuel.nuclear)

prod.by.fuel.renew = prod.by.fuel.total.p
prod.by.fuel.renew[-1,] = prod.by.fuel.renew[-1,] - prod.by.fuel.comb.p[-1,] - prod.by.fuel.nuclear.p[-1,] #renewable electricity capacity (MegaWatt)

colnames(prod.by.fuel.total.p)= prod.by.fuel.total.p[1,]
prod.by.fuel.total.p=prod.by.fuel.total.p[-1,]

colnames(prod.by.fuel.comb.p)= prod.by.fuel.comb.p[1,]
prod.by.fuel.comb.p=prod.by.fuel.comb.p[-1,]

colnames(prod.by.fuel.renew)= prod.by.fuel.renew[1,]
prod.by.fuel.renew=prod.by.fuel.renew[-1,]

```


To visualize the obtained data, we can plot European renewable and non renewable consumption levels:

```{r}
r_europe <- ggplot(data=as.data.frame(t(consump.renew.p)), aes(x=year, y=European_Union)) +
            labs(title="Renewable Energies Consumption Progression - European Union", 
                 subtitle="Inland Consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="blue", colour="darkblue", size=1)
r_europe
```

```{r}
# Example of European consumption of solid fossil fuels
f_europe <- ggplot(data=as.data.frame(t(consump.fossils.p)), aes(x=year, y=European_Union)) +
            labs(title="Consumption Solid Fossil Fuels - European Union", 
                 subtitle="Inland consumption") +
            xlab("Year") + ylab("Terajoules") +
            geom_point() +
            geom_smooth(method="loess", formula=y~x, fill="red", colour="darkred", size=1)
f_europe

```

We will also create some auxiliary variables & datasets, so it is easier to follow what we are doing. 
```{r}
year.min       <- min(energy.balances.p[1,])
year.max       <- max(energy.balances.p[1,])
year.grid      <- seq(year.min, year.max)

countries.list <- rownames(consump.fossils.p[-c(1,2,3,4),])

# Construct datasets with and without total European values 
energy.balances.countries  <- energy.balances.p[-c(1,2,3,4),]
consump.fossils.countries  <- consump.fossils.p[-c(1,2,3,4),]
consump.oil.petr.countries <- consump.oil.petr.p[-c(1,2,3,4),]
consump.gas.countries      <- consump.gas.p[-c(1,2,3,4),]
consump.renew.countries    <- consump.renew.p[-c(1,2,3,4),]

consump.oil.petr.europe <- consump.oil.petr.p[3,]
consump.gas.europe <- consump.gas.p[3,]
consump.fossils.europe <- consump.fossils.p[3,]
consump.renew.europe <- consump.renew.p[3,]

colnames(energy.balances.countries)=year.grid
colnames(consump.fossils.countries)=year.grid
colnames(consump.oil.petr.countries)=year.grid
colnames(consump.gas.countries)=year.grid
colnames(consump.renew.countries)=year.grid
```

Since we are working with time series, by their nature data are yearly correlated.
To deal with this problem, let's construct year to year variations datasets that will be useful later on:
```{r}
energy.balances.diff <- energy.balances.p[-1,-1] - energy.balances.p[-1,-length(energy.balances.p)]
consump.fossils.diff <- consump.fossils.p[-1,-1] - consump.fossils.p[-1,-length(consump.fossils.p)]
consump.oil.petr.diff <- consump.oil.petr.p[-1,-1] - consump.oil.petr.p[-1,-length(consump.oil.petr.p)]
consump.gas.diff <- consump.gas.p[-1,-1] - consump.gas.p[-1,-length(consump.gas.p)]
consump.renew.diff <- consump.renew.p[-1,-1] - consump.renew.p[-1,-length(consump.renew.p)]

energy.balances.diff <- rbind(year=seq(1991, 2019), energy.balances.diff)
consump.fossils.diff <- rbind(year=seq(1991, 2019), consump.fossils.diff)
consump.oil.petr.diff <- rbind(year=seq(1991, 2019), consump.oil.petr.diff)
consump.gas.diff <- rbind(year=seq(1991, 2019), consump.gas.diff)
consump.renew.diff <- rbind(year=seq(1991, 2019), consump.renew.diff)
```


# Starting Point: Analysis of current European Renewable Transition

To properly deal with our objective we thought it was important to analyze, as a starting point, the current European situation and in particular its “Green Transition”.  Since to do so we should take into account several indicators, we set this analysis in 3 important consequent steps, in a way to look at the European green transition from 3 main different perspectives.

## First target: investigate how renewable and non-renewable consumptions are evolving.


Let's have a first look at the consumption levels of all EU countries.

Via time series visualization of :
```{r}
#matplot(seq(year.min, year.max), t(energy.balances.countries), type="l", lty=1,
        #main="Energy Balances EU 1990 - 2019", xlab="Year", ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.fossils.countries), type="l", lty=1,
        main="Consumption of Solid Fossil Fuels EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.oil.petr.countries), type="l", lty=1,
        main="Consumption of Oil and Petroleum EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.gas.countries), type="l", lty=1,
        main="Consumption of Natural Gas EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")

matplot(seq(year.min, year.max), t(consump.renew.countries), type="l", lty=1,
        main="Consumption of Renewables EU 1990 - 2019", xlab="Year",
        ylab="Terajoules")
```

First let us check for normality with a simple Shapiro-Wilk test, to justify the importance of using nonparametric tools.

We check the distribution of p-values obtained with a Shapiro-Wilk test:
```{r}

p.values.ff <- numeric(length(countries.list)) # Fossil fuels
p.values.op <- numeric(length(countries.list)) # Oil&Petr.
p.values.ng <- numeric(length(countries.list)) # Natural gas 
p.values.re <- numeric(length(countries.list)) # RE

for(c in 1:length(countries.list)){
  
  if (identical(diff(as.numeric(t(consump.fossils.diff[-c(1,2,3,4),])[,c])),rep(0,length(as.numeric(t(consump.fossils.diff[-c(1,2,3,4),])[,c]))-1)))  #we check that values are not all equal, if it happens we put a simbolic value in the vector of p-values.
    
  {p.values.ff[c]=2 }#simbolic value
  else{
    p.values.ff[c] <- shapiro.test(t(consump.fossils.diff[-c(1,2,3,4),])[,c])$p.value
  }
  
  if(identical(diff(as.numeric(t(consump.oil.petr.diff[-c(1,2,3,4),])[,c])),rep(0,length(as.numeric(t(consump.oil.petr.diff[-c(1,2,3,4),])[,c]))-1)))
    
  {p.values.op[c]=2}
  else{
    p.values.op[c] <- shapiro.test(t(consump.oil.petr.diff[-c(1,2,3,4),])[,c])$p.value
  }
  
  if(identical(diff(as.numeric(t(consump.gas.diff[-c(1,2,3,4),])[,c])),rep(0,length(as.numeric(t(consump.gas.diff[-c(1,2,3,4),])[,c]))-1))) 
    
  {p.values.ng[c]=2}
  else{
    p.values.ng[c] <- shapiro.test(t(consump.gas.diff[-c(1,2,3,4),])[,c])$p.value
  }
  
  if(identical(diff(as.numeric(t(consump.renew.diff[-c(1,2,3,4),])[,c])),rep(0,length(as.numeric(t(consump.renew.diff[-c(1,2,3,4),])[,c]))-1)))
    
  {p.values.re[c]=2}
  else{
    p.values.re[c] <- shapiro.test(t(consump.renew.diff[-c(1,2,3,4),])[,c])$p.value
  }
}
hist(p.values.ff,breaks=20)
hist(p.values.op,breaks=20)
hist(p.values.ng,breaks=20)
hist(p.values.re,breaks=20)
```

### Permutational Multivariate tests - Comparing Consumption distributions

We want to compare the distributions of Non Renewable vs Renewable fuels for each country:
```{r}
consump.fossils.mean <- colMeans(consump.fossils.countries, na.rm=T)
consump.oil.petr.mean <- colMeans(consump.oil.petr.countries, na.rm=T)
consump.gas.mean <- colMeans(consump.gas.countries, na.rm=T)
consump.renew.mean <- colMeans(consump.renew.countries, na.rm=T)

matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean,
                                       consump.renew.mean)),
        type="l",main="Consumption means for each type of fuel",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(consump.fossils.mean)[2]+300000),lwd=2)

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas","Renewable Energies"), col=1:4, pch=2)


```

Plot of only non-renewables
```{r}
matplot(seq(year.min, year.max), t(rbind(consump.fossils.mean,
                                       consump.oil.petr.mean,
                                       consump.gas.mean)),
        type="l",main="Consumption means for each type of non renewable fuel",xlab="Years",ylab="Terajoules",lwd=2,
        ylim=c(min(consump.fossils.mean)-30000,max(consump.fossils.mean)+30000))

legend("topright", legend =c("Fossil Fuels","Oil and Petroleum","Natural Gas"), col=1:3, pch=2)
```

We start with a permutational MANOVA to see whether the three non renewable sources have the same distribution

```{r}

consump.nonrenew.countries=rbind(consump.oil.petr.p[5:39,],
                                 consump.fossils.p[5:39,],consump.gas.p[5:39,])

nonrenew.source <- c(rep("Oil_Petr",35),rep("Fossil_Fuels",35),rep("Natural_Gas",35))
nonrenew.source <- factor(nonrenew.source)
```



```{r}
fit <- manova(as.matrix(consump.nonrenew.countries) ~ nonrenew.source)
print(summary.manova(fit,test="Wilks")) 
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
```


```{r}
set.seed(seed)
T_stat <- numeric(B)
n=dim(consump.nonrenew.countries)[1]

for(perm in 1:B){
  # choose random permutation
  permutation <- sample(1:n)
  source.perm <- nonrenew.source[permutation]
  fit.perm <- manova(as.matrix(consump.nonrenew.countries) ~ source.perm)
  T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="Wilks stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-2,1),main="Wilk stat ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```

We reject the null hypothesis so we can state that at least one of them has a different distribution from the others.


To investigate whether the difference was in their means we proceeded with 3 coupled permutational tests using the squared Euclidean distance (i.e. sum of squared differences) between the two sample mean vectors

Non-renewables coupled permutational tests:
```{r}

# H0: Distributions are equal
# H1: Distributions are not equal

# Natural Gas vs Oil&Petroleum ----------------------------------------------------------------

n1 <- dim(consump.gas.countries)[1]
n2 <- dim(consump.oil.petr.countries)[1]
n  <- n1 + n2

# Test statistic
T10 <- as.numeric((consump.gas.mean-consump.oil.petr.mean) %*% (consump.gas.mean-consump.oil.petr.mean))
T10

# Permutational distribution
T1 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)

t_pooled = rbind(consump.gas.countries, consump.oil.petr.countries)
for(perm in 1:B){
    
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm)#, na.rm = T)
    t2.mean_perm = colMeans(t2_perm)#, na.rm = T)
    T1[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T1,xlim=range(c(T1,T10)),main="Test statistic permutational distribution")
abline(v=T10,col=3,lwd=4)

plot(ecdf(T1),main="Test statistic permutational ecdf")
abline(v=T10,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T1>=T10)/B
p_val

```

```{r}

# Fossil Fuels vs Oil&Petroleum ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.fossils.countries))[1]
n2 <- dim(as.matrix(consump.oil.petr.countries))[1]
n  <- n1 + n2

# Test statistic
T20 <- as.numeric((consump.fossils.mean-consump.oil.petr.mean) %*% (consump.fossils.mean-consump.oil.petr.mean))
T20

# Permutational distribution
T2 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)

t_pooled = rbind(consump.fossils.countries, consump.oil.petr.countries)

for(perm in 1:B){
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm)
    t2.mean_perm = colMeans(t2_perm)
    T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T2,xlim=range(c(T2,T20)),main="Test statistic permutational distribution")
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2),main="Test statistic permutational ecdf")
abline(v=T20,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T2>=T20)/B
p_val

```


```{r}

# Natural Gas vs Fossil Fuels ----------------------------------------------------------------

n1 <- dim(as.matrix(consump.fossils.countries))[1]
n2 <- dim(as.matrix(consump.gas.countries))[1]
n  <- n1 + n2

# Test statistic
T20 <- as.numeric((consump.fossils.mean-consump.gas.mean) %*% (consump.fossils.mean-consump.gas.mean))
T20

# Permutational distribution
T2 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)

t_pooled = rbind(consump.fossils.countries, consump.gas.countries)

for(perm in 1:B){
    permutation = sample(n)
    t_perm = t_pooled[permutation,]
    t1_perm = t_perm[1:n1,]
    t2_perm = t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm = colMeans(t1_perm)
    t2.mean_perm = colMeans(t2_perm)
    T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T2,xlim=range(c(T2,T20)),main="Test statistic permutational distribution")
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2),main="Test statistic permutational ecdf")
abline(v=T20,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T2>=T20)/B
p_val

```

We never reject the null hypothesis so we can assume that in average the three non-renewable sources are decreasing at the same rate.

This result gave us the possibility to compare renewable energies with the average of non-renewable ones. 

In particular we wanted to know if the renewable consumptions are increasing as fast as the non-renewable consumptions are decreasing.
To do so we performed a permutational test using the same statistics as before so considering the distance between the means of year to year variations of consumptions, so we made a test over the first derivatives.

In particular we changed sign of non-renewable year to year differences to proceed comparing if the two curves are moving at the same rate.
```{r}

# Renewables vs Non-Renewables ----------------------------------------------------------------
# Use year by year variations of each energy

mean.consump.nonrenew <-(consump.fossils.countries+consump.gas.countries+consump.oil.petr.countries )/3
mean.consump.nonrenew.mean=colMeans(mean.consump.nonrenew)

matplot(seq(year.min, year.max), t(rbind(mean.consump.nonrenew.mean,
                                         consump.renew.mean)),
        type="l",main="Consumption means renewables vs non-renewables",xlab="Years",ylab="Terajoules",
        ylim=c(0,range(mean.consump.nonrenew.mean)[2]+300000),col=c(1,3),lty=c(1,1),lwd=2)
legend("topright",legend=c("Non-renewable sources","Renewable sources"),col=c(1,3),pch=2)


mean.consump.nonrenew.diff <- mean.consump.nonrenew[,-length(mean.consump.nonrenew)] - mean.consump.nonrenew[,-1] #"inverse" deltas for non renewables to obtain growing curve differences

consump.renew.diff <- consump.renew.countries[,-1] - consump.renew.countries[,-length(consump.renew.countries)]

mean.consump.nonrenew.diff.mean <- colMeans(mean.consump.nonrenew.diff, na.rm=T)
consump.renew.diff.mean <- colMeans(consump.renew.diff, na.rm=T)

matplot(seq(year.min+1,year.max), consump.renew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Renewable consumptions year to year average deltas",col="green",lwd=2,ylim=c(-40000,100000))
matlines(seq(year.min+1,year.max), mean.consump.nonrenew.diff.mean,type="l",ylab="Terajoules",xlab="Years",
        main="Mean non-renewable consumptions year to year inverse average deltas",lwd=2)
legend("topright",legend=c("Non-renewable sources","Renewable sources"),col=c(1,3),pch=2)


n1 <- dim(as.matrix(consump.renew.diff))[1]
n2 <- dim(as.matrix(mean.consump.nonrenew.diff))[1]
n  <- n1 + n2

# Test statistic
T30 <- as.numeric((consump.renew.diff.mean-mean.consump.nonrenew.diff.mean) %*% (consump.renew.diff.mean-mean.consump.nonrenew.diff.mean))
T30

# Permutational distribution
T3 <- numeric(B)
set.seed(seed)
pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)

pb$tick(0)

t_pooled <- cbind(consump.renew.diff,mean.consump.nonrenew.diff)

for(perm in 1:B){
    permutation <- sample(n)
    t_perm <- t_pooled[permutation,]
    t1_perm <- t_perm[1:n1,]
    t2_perm <- t_perm[(n1+1):n,]
    
    # Evaluation of the test statistic on permuted data
    t1.mean_perm <- colMeans(t1_perm, na.rm = T)
    t2.mean_perm <- colMeans(t2_perm, na.rm = T)
    T3[perm]  <- (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
    
    pb$tick()
    
}

# Graphics for the permutational distribution
hist(T3,xlim=range(c(T3,T30)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T30,col=3,lwd=4)

plot(ecdf(T3),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T30,col=3,lwd=4)

# Calculate p-value
p_val <- sum(T3>=T30)/B
p_val

```

Since we do not reject the null hypothesis of same growth rate we can effectively conclude that, in average, the renewable consumptions are increasing as fast as the non-renewable consumptions are decreasing.

## Second Target: Investigate how electricity production coming from renewable sources is growing

Let's visualize the total electricity production trend by country

```{r}
tot_elec <- read.xlsx('data/total_electricity_use.xlsx')
# View(tot_elec)
tot_elec = preprocess(tot_elec)

colnames(tot_elec) <- tot_elec[1,] #use years as columns names
tot_elec <- tot_elec[-1,] #first row is now useless
tot_elec <- tot_elec[,-17] #don't consider 2020

matplot(colnames(tot_elec),t(tot_elec[4:39,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Total electricity production by country")
```

Let's visualize the production of electricity from renewables trend by country

```{r}
use_renew_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=1)
# View(use_renew_elec)
use_renew_elec = preprocess(use_renew_elec)

colnames(use_renew_elec) <- use_renew_elec[1,] #use years as columns names
use_renew_elec <- use_renew_elec[-1,] #first row now is useless


use_renew_elec <- use_renew_elec[!is.na(use_renew_elec[,16]),]
# View(use_renew_elec)



matplot(colnames(use_renew_elec),t(use_renew_elec[4:40,]),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from renewables by country")

```

Let's see, out of curiosity, which country is particularly above the others in total usage of renewables for electricity production

```{r}
rownames(use_renew_elec)[which.max(use_renew_elec[4:40,16])+3] #first three rows are total european statistics
```

Let's construct a dataset with percentage of electricity coming from renewables to visualize its evolution at a European level
```{r}
elec_percentage <- tot_elec

for (j in 1:16){
  elec_percentage[,j] <- use_renew_elec[-34,j]/elec_percentage[,j]
  #34th row is Montenegro, which didn't survive preprocessing in the total electricity production dataset
}
# View(elec_percentage)

years_04_19 <- as.numeric(colnames(elec_percentage))
plot(years_04_19,as.numeric(elec_percentage[2,]),main="Percentage of electricity coming from renewable sources - EU",xlab="Year",ylab="Percentage",type="l")
points(years_04_19,as.numeric(elec_percentage[2,]),col="Green",lwd=3)
```

Fortunately it is clearly ramping up!

### MANOVA to compare the distributions from the three main types of Renewables for electricity consumption

We proceeded with a manova test, to investigate if the increase of electricity production coming from the three main renewable sources (Hydro, Wind, Solar) has the same distribution.

Getting and preprocessing electricity data
```{r}
use_hydro_elec <-read.xlsx('data/use_renew_elec.xlsx',sheet=2)
use_wind_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=4)
use_solar_elec <- read.xlsx('data/use_renew_elec.xlsx',sheet=6)

#clean hydro
use_hydro_elec=preprocess(use_hydro_elec)

colnames(use_hydro_elec) <- use_hydro_elec[1,]
use_hydro_elec <- use_hydro_elec[-1,]

use_hydro_elec <- use_hydro_elec[!is.na(use_hydro_elec[,16]),]

#clean wind
use_wind_elec=preprocess(use_wind_elec)

colnames(use_wind_elec) <- use_wind_elec[1,]
use_wind_elec <- use_wind_elec[-1,]

use_wind_elec <- use_wind_elec[!is.na(use_wind_elec[,16]),]

#clean solar
use_solar_elec=preprocess(use_solar_elec)

colnames(use_solar_elec) <- use_solar_elec[1,]
use_solar_elec <- use_solar_elec[-1,]

use_solar_elec <- use_solar_elec[!is.na(use_solar_elec[,16]),]

use_hydro_elec[] <- lapply(use_hydro_elec, as.numeric)
use_wind_elec[] <- lapply(use_wind_elec, as.numeric)
use_solar_elec[] <- lapply(use_solar_elec, as.numeric)


use_principal <- rbind(use_hydro_elec[4:40,],use_wind_elec[4:40,],use_solar_elec[4:40,])

#factor vector
source <- c(rep("Hydro",37),rep("Wind",37),rep("Solar",37))
source <- factor(source)
```

Let's obtain year to year differences from these datasets, as done before:

```{r}

tot_elec.diff        <- tot_elec[,-1] - tot_elec[,-length(tot_elec)]
colnames(tot_elec.diff) <- seq(2005,2019)

use_renew_elec.diff  <- use_renew_elec[,-1] - use_renew_elec[,-length(use_renew_elec)] 
colnames(use_renew_elec.diff) <- seq(2005,2019)

elec_percentage.diff <- elec_percentage[,-1] - elec_percentage[,-length(elec_percentage)]
colnames(elec_percentage.diff) <- seq(2005,2019)

use_hydro_elec.diff  <- use_hydro_elec[,-1] - use_hydro_elec[,-length(use_hydro_elec)]
use_solar_elec.diff  <- use_solar_elec[,-1] - use_solar_elec[,-length(use_solar_elec)]
use_wind_elec.diff   <- use_wind_elec[,-1] - use_wind_elec[,-length(use_wind_elec)]
colnames(use_hydro_elec.diff) <- seq(2005,2019)
colnames(use_solar_elec.diff) <- seq(2005,2019)
colnames(use_wind_elec.diff) <- seq(2005,2019)

use_principal.diff   <- rbind(use_hydro_elec.diff[4:40,], use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])     
colnames(use_principal.diff) <- seq(2005,2019)


```

Plot electricity trends

```{r}
matplot(colnames(use_principal),t(use_principal),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from Hydro-Wind-Solar",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```

```{r}
matplot(colnames(use_principal.diff),t(use_principal.diff),type='l',xlab="Year",ylab="Gigawatt-hour",main="Electricity from Hydro-Wind-Solar, year to year variations",col=source)
legend("topleft",legend=levels(source),col=c(1,2,3),pch=1)
```


Seems like Hydro is uniformly more used than the other two.
Seems like Hydro has less variations than the other two, let's proceed to statistically test this fact.

Observed statistic:
```{r}
fit <- manova(as.matrix(use_principal.diff) ~ source)
print(summary.manova(fit,test="Wilks")) 
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
```

Run the test

```{r}
set.seed(seed)
T_stat <- numeric(B)
n=dim(use_principal.diff)[1]

for(perm in 1:B){
  # choose random permutation
  permutation <- sample(1:n)
  source.perm <- source[permutation]
  fit.perm <- manova(as.matrix(use_principal.diff) ~ source.perm)
  T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="Wilks stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-2,1),main="Wilk stat ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
p_val <- sum(T_stat>=T0)/B
p_val
```

So here we have statistical evidence to say that at least one of the renewable electricity sources has different growth distribution from the others. 

As observed before, Hydro seems to be the principal source of renewable electricity and the one with less variations, so we proceeded investigating if the two other sources (Wind and Solar) are in average developing at the same rate.
```{r}
wind.mean = colMeans(use_wind_elec.diff[4:40,])
solar.mean = colMeans(use_solar_elec.diff[4:40,])
years_04_19=as.numeric(colnames(use_wind_elec)) #years from 2004 to 2019
years_05_19=years_04_19[-1]

matplot(years_05_19,t(rbind(wind.mean,solar.mean)), type='l', col=c("green","red"), lty=1,xlab="Year",ylab="Gigawatt-hour",main="Mean yearly variations of electricity production")
legend("topleft",legend=c("Wind","Solar"),col=c(3,2),pch=1)
```

Two populations permutational test
```{r}
n1 = n2=dim(use_wind_elec.diff[4:40,])[1]
n  = n1 + n2

T20 = as.numeric((wind.mean-solar.mean) %*% (wind.mean-solar.mean))
T20

# Estimating the permutational distribution under H0

T2 = numeric(B)
set.seed(seed)
t_pooled = rbind(use_wind_elec.diff[4:40,],use_solar_elec.diff[4:40,])

for(perm in 1:B){
  # Random permutation of indexes
  permutation = sample(n)
  t_perm = t_pooled[permutation,]
  t1_perm = t_perm[1:n1,]
  t2_perm = t_perm[(n1+1):n,]
  
  # Evaluation of the test statistic on permuted data
  t1.mean_perm = colMeans(t1_perm)
  t2.mean_perm = colMeans(t2_perm)
  T2[perm]  = (t1.mean_perm-t2.mean_perm) %*% (t1.mean_perm-t2.mean_perm) 
}

hist(T2,xlim=range(c(T2,T20)),main="Squared L2 norm of means difference - permutational distribution")
abline(v=T20,col=3,lwd=4)

plot(ecdf(T2),main="Squared L2 norm of means difference - permutational ecdf")
abline(v=T20,col=3,lwd=4)

pvalue=sum(T2>=T20)/B
pvalue
```

In the end we have no statistical evidence to state that the two growth distribution are different.

### Regression on types of Renewables for electricity production 

To understand how Hydro, Wind and Solar sources of electricity are growing with time we proceeded with some regression of the amount of electricity coming from each of them, in function of Gdp, population and their interaction. 
    
For this purpose, we will first have to import the SSP data from our datasets, which was obtained by retrieving the year to year values from the original data (more details in "src/preprocessing_SSP.Rmd").

We also construct variations datasets that will prove to be useful in the near future.

```{r}
gdp <- read.xlsx("data/ssp_iiasa_YtY_gdp.xlsx", 1)
pop <- read.xlsx("data/ssp_iiasa_YtY_pop.xlsx", 1)

gdp.diff <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop.diff <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

rownames(gdp.diff) <- gdp$Country.Name
rownames(pop.diff) <- pop$Country.Name

gdp.diff <- gdp.diff[,-1] - gdp.diff[,-length(gdp.diff)]
pop.diff <- pop.diff[,-1] - pop.diff[,-length(pop.diff)]
years_90_40=colnames(pop)[-c(1,2,3,4)]

colnames(gdp.diff) <- years_90_40[-1]
colnames(pop.diff) <- years_90_40[-1]

gdp <- data.frame(lapply(gdp[,-c(1,2,3,4)],as.numeric))
pop <- data.frame(lapply(pop[,-c(1,2,3,4)],as.numeric))

colnames(gdp) <- years_90_40
colnames(pop) <- years_90_40

rownames(gdp) <- rownames(gdp.diff)
rownames(pop) <- rownames(pop.diff)
```

```{r}
gdp[is.na(gdp)] <- 0 #replace NA with 0
gdp.diff[is.na(gdp.diff)] <- 0 
```

In particular we decided to work with total EU values.

EU totals - original data
For the moment we are trying to make regression for the three renewable electricity sources with original data.
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp)
discard.pop.idx <- rownames(pop)%in%rownames(gdp)

# Take EU totals 
use_solar_elec.total <- use_solar_elec[2,]
use_wind_elec.total <- use_wind_elec[2,]
use_hydro_elec.total <- use_hydro_elec[2,]

pop <- pop[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp)%in%rownames(use_solar_elec[-c(1,2,3),])
discard.pop.idx <- rownames(pop)%in%rownames(use_solar_elec[-c(1,2,3),])

gdp <- gdp[discard.gdp.idx,]
pop <- pop[discard.pop.idx,]


rn <- rownames(gdp)
gdp <- gdp[rn,]
pop <- pop[rn,]

gdp.total <- as.numeric(colSums(gdp))
pop.total <- as.numeric(colSums(pop))
```

Montenegro and Albania should be discarded as they have NaN values or no information available for either population or GDP (see "preprocessing_SSP.Rmd"). Kosovo should be discarded as it is not recognized by the SSP predictions.


Since we have data only from 2004 (instead of 1990) to 2019, more points are needed to construct regression models. We generate these points through a smoothing procedure, obtaining semestral data.


Smoothing for solar, wind and hydro to obtain data for each semester (total values)
```{r}
use_solar_elec.total.s <- smoothing_procedure(use_solar_elec.total, 2004, 2019, interval=2, row_names = rownames(use_solar_elec.total))
use_wind_elec.total.s <- smoothing_procedure(use_wind_elec.total, 2004, 2019, interval=2, row_names = rownames(use_wind_elec.total))
use_hydro_elec.total.s <- smoothing_procedure(use_hydro_elec.total, 2004, 2019, interval=2, row_names = rownames(use_hydro_elec.total))
```



```{r}
gdp.elec.train <- gdp[,as.character(seq(2004,2019))]
pop.elec.train <- pop[,as.character(seq(2004,2019))]
gdp.elec.train = colSums(gdp.elec.train)
pop.elec.train = colSums(pop.elec.train)
```


Smoothing on Gdp and Population (total values)
```{r}

gdp.elec.train.s <- smoothing_procedure(t(data.frame(gdp.elec.train)), 2004, 2019, interval=2)
pop.elec.train.s <- smoothing_procedure(t(data.frame(pop.elec.train)), 2004, 2019, interval=2)


```


```{r}
#vectors for EU total data
vec_train = cbind(as.numeric(gdp.elec.train.s), as.numeric(pop.elec.train.s))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")


vec_train
```

We first tried to construct models using original data and checked the correlation of the residuals using the (partial) autocorrelation function, obtaining as we will see high correlation values.


Let's find the adequate models to use for our regression

#### Wind model - original data
```{r}
tr_data=data.frame(t(use_wind_elec.total.s),vec_train)
colnames(tr_data)[1]="European_Union"
with(tr_data,plot(gdp,European_Union,main="Wind electricity vs gdp"))
with(tr_data,plot(pop,European_Union,main="Wind electricity vs pop"))
```


```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
Acf(model_gam$residuals)
```


```{r}
Pacf(model_gam$residuals)
```

#### Solar model - original data
```{r}
tr_data=data.frame(t(use_solar_elec.total.s),vec_train)

with(tr_data,plot(gdp,European_Union,main="Solar electricity vs gdp"))
with(tr_data,plot(pop,European_Union,main="Solar electricity vs pop"))

```

```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's see with a permutational anova if the interaction term is significant (residuals are not gaussian)
```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][3,4]

aov.H0= aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr') +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][3,4] 
pb$tick
}
sum(T_perm>= T0)/B


```

So we cannot drop the interaction term, let's try to quit the gdp
```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][1,4]

aov.H0= aov(gam(European_Union ~ s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)

for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr') +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][1,4] 
pb$tick
}
sum(T_perm>= T0)/B
```

Let's instead try to drop the population term
```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][2,4]

aov.H0= aov(gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)

for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr') +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][2,4] 
pb$tick
}
sum(T_perm>= T0)/B
```

We can drop it

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

```{r}
Acf(model_gam$residuals)

```

```{r}
Pacf(model_gam$residuals)
```


#### Hydro model - original data
```{r}
tr_data=data.frame(t(use_hydro_elec.total.s),vec_train)

with(tr_data,plot(gdp,European_Union,main="Hydro electricity vs gdp"))
with(tr_data,plot(pop,European_Union,main="Hydro electricity vs pop"))

```


```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```
Let's see if the interaction term is significant (residuals are gaussian)

```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)
anova(model_gam_reduced,model_gam,test="F")
```

We can quit the interaction term

```{r}
model_gam=model_gam_reduced

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

We should also try to quit population (residuals are gaussian)

```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') ,data=tr_data)
anova(model_gam_reduced,model_gam,test="F")
```

Seems like population is significant after all...

```{r}
Acf(model_gam$residuals)
```


```{r}
Pacf(model_gam$residuals)
```


Differences are much needed...

Since working with original data gave us residuals with high correlations, we had to change strategy in order to tackle this problem: we looked for models to derive the year-to-year variations of each electricity source in function of GDP and population year-to-year variations and their interactions. 
Each time we search for the best GAM model by looking at the significance of the covariates and the adjusted R squared.

#### First order differences dataframes
```{r}
# Not in SSP GDP data and in electricity data
discard.idx <- rownames(use_solar_elec[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# We discard the countries which are not going to be used 
use_solar_elec.diff.c <- use_solar_elec.diff[c(F,F,F,discard.idx),]
use_wind_elec.diff.c <- use_wind_elec.diff[c(F,F,F,discard.idx),]
use_hydro_elec.diff.c <- use_hydro_elec.diff[c(F,F,F,discard.idx),]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in electricity data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(use_solar_elec.diff.c)
discard.pop.idx <- rownames(pop.diff)%in%rownames(use_solar_elec.diff.c)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]


rn <- rownames(gdp.diff)
gdp.diff <- gdp.diff[rn,]
pop.diff <- pop.diff[rn,]

use_solar_elec.diff.c <- use_solar_elec.diff.c[rn,]
use_wind_elec.diff.c <- use_wind_elec.diff.c[rn,]
use_hydro_elec.diff.c <- use_hydro_elec.diff.c[rn,]

```


Smoothing for solar, wind and hydro to obtain semestral data (yearly variations)
```{r}
use_solar_elec.diff.s <- smoothing_procedure(use_solar_elec.diff.c, 2005, 2019, interval=2, row_names = rownames(use_solar_elec.diff.c))
use_wind_elec.diff.s <- smoothing_procedure(use_wind_elec.diff.c, 2005, 2019, interval=2, row_names = rownames(use_wind_elec.diff.c))
use_hydro_elec.diff.s <- smoothing_procedure(use_hydro_elec.diff.c, 2005, 2019, interval=2, row_names = rownames(use_hydro_elec.diff.c))
```

```{r}
#obtaining EU values
gdp.diff.total=t(data.frame(colSums(gdp.diff)))
pop.diff.total=t(data.frame(colSums(pop.diff)))

use_solar_elec.diff.total=t(data.frame(colSums(use_solar_elec.diff.c)))
use_wind_elec.diff.total=t(data.frame(colSums(use_wind_elec.diff.c)))
use_hydro_elec.diff.total=t(data.frame(colSums(use_hydro_elec.diff.c)))

use_solar_elec.diff.total.s=t(data.frame(colSums(use_solar_elec.diff.s)))
use_wind_elec.diff.total.s=t(data.frame(colSums(use_wind_elec.diff.s)))
use_hydro_elec.diff.total.s=t(data.frame(colSums(use_hydro_elec.diff.s)))

```


```{r}
gdp.elec.diff.train <- gdp.diff.total[,as.character(seq(2005,2019))]
pop.elec.diff.train <- pop.diff.total[,as.character(seq(2005,2019))]
```

```{r}
gdp.elec.diff.train.s <- smoothing_procedure(t(data.frame(gdp.elec.diff.train)), 2005, 2019, interval=2)
pop.elec.diff.train.s <- smoothing_procedure(t(data.frame(pop.elec.diff.train)), 2005, 2019, interval=2)

```


```{r}
#vectors for EU yearly variations
vec_train = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_train
```

#### Wind model - First order differences

```{r}
tr_data=data.frame(t(use_wind_elec.diff.total.s),vec_train)
colnames(tr_data)[1]="European_Union"

with(tr_data,plot(gdp,European_Union,main="Wind diff electricity vs diff gdp"))
with(tr_data,plot(pop,European_Union,main="Wind diff electricity vs diff pop"))

```

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's try quitting one covariate at a time. We start quitting the interaction term (gaussian residuals)
```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```

Let's put back the interaction term and quit gdp

```{r}
model_gam_reduced=gam(European_Union ~ s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```

Let's put back gdp and quit population

```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")

```

Let's try quitting the smooth terms, one at a time. We exploit the lm command coupled with the bs generators to better investigate the adequate degree to use for the spline basis.

```{r}
#linear interaction
model_gam1=lm(European_Union ~ bs(gdp) + bs(pop) + gdp:pop,data=tr_data)

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```

```{r}
#linear pop
model_gam2=lm(European_Union ~ bs(gdp) + pop + bs(I(gdp*pop)),data=tr_data)

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```


```{r}
#linear gdp
model_gam3=lm(European_Union ~ gdp + bs(pop) + bs(I(gdp*pop)),data=tr_data)

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```


By looking at R squared and singular significance, the second one seems the best, let's go with it
```{r}
model_gam_wind=model_gam2

```


```{r}
Acf(model_gam_wind$residuals)
```

```{r}
Pacf(model_gam_wind$residuals)
```

Unfortunately there is again a bit of correlation at 2 steps but this could be due to the smoothing that we had to apply in order to construct the models (as mentioned before). Anyway it is clearly better than the corresponding best model constructed with original data.


#### Hydro model - First order differences

Let's go on constructing hydro model

```{r}
tr_data=data.frame(t(use_hydro_elec.diff.total.s),vec_train)
colnames(tr_data)[1]="European_Union"

with(tr_data,plot(gdp,European_Union,main="Hydro diff electricity vs diff gdp"))
with(tr_data,plot(pop,European_Union,main="Hydro diff electricity vs diff pop"))

```

```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's try quitting one covariate at a time (residuals are gaussian)

```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```

We cannot quit the interaction term

```{r}
model_gam_reduced=gam(European_Union ~ s(gdp,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```

We cannot quit the population term

```{r}
model_gam_reduced=gam(European_Union ~ s(pop,bs='cr') + s(I(gdp*pop),bs='cr') ,data=tr_data)

anova(model_gam_reduced,model_gam,test="F")

```

We cannot quit the gdp term

So,as before, let's try quitting the smooth terms, one at a time

```{r}
#linear interaction
model_gam1=lm(European_Union ~ bs(gdp) + bs(pop) + gdp:pop,data=tr_data)

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```

```{r}
#linear pop
model_gam2=lm(European_Union ~ bs(gdp) + pop + bs(I(gdp*pop)),data=tr_data)

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```


```{r}
#linear gdp
model_gam3=lm(European_Union ~ gdp + bs(pop) + bs(I(gdp*pop)),data=tr_data)

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

From the third one, let's try to quit the interaction term (residuals are gaussian)

```{r}
model_gam_reduced=lm(European_Union ~ gdp + bs(pop),data=tr_data)

anova(model_gam_reduced,model_gam3,test="F")
```
We can quit the interaction term

```{r}
model_gam3=model_gam_reduced

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```
Let's try quit the gdp (residuals are gaussian)

```{r}
model_gam_reduced=lm(European_Union ~ bs(pop),data=tr_data)

anova(model_gam_reduced,model_gam3,test="F")
```
We can quit gdp

```{r}
model_gam3=model_gam_reduced

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```
Let's get back to the complete model and now we try to quit two smooth terms at a time

```{r}
#linear pop and interaction
model_gam1=lm(European_Union ~ bs(gdp) + pop + gdp:pop,data=tr_data)

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```


```{r}
#linear gdp and interaction
model_gam2=lm(European_Union ~ gdp + bs(pop) + gdp:pop,data=tr_data)

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```

```{r}
#linear gdp and pop
model_gam3=lm(European_Union ~ gdp + pop + bs(I(gdp*pop)),data=tr_data)

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

From the third model we start quitting the interaction term (residuals are gaussian)

```{r}
model_gam_reduced=lm(European_Union ~ gdp + pop,data=tr_data)

anova(model_gam_reduced,model_gam3,test="F")
```

We can quit the interaction term

```{r}
model_gam3=model_gam_reduced

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

Let's try quitting gdp (residuals are gaussian)
```{r}
model_gam_reduced=lm(European_Union ~  pop,data=tr_data)

anova(model_gam_reduced,model_gam3,test="F")
```

We can quit gdp

```{r}
model_gam3=model_gam_reduced

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

Go back to the first model
```{r}
summary(model_gam1)
shapiro.test(model_gam1$residuals)
```

from this model let's try to quit the gdp (gaussian residuals)
```{r}
model_gam_reduced=lm(European_Union ~  pop + gdp:pop,data=tr_data)

anova(model_gam_reduced,model_gam1,test="F")
```

We can quit the gdp
```{r}
model_gam1=model_gam_reduced

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```

Let's try to quit the interaction (gaussian residuals)
```{r}
model_gam_reduced=lm(European_Union ~  pop,data=tr_data)

anova(model_gam_reduced,model_gam1,test="F")
```

We obtain the same result as before, so we should try with the second model
```{r}
summary(model_gam2)
shapiro.test(model_gam2$residuals)
```

Let's try to quit the interaction (gaussian residuals)
```{r}
model_gam_reduced=lm(European_Union ~ gdp + bs(pop),data=tr_data)

anova(model_gam_reduced,model_gam2,test="F")
```

We quit the interaction
```{r}
model_gam2=model_gam_reduced

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```

Try to quit gdp (gaussian residuals)
```{r}
model_gam_reduced=lm(European_Union ~  bs(pop),data=tr_data)

anova(model_gam_reduced,model_gam2,test="F")
```

We can quit it
```{r}
model_gam2=model_gam_reduced

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```

Since all the efforts using variations datasets did not produce a satisfying model, let's try to explain the differences of hydro usage with original data of EU gdp and population.


```{r}
#vectors for EU total data
vec_train = cbind(as.numeric(gdp.elec.train.s[,3:31]), as.numeric(pop.elec.train.s[,3:31]))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_train
```

```{r}
tr_data=data.frame(t(use_hydro_elec.diff.total.s),vec_train)
colnames(tr_data)[1]="European_Union"

with(tr_data,plot(gdp,European_Union,main="Hydro diff electricity vs gdp"))
with(tr_data,plot(pop,European_Union,main="Hydro diff electricity vs pop"))

```

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's try to quit the interaction (residuals are gaussian)
```{r}
model_gam_reduced=gam(European_Union ~  s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```

We cannot quit the interaction term, let's try with gdp
```{r}
model_gam_reduced=gam(European_Union ~  s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

anova(model_gam_reduced,model_gam,test="F")
```

We cannot quit gdp either, so we have our model

```{r}
Acf(model_gam$residuals)

```


```{r}
Pacf(model_gam$residuals)
```

```{r}
model_gam_hydro=model_gam
```


#### Solar model - First order differences

Let's go back to yearly variations datasets
```{r}
#vectors for EU yearly variations
vec_train = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train=data.frame(vec_train)
colnames(vec_train)=c("gdp","pop")

vec_train
```

```{r}
tr_data=data.frame(t(use_solar_elec.diff.total.s),vec_train)
colnames(tr_data)[1]="European_Union"

with(tr_data,plot(gdp,European_Union,main="Solar diff electricity vs diff gdp"))
with(tr_data,plot(pop,European_Union,main="Solar diff electricity vs diff pop"))

```

```{r}

model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + s(I(gdp*pop),bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Again, let's quit one covariate at a time (residuals are not gaussian)
```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr') + +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][3,4]

aov.H0= aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr') +s(I(gdp*pop),bs='cr'),data=tr_data)))[[1]][3,4] 
pb$tick
}
sum(T_perm>= T0)/B
```

We can quit the interaction term

```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's try to quit pop (residuals are not gaussians)

```{r}
T0 <- summary.aov(aov(gam(European_Union ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)))[[1]][2,4]

aov.H0= aov(gam(European_Union ~ s(gdp,bs='cr'),data=tr_data))
aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(tr_data)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp,bs='cr') + s(pop,bs='cr'),data=tr_data)))[[1]][2,4] 
pb$tick
}
sum(T_perm>= T0)/B
```


So we can quit pop too
```{r}
model_gam=gam(European_Union ~ s(gdp,bs='cr'),data=tr_data)

summary(model_gam)

hist(model_gam$residuals)
qqnorm(model_gam$residuals)
shapiro.test(model_gam$residuals)
```

Let's try to quit one smooth term at a time
```{r}
#linear interaction
model_gam1=lm(European_Union ~ bs(gdp) + bs(pop) + gdp:pop,data=tr_data)

summary(model_gam1)

hist(model_gam1$residuals)
qqnorm(model_gam1$residuals)
shapiro.test(model_gam1$residuals)
```

```{r}
#linear pop
model_gam2=lm(European_Union ~ bs(gdp) + pop + bs(I(gdp*pop)),data=tr_data)

summary(model_gam2)

hist(model_gam2$residuals)
qqnorm(model_gam2$residuals)
shapiro.test(model_gam2$residuals)
```

```{r}
#linear gdp
model_gam3=lm(European_Union ~ gdp + bs(pop) + bs(I(gdp*pop)),data=tr_data)

summary(model_gam3)

hist(model_gam3$residuals)
qqnorm(model_gam3$residuals)
shapiro.test(model_gam3$residuals)
```

Starting from the second, we could try to lower the degree of gdp spline (residuals are gaussian)

```{r}
model_gam_reduced=lm(European_Union ~ bs(gdp,degree=2) + pop+ bs(I(gdp*pop)),data=tr_data)

anova(model_gam_reduced,model_gam2,test="F")

```

So we cannot reduce the degree of gdp spline to degree 2
Let's try to lower the degree of the interaction term


```{r}
model_gam_reduced=lm(European_Union ~ bs(gdp) + pop+ bs(I(gdp*pop),degree=2),data=tr_data)

anova(model_gam_reduced,model_gam2,test="F")

```

We cannot reduce the interaction spline degree either, so we have our model

```{r}
Acf(model_gam2$residuals)

```


```{r}
Pacf(model_gam2$residuals)
```


High correlation in 1 step residuals but still better than using original values, so we stick with this model

```{r}
model_gam_solar=model_gam2
```

#### Little review of the selected models

1.	DIFF_EU_WIND ~ β0 + f(DIFF_EU _GDP) + DIFF_EU _POPULATION + f(DIFF_EU _GDP*DIFF_EU _POPULATION) +  ϵ

```{r}
summary(model_gam_wind)

```


2.	DIFF_EU _HYDRO ~ β0 + f(EU _GDP) + f(EU _POPULATION) + f(EU _GDP*EU _POPULATION)) + ϵ

```{r}
summary(model_gam_hydro)

```


3.	DIFF_EU _SOLAR ~ β0 + f(DIFF_EU _GDP) + DIFF_EU _POPULATION + f(DIFF_EU _GDP*DIFF_EU _POPULATION) +  ϵ

```{r}
summary(model_gam_solar)

```


#### Plots

Wind regression

```{r}
vec_train_wind = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train_wind=data.frame(vec_train_wind)
colnames(vec_train_wind)=c("gdp","pop")

gdp.grid=with(vec_train_wind,seq(min(gdp),max(gdp),length.out=100))
pop.grid=with(vec_train_wind,seq(min(pop),max(pop),length.out=100))
grid.wind=expand.grid(gdp.grid,pop.grid)
names(grid.wind)=c('gdp','pop')


preds_wind=predict(model_gam_wind,newdata=grid.wind)
persp3d(gdp.grid,pop.grid,preds_wind,col='green',border="white",lwd=0.1,xlab="gdp",ylab="pop",alpha=0.5)
with(vec_train_wind, points3d(gdp,pop,use_wind_elec.diff.total.s,col='black',size=10))
```


Wind yearly evolution
```{r}
plot(seq(2005,2019,0.5), use_wind_elec.diff.total.s,cex =.5,xlab="Year",ylab="Terajoules",col =" darkgrey ",main='Wind Diff Electricity Use')

lines(seq(2005,2019,0.5),model_gam_wind$fitted.values,lwd=2,col="green",lty=1)

```

Hydro regression
```{r}
vec_train_hydro = cbind(as.numeric(gdp.elec.train.s[,3:31]), as.numeric(pop.elec.train.s[,3:31]))
vec_train_hydro=data.frame(vec_train_hydro)
colnames(vec_train_hydro)=c("gdp","pop")

gdp.grid=with(vec_train_hydro,seq(min(gdp),max(gdp),length.out=100))
pop.grid=with(vec_train_hydro,seq(min(pop),max(pop),length.out=100))
grid.hydro=expand.grid(gdp.grid,pop.grid)
names(grid.hydro)=c('gdp','pop')


preds_hydro=predict(model_gam_hydro,newdata=grid.hydro)
persp3d(gdp.grid,pop.grid,preds_hydro,col='cyan1',border="black",lwd=0.3,xlab="gdp",ylab="pop",alpha=0.5)
with(vec_train_hydro, points3d(gdp,pop,use_hydro_elec.diff.total.s,col='black',size=10))
```

Hydro yearly evolution
```{r}
plot(seq(2005,2019,0.5), use_hydro_elec.diff.total.s,cex =.5,xlab="Year",ylab="Terajoules",col =" darkgrey ",main='Hydro Diff Electricity Use')

lines(seq(2005,2019,0.5),model_gam_hydro$fitted.values,lwd=2,col="cyan1",lty=1)
```

Solar regression
```{r}
vec_train_solar = cbind(as.numeric(gdp.elec.diff.train.s), as.numeric(pop.elec.diff.train.s))
vec_train_solar=data.frame(vec_train_solar)
colnames(vec_train_solar)=c("gdp","pop")

gdp.grid=with(vec_train_solar,seq(min(gdp),max(gdp),length.out=100))
pop.grid=with(vec_train_solar,seq(min(pop),max(pop),length.out=100))
grid.solar=expand.grid(gdp.grid,pop.grid)
names(grid.solar)=c('gdp','pop')


preds_solar=predict(model_gam_solar,newdata=grid.solar)
persp3d(gdp.grid,pop.grid,preds_solar,col='darkorange',border="black",lwd=0.3,xlab="gdp",ylab="pop",alpha=0.5)
with(vec_train_solar, points3d(gdp,pop,use_solar_elec.diff.total.s,col='black',size=10))
```

Solar yearly evolution
```{r}
plot(seq(2005,2019,0.5), use_solar_elec.diff.total.s,cex =.5,xlab="Year",ylab="Terajoules",col =" darkgrey ",main='Solar Diff Electricity Use')

lines(seq(2005,2019,0.5),model_gam_solar$fitted.values,lwd=2,col="darkorange",lty=1)
```


Let's see them altogether in one plot

```{r}
matplot(seq(2005,2019,0.5),model_gam_wind$fitted.values,type='l',lwd=2,col="green",main="Variations of electricity production coming from renewable sources",ylim=c(-500,40000),xlab="Years",ylab="Terajoules")
lines(seq(2005,2019,0.5),model_gam_hydro$fitted.values,lwd=2,col="cyan1",lty=1)
lines(seq(2005,2019,0.5),model_gam_solar$fitted.values,lwd=2,col="darkorange",lty=1)
legend("topleft",legend=c("Wind","Hydro","Solar"),col=c("green","blue","darkorange"),pch=1)
```

We can clearly see that the electricity production coming from renewable sources is effectively growing and in particular wind is the one that is developing more than the others.


## Third Target: Analyse the current European renewable energy network.

One of the most important indicator to analyze if we are moving towards a “green future” is to investigate whether electricity power coming from renewable sources would be enough to satisfy picks of electricity demand, i.e. understand if the renewable energy network has sufficient production capacity, in terms of daily generated power (Megawatt).

### Regression on european electricity capacity

Let's plot some trends
```{r}
matplot(colnames(prod.by.fuel.total.p),t(prod.by.fuel.total.p[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Total electricity capacities")
```

```{r}
matplot(colnames(prod.by.fuel.comb.p),t(prod.by.fuel.comb.p[4:38,]),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from non-renewables")
```


```{r}
prod.by.fuel.renew.countries=prod.by.fuel.renew[-c(1,2,3),]
matplot(colnames(prod.by.fuel.renew.countries),t(prod.by.fuel.renew.countries),type='l',xlab="Year",ylab="Megawatt",main="Electricity capacities from renewables")
```

Which country is generating more power from renewables?
```{r}
idx_max=which.max(prod.by.fuel.renew.countries[,30])
rownames(prod.by.fuel.renew.countries)[idx_max]
```

Now let's perform different kinds of nonparametric regression to compare European trends of renewable vs non renewable electricity capacity
```{r}
years_90_19=as.numeric(colnames(prod.by.fuel.comb.p))
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European non-renewable electricity capacity",xlab="Year",ylab="Megawatt")
```

```{r}
m_list=lapply(1:10,function(degree){lm(as.numeric(prod.by.fuel.comb.p[2,]) ~ poly(as.numeric(years_90_19),degree=degree))})
do.call(anova,m_list)
```

Theorethically we should choose grade 9, since it's the last significant model, but we don't want to overfit, so let's analyze lower degrees
```{r}
summary(m_list[[2]])
```

```{r}
summary(m_list[[3]])

```

```{r}
summary(m_list[[6]])

```


```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[2]]$fitted.values,col="red")

```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[3]]$fitted.values,col="red")
```
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]),main="European Non Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[6]]$fitted.values,col="red")
```

Third grade polynomial regression seems reasonable

```{r}
comb_model=m_list[[3]]
```


Now let's move to renewables
```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
```

```{r}
m_list=lapply(1:10,function(degree){lm(as.numeric(prod.by.fuel.renew[2,]) ~ poly(as.numeric(years_90_19),degree=degree))})
do.call(anova,m_list)
```

Again, we don't want to overfit

```{r}
summary(m_list[[2]])

```

```{r}
summary(m_list[[4]])

```

```{r}
summary(m_list[[7]])

```

```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[2]]$fitted.values,col="green")
```

```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[4]]$fitted.values,col="green")
```


```{r}
plot(years_90_19,as.numeric(prod.by.fuel.renew[2,]),main="European Renewable Electricity Capacity",xlab="Year",ylab="Megawatt")
lines(years_90_19,m_list[[7]]$fitted.values,col="green")
```
Since by passing to fourth grade we only add one parameter w.r.t second grade (third grade coefficient is considered zero), we can consider the fourth grade regression.

But we can notice that the coefficient of fourth grade is negative! It's not really reasonable for future developments, so we stick to second grade


```{r}
ren_model=m_list[[2]]
```


```{r}
anni=seq(range(years_90_19)[1],range(years_90_19)[2],by=0.25)
preds=predict(comb_model,list(years_90_19=anni),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
plot(years_90_19 ,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni), ylim=range(as.numeric(prod.by.fuel.renew[2,]))+5000,cex =.5, col =" darkgrey ",main='Polynomial regression on european electricity capacity',xlab="Year",ylab="Megawatt")
lines(anni,preds$fit ,lwd =2, col =" red")
matlines (anni ,se.bands ,lwd =1, col =" red",lty =3)

preds=predict(ren_model,list(years_90_19=anni),se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ",pch=2)
lines(anni,preds$fit ,lwd =2, col =" green")
matlines (anni ,se.bands ,lwd =1, col =" green",lty =3)

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)
```

Let's also try with quadratic spline regression, with 5 knots evenly spaced, since a local approach should better captures the temporal local variations
```{r}
#combustible fuels
b=data.frame(cap=as.numeric(prod.by.fuel.comb.p[2,]),years_b=years_90_19)
comb_model_spline <- lm(cap ~ bs(years_b, df=7,degree=2), data=b )
dat_b=data.frame(years_b=anni)

preds=predict(comb_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

plot(years_90_19,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni),
    ylim=range(as.numeric(prod.by.fuel.renew[2,]))+5000,cex =.5, col =" darkgrey ",
    main="Splines regression on european electricity capacity",xlab="Year",ylab="Megawatt")

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)

lines(anni,preds$fit ,lwd =2, col =" red")
matlines(anni, se.bands ,lwd =1, col =" red",lty =3)

#renewables
c=data.frame(cap=as.numeric(prod.by.fuel.renew[2,]),years_b=years_90_19)
ren_model_spline <- lm(cap ~ bs(years_b, df=7,degree=2), data=c )
dat_b=data.frame(years_b=anni)

preds=predict(ren_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ")
lines(anni,preds$fit ,lwd =2, col =" green")
matlines(anni, se.bands ,lwd =1, col =" green",lty =3)
```

Natural cubic splines
```{r}
comb_model_spline <- lm(cap ~ ns(years_b, df=8), data=b )
dat_b=data.frame(years_b=anni)

preds=predict(comb_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

plot(years_90_19 ,as.numeric(prod.by.fuel.comb.p[2,]) ,xlim=range(anni) ,ylim=range(as.numeric(prod.by.fuel.renew[2,]))+3000,cex =.5, col =" darkgrey ",
     main="Natural Splines regression on european electricity capacity",xlab="Year",ylab="Megawatt")

legend("topleft",legend=c("Non-renewable","Renewable"),col=c(2,3),pch=1)

lines(anni,preds$fit ,lwd =2, col =" red")
matlines(anni, se.bands ,lwd =1, col =" red",lty =3)

ren_model_spline <- lm(cap ~ ns(years_b, df=7), data=c )
dat_b=data.frame(years_b=anni)

preds=predict(ren_model_spline,dat_b,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)

points(years_90_19 ,as.numeric(prod.by.fuel.renew[2,]) ,xlim=range(anni) ,cex =.5, col =" darkgrey ")
lines(anni,preds$fit ,lwd =2, col =" green")
matlines(anni, se.bands ,lwd =1, col =" green",lty =3)
```

Natural cubic splines seems the best approach.


### ANOVA test on 2019 capacities, dividing Europe in four regions

Now we set a region-based analysis of electricity capacity: we looked for different development of the renewable network in the four regions of Europe (North, East, South and Centre) with an anova test on 2019 relative capacities. These quantities were computed as the ratio between renewable and total capacities in order to take into account the country dimension. 

```{r}

countries=rownames(prod.by.fuel.renew.countries)

north_europe=c("Denmark","Estonia","Latvia","Lithuania","Finland","Sweden","Norway","Iceland","United Kingdom","Ireland")

east_europe=c("Bulgaria","Czechia","Hungary","Poland","Romania","Slovakia","Turkey","Ukraine")

south_europe=c("Greece","Spain","Italy","Cyprus","Malta","Portugal","Croatia","Slovenia","North Macedonia","Albania","Serbia")

central_europe=c("France","Belgium","Germany (until 1990 former territory of the FRG)","Luxembourg","Netherlands","Austria")

length(countries)==length(c(north_europe,south_europe,east_europe,central_europe))  #just to see correct division
```

Let's build the dataframe with groups attached, to perform an anova test on 2019 capacities
```{r}
north=prod.by.fuel.renew.countries[match(north_europe,countries),30]
east=prod.by.fuel.renew.countries[match(east_europe,countries),30]
south=prod.by.fuel.renew.countries[match(south_europe,countries),30]
central=prod.by.fuel.renew.countries[match(central_europe,countries),30]

north=cbind(north,rep("North",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("South",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_no_nuclear=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_no_nuclear)=c("cap_19","Region")
aov_no_nuclear$Region=factor(aov_no_nuclear$Region)
```

Let's build the ad-hoc dataframe with relative capacities of 2019
```{r}
north=prod.by.fuel.renew.countries[match(north_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(north_europe,countries),30])

east=prod.by.fuel.renew.countries[match(east_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(east_europe,countries),30])

south=prod.by.fuel.renew.countries[match(south_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(south_europe,countries),30])

central=prod.by.fuel.renew.countries[match(central_europe,countries),30]/(prod.by.fuel.total.p[4:38,][match(central_europe,countries),30])

north=cbind(north,rep("Northern",length(north)))
east=cbind(east,rep("Eastern",length(east)))
south=cbind(south,rep("Southern",length(south)))
central=cbind(central,rep("Central",length(central)))

aov_ratio_cap=data.frame(rbind(north,east,south,central),row.names=c(north_europe,east_europe,south_europe,central_europe))
colnames(aov_ratio_cap)=c("ratio_cap_19","Region")
aov_ratio_cap$Region=factor(aov_ratio_cap$Region)
```

```{r}
attach(aov_ratio_cap)
g=nlevels(aov_ratio_cap$Region)
g
boxplot(as.numeric(ratio_cap_19) ~ Region,col=c("cyan1","indianred1","cornflowerblue","chartreuse1"),main="Relative renewable electricity capacity by region",ylab="Percentage")
```

```{r}
ratio_cap_19=as.numeric(ratio_cap_19)
fit <- aov(ratio_cap_19 ~ Region)
T0 <- summary(fit)[[1]][1,4]

T_stat <- numeric(B) 
n <- dim(aov_ratio_cap)[1]
set.seed(seed)
for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n)
  cap_perm <- ratio_cap_19[permutation]
  fit_perm <- aov(cap_perm ~ Region)
  
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
```

```{r}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,main="F stat permutational distribution")
abline(v=T0,col=3,lwd=2)

plot(ecdf(T_stat),xlim=c(-1,20),main="F stat permutational ecdf")
abline(v=T0,col=3,lwd=4)

# p-value
sum(T_stat>=T0)/B
detach(aov_ratio_cap)
```

No statistical evidence of different development in different regions.

So to conclude this third analysis step, we can state, from the above results, that electricity capacity coming from renewable sources has surpassed non-renewable one around 2016 and that this improvement is uniformly distributed across the four regions of Europe since there is no evidence to say that a certain region is doing better thanthe other ones.


So the conclusion of the start point analysis is that:
“Europe is effectively undertaking a renewable transition... but is it fast enough?”


To answer to this question we are ready to enter in the core of our project that is to construct a robust model to predict future european Greenhouse gases emissions.

# Core: Model to predict future european GHG emissions
We have set ourselves the goal of predicting whether the Green Deal target of a 55% cut in greenhouse gases emissions by 2030 with respect to 1990 levels is feasible.

With the target to develop a model to predict future Greenhouse gases emissions as a function of the other energy indicators we had to previously construct a variety of auxiliary models to predict covariates values to be used in the final model.


Keeping only European countries for which we have complete data of Gdp, Population and Energy consumptions.
```{r}
# Not in SSP GDP data and in EUstat data
discard.idx <- rownames(consump.oil.petr.diff[-c(1,2,3),])%in%rownames(gdp.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(gdp.diff)

# Countries dataframe
consump.oil.petr.diff.s <- consump.oil.petr.diff[-1,]
consump.fossils.diff.s <- consump.fossils.diff[-1,]
consump.gas.diff.s <- consump.gas.diff[-1,]

colnames(consump.oil.petr.diff.s) <- consump.oil.petr.diff[1,]
colnames(consump.fossils.diff.s) <- consump.fossils.diff[1,]
colnames(consump.gas.diff.s) <- consump.gas.diff[1,]

# EU totals vectors
consump.oil.petr.diff.total <- consump.oil.petr.diff[3,]
consump.gas.diff.total <- consump.gas.diff[3,]
consump.fossils.diff.total <- consump.fossils.diff[3,]
consump.renew.diff.total <- consump.renew.diff[3,]

pop.diff <- pop.diff[discard.pop.idx,]

# Not in SSP GDP data and in EUstat data
discard.gdp.idx <- rownames(gdp.diff)%in%rownames(consump.oil.petr.diff)
discard.pop.idx <- rownames(pop.diff)%in%rownames(consump.oil.petr.diff)

gdp.diff <- gdp.diff[discard.gdp.idx,]
pop.diff <- pop.diff[discard.pop.idx,]

gdp.diff.total<-as.numeric(colSums(gdp.diff,na.rm=T))[1:40] #we have data until 2100,                                                               so we keep only until 2030
pop.diff.total<-as.numeric(colSums(pop.diff,na.rm=T))[1:40]

```


Since we are working with time series, where there is a strong temporal dependence, from now on each time we are constructing a model we check the correlation of the residuals using the (partial) autocorrelation function. This is important to understand whether the model is able to capture the relations in original data or whether it is better to perform a first order differentiation to mitigate the natural collinearity problem of these datasets. With this idea in mind, we initially fit the models with original data and then saw whether it is necessary or not to switch to yearly variations.


The first auxiliary models we fit aim to point predict year-to-year differences of the total European consumption from the three non-renewable sources (oil and petroleum products, solid fossil fuels and natural gas) in function of gdp, population and their interaction.

## EU_NON_RENEWABLE CONSUMPTIONS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION

This section includes three models, one for each non-renewable energy:
    - EU_PETROLEUM  ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
    - EU_SOLID FOSSIL FUELS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION
    - EU_NATURAL GAS ~ EU_GDP + EU_POPULATION + EU_GDP:EU_POPULATION

```{r}
gdp.train <- gdp.total[1:30] #from 1990 to 2019
pop.train <- pop.total[1:30]

gdp.pred <- gdp.total[31:41] #from 2020 to 2030
pop.pred <- pop.total[31:41]
```


```{r}
#Eu total data
vec_oil <- t(rbind(consump.oil.petr.europe,gdp.train,pop.train))
vec_oil <- data.frame(vec_oil)
colnames(vec_oil)=c("oil_eu","gdp_eu","pop_eu")

vec_oil_pred <- cbind(gdp.pred, pop.pred)
vec_oil_pred <- data.frame(vec_oil_pred)

colnames(vec_oil_pred) <- c("gdp_eu","pop_eu")

vec_fossil <- t(rbind(consump.fossils.europe,gdp.train, pop.train))
vec_fossil <- data.frame(vec_fossil)
colnames(vec_fossil)=c("fossil_eu","gdp_eu","pop_eu")

vec_fossil_pred=vec_oil_pred

vec_gas <- t(rbind(consump.gas.europe,gdp.train, pop.train))
vec_gas <- data.frame(vec_gas)
colnames(vec_gas)=c("gas_eu","gdp_eu","pop_eu")

vec_gas_pred=vec_oil_pred
```

### Oil & Petr.
```{r}
with(vec_oil,plot(gdp_eu,oil_eu))

with(vec_oil,plot(pop_eu,oil_eu))
```

```{r}
consump.oil.petr.gam <- gam(oil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') +s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

Let's see if we can discard the interaction term (residuals are gaussian)

```{r}
oil_petr_reduced=gam(oil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr'),
                           data = vec_oil)
anova(oil_petr_reduced,consump.oil.petr.gam,test="F")
```

so we can discard the interaction term

```{r}
consump.oil.petr.gam <- gam(oil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') ,
                           data = vec_oil) 
summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

```{r}
Acf(consump.oil.petr.gam$residuals)
```


```{r}
Pacf(consump.oil.petr.gam$residuals)
```


### Fossils
```{r}
with(vec_fossil,plot(gdp_eu,fossil_eu))

with(vec_fossil,plot(pop_eu,fossil_eu))
```

```{r}
consump.fossils.gam <- gam(fossil_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_fossil) 
summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```

```{r}
Acf(consump.fossils.gam$residuals)
```

```{r}
Pacf( 
  consump.fossils.gam$residuals
)
```

### Natural gas
```{r}
with(vec_gas,plot(gdp_eu,gas_eu))

with(vec_gas,plot(pop_eu,gas_eu))
```


```{r}
consump.gas.gam <- gam(gas_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)

```

Let's try to quit the interaction (residuals are gaussian, but simple anova doesn't work)
```{r}
gas_reduced=gam(gas_eu ~ s(pop_eu,bs='cr') + s(gdp_eu,bs='cr'),data=vec_gas)
anova(gas_reduced,consump.gas.gam,test="F") #doesn't print p_value!
```

```{r}
T0 <- summary.aov(aov(gam(gas_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas)))[[1]][3,4]

aov.H0= aov(gam(gas_eu ~ s(gdp_eu,bs='cr')  + s(pop_eu,bs='cr'),
                           data = vec_gas))
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)
for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),data = vec_gas)))[[1]][3,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```


We cannot discard the interaction, let's try with the gdp

```{r}
T0 <- summary.aov(aov(gam(gas_eu ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas)))[[1]][1,4]

aov.H0= aov(gam(gas_eu ~  s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),
                           data = vec_gas))
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)

for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(gdp_eu,bs='cr') + s(pop_eu,bs='cr') + s(I(gdp_eu*pop_eu),bs='cr'),data = vec_gas)))[[1]][1,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```
So we don't quit gdp either

```{r}
Acf(  consump.gas.gam$residuals
)
```

```{r}
Pacf(
  consump.gas.gam$residuals
)
```

Since the correlations are not negligible, we pass to first order differences

## DIFF_NON_RENEWABLE CONSUMPTIONS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION

    - DIFF_EU_PETROLEUM  ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION
    - DIFF_EU_SOLID FOSSIL FUELS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION
    - DIFF_EU_NATURAL GAS ~ DIFF_EU_GDP + DIFF_EU_POPULATION + DIFF_EU_GDP:DIFF_EU_POPULATION

```{r}
gdp.train <- gdp.diff.total[1:29]
pop.train <- pop.diff.total[1:29]

gdp.pred  <- gdp.diff.total[30:40]
pop.pred  <- pop.diff.total[30:40]
```




```{r}

vec_oil.diff <- t(rbind(consump.oil.petr.diff.total,gdp.train,pop.train))
vec_oil.diff <- data.frame(vec_oil.diff)
colnames(vec_oil.diff) <- c("dif_oil_eu","dif_gdp_eu","dif_pop_eu")

# Variables to predict oil
vec_oil_pred.diff <- cbind(gdp.pred, pop.pred)
vec_oil_pred.diff <- data.frame(vec_oil_pred.diff)

colnames(vec_oil_pred.diff) <- c("dif_gdp_eu","dif_pop_eu")

vec_fossil.diff <- t(rbind(consump.fossils.diff.total,gdp.train, pop.train))
vec_fossil.diff <- data.frame(vec_fossil.diff)
colnames(vec_fossil.diff) <- c("dif_fossil_eu","dif_gdp_eu","dif_pop_eu")

# Variables to predict ff
vec_fossil_pred.diff = vec_oil_pred.diff

colnames(vec_fossil_pred.diff) <- c("dif_gdp_eu","dif_pop_eu")

vec_gas.diff <- t(rbind(consump.gas.diff.total,gdp.train, pop.train))
vec_gas.diff <- data.frame(vec_gas.diff)
colnames(vec_gas.diff) <- c("dif_gas_eu","dif_gdp_eu","dif_pop_eu")

# Variables to predict gas
vec_gas_pred.diff=vec_fossil_pred.diff

```




### Oil & Petr.
```{r}
with(vec_oil.diff,plot(dif_gdp_eu,dif_oil_eu))
with(vec_oil.diff,plot(dif_pop_eu,dif_oil_eu))

```


```{r}

consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_oil.diff) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

We try to quit the interaction term (residuals are gaussian, but simple anova doesn't work)

```{r}
T0 <- summary.aov(aov(gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_oil.diff) ))[[1]][3,4]

aov.H0= aov(gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') ,data = vec_oil.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_oil.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)

for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_oil.diff) ))[[1]][3,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

So we can quit the interaction term
```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_oil.diff) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

Let's try to quit pop too (residuals are gaussian)
```{r}
oil_reduced=gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') ,data = vec_oil.diff)
anova(oil_reduced,consump.oil.petr.gam,test="F")
```
So we can quit population too

```{r}
consump.oil.petr.gam <- gam(dif_oil_eu ~ s(dif_gdp_eu,bs='cr') ,data = vec_oil.diff) 

summary(consump.oil.petr.gam)

hist(consump.oil.petr.gam$residuals)
qqnorm(consump.oil.petr.gam$residuals)
shapiro.test(consump.oil.petr.gam$residuals)
```

Let's try to quit the smooth terms, one at a time

```{r}
#linear interaction
consump.oil.petr.gam.1 <- lm(dif_oil_eu ~ bs(dif_gdp_eu) + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,data = vec_oil.diff) 

summary(consump.oil.petr.gam.1)

hist(consump.oil.petr.gam.1$residuals)
qqnorm(consump.oil.petr.gam.1$residuals)
shapiro.test(consump.oil.petr.gam.1$residuals)
```
```{r}
#linear pop
consump.oil.petr.gam.2 <- lm(dif_oil_eu ~ bs(dif_gdp_eu) + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff) 

summary(consump.oil.petr.gam.2)

hist(consump.oil.petr.gam.2$residuals)
qqnorm(consump.oil.petr.gam.2$residuals)
shapiro.test(consump.oil.petr.gam.2$residuals)
```

```{r}
#linear gdp
consump.oil.petr.gam.3 <- gam(dif_oil_eu ~ dif_gdp_eu + bs(dif_pop_eu)+ bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

The third one seems promising, let's try to quit population from it (residuals are gaussian)

```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu + bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff)
anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```

We can quit pop

```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu +  bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

Can we quit the interaction? (gaussian residuals)
```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu ,data = vec_oil.diff) 
anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```

Yes, we quit it
```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu ,data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

Let's try to quit two smooth terms at a time
```{r}
consump.oil.petr.gam.1 <- lm(dif_oil_eu ~ dif_gdp_eu + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,data = vec_oil.diff) 

summary(consump.oil.petr.gam.1)

hist(consump.oil.petr.gam.1$residuals)
qqnorm(consump.oil.petr.gam.1$residuals)
shapiro.test(consump.oil.petr.gam.1$residuals)
```

```{r}
consump.oil.petr.gam.2 <- lm(dif_oil_eu ~ dif_gdp_eu + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,data = vec_oil.diff) 

summary(consump.oil.petr.gam.2)

hist(consump.oil.petr.gam.2$residuals)
qqnorm(consump.oil.petr.gam.2$residuals)
shapiro.test(consump.oil.petr.gam.2$residuals)
```

```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

From the third let's try to reduce the interaction degree to one (residuals are gaussian)

```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu),degree=1),data = vec_oil.diff) 
anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```

We can
```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu),degree=1),data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```

Should we quit the interaction? (gaussian residuals)

```{r}
oil_reduced=lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu,data = vec_oil.diff)

anova(oil_reduced,consump.oil.petr.gam.3,test="F")
```
Quit it

```{r}
consump.oil.petr.gam.3 <- lm(dif_oil_eu ~ dif_gdp_eu + dif_pop_eu ,data = vec_oil.diff) 

summary(consump.oil.petr.gam.3)

hist(consump.oil.petr.gam.3$residuals)
qqnorm(consump.oil.petr.gam.3$residuals)
shapiro.test(consump.oil.petr.gam.3$residuals)
```


```{r}
consump.oil.petr.gam=consump.oil.petr.gam.3

Acf(  consump.oil.petr.gam$residuals
)
Pacf(
  consump.oil.petr.gam$residuals
)
```

Note that it is quite strange that we should not reject the null hypothesis of the fundamental test of significance, while we reject the null hypothesis of the singular tests. Since the p-value of the fundamental test is just slightly above 0.05, we overlook this fact and consider this as the final model for the oil and petroleum products.

### Fossils

```{r}
with(vec_fossil.diff,plot(dif_gdp_eu,dif_fossil_eu))
with(vec_fossil.diff,plot(dif_pop_eu,dif_fossil_eu))
```


```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_fossil.diff) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```

Let's try to quit the interaction (residuals are gaussian)

```{r}
fossil_reduced=gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') ,data = vec_fossil.diff)
anova(fossil_reduced,consump.fossils.gam,test="F")
```

We can quit the interaction term

```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_fossil.diff) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```

Let's try to quit gdp as well (residuals are gaussian, but simple anova doesn't work)
```{r}
T0 <- summary.aov(aov(gam(dif_fossil_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') ,data = vec_fossil.diff) ))[[1]][1,4]

aov.H0= aov(gam(dif_fossil_eu ~ s(dif_pop_eu,bs='cr') ,data = vec_fossil.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_fossil.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)

for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr'),data = vec_fossil.diff) ))[[1]][1,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit gdp
```{r}
consump.fossils.gam <- gam(dif_fossil_eu ~ s(dif_pop_eu,bs='cr'),data = vec_fossil.diff) 

summary(consump.fossils.gam)

hist(consump.fossils.gam$residuals)
qqnorm(consump.fossils.gam$residuals)
shapiro.test(consump.fossils.gam$residuals)
```

```{r}
Acf( 
  consump.fossils.gam$residuals
)
```

```{r}
Pacf( 
  consump.fossils.gam$residuals
)
```



### Natural gas
```{r}
with(vec_gas.diff,plot(dif_gdp_eu,dif_gas_eu))
with(vec_gas.diff,plot(dif_pop_eu,dif_gas_eu))
```

```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_gdp_eu,bs='cr') + s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas.diff) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```

Let's try to quit gdp (residuals are gaussian)
```{r}
gas_reduced=gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),data = vec_gas.diff)
anova(gas_reduced,consump.gas.gam,test="F")
```

We can quit gdp

```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') + s(I(dif_gdp_eu*dif_pop_eu),bs='cr'),
                           data = vec_gas.diff) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```


Trying to quit interaction as well (residuals are gaussian)
```{r}
gas_reduced=gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr') ,data = vec_gas.diff)
anova(gas_reduced,consump.gas.gam,test="F")
```

We can quit the interaction too

```{r}
consump.gas.gam <- gam(dif_gas_eu ~ s(dif_pop_eu,bs='cr'), data = vec_gas.diff) 
summary(consump.gas.gam)

hist(consump.gas.gam$residuals)
qqnorm(consump.gas.gam$residuals)
shapiro.test(consump.gas.gam$residuals)
```

Let's try again with some linear contributions

```{r}
#linear interaction
consump.gas.gam.1 <- lm(dif_gas_eu ~ bs(dif_gdp_eu) + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.1)

hist(consump.gas.gam.1$residuals)
qqnorm(consump.gas.gam.1$residuals)
shapiro.test(consump.gas.gam.1$residuals)
```

```{r}
#linear pop
consump.gas.gam.2 <- lm(dif_gas_eu ~ bs(dif_gdp_eu) + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) 
summary(consump.gas.gam.2)

hist(consump.gas.gam.2$residuals)
qqnorm(consump.gas.gam.2$residuals)
shapiro.test(consump.gas.gam.2$residuals)
```

```{r}
#linear gdp
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu) + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```
From the third one, let's try to quit the interaction (residuals are gaussian, but simple anova doesn't work)


```{r}
T0 <- summary.aov(aov(lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu) + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) ))[[1]][3,4]

aov.H0= aov(lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu) ,
                           data = vec_gas.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)

for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(lm(risposta.perm.H0 ~ dif_gdp_eu + bs(dif_pop_eu) + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) ))[[1]][3,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit the interaction

```{r}
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu),
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

Let's try to quit population (residual are not gaussian)
```{r}
T0 <- summary.aov(aov(lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu),
                           data = vec_gas.diff) ))[[1]][2,4]

aov.H0= aov(lm(dif_gas_eu ~ dif_gdp_eu ,
                           data = vec_gas.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)

for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(lm(risposta.perm.H0 ~ dif_gdp_eu + bs(dif_pop_eu),
                           data = vec_gas.diff) ))[[1]][2,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit population

```{r}
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

We quit two smooth terms at a time

```{r}
#linear pop and interaction
consump.gas.gam.1 <- lm(dif_gas_eu ~ bs(dif_gdp_eu) + dif_pop_eu + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.1)

hist(consump.gas.gam.1$residuals)
qqnorm(consump.gas.gam.1$residuals)
shapiro.test(consump.gas.gam.1$residuals)
```

```{r}
#linear gdp and interaction
consump.gas.gam.2 <- lm(dif_gas_eu ~ dif_gdp_eu + bs(dif_pop_eu) + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.2)

hist(consump.gas.gam.2$residuals)
qqnorm(consump.gas.gam.2$residuals)
shapiro.test(consump.gas.gam.2$residuals)
```

```{r}
#linear gdp and pop
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

From the third one let's try to quit the interaction (residuals are not gaussian)

```{r}
T0 <- summary.aov(aov(lm(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) ))[[1]][3,4]

aov.H0= aov(lm(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu,data = vec_gas.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)

for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(lm(risposta.perm.H0 ~ dif_gdp_eu + dif_pop_eu + bs(I(dif_gdp_eu*dif_pop_eu)),
                           data = vec_gas.diff) ))[[1]][3,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We can quit the interaction

```{r}
consump.gas.gam.3 <- lm(dif_gas_eu ~ dif_gdp_eu + dif_pop_eu ,
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

We try to quit population too (residuals are gaussian)
```{r}
gas_reduced=lm(dif_gas_eu ~ dif_gdp_eu,
                           data = vec_gas.diff)
anova(gas_reduced,consump.gas.gam.3,test="F")
```

We can quit population too

```{r}
consump.gas.gam.3 <- gam(dif_gas_eu ~ dif_gdp_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.3)

hist(consump.gas.gam.3$residuals)
qqnorm(consump.gas.gam.3$residuals)
shapiro.test(consump.gas.gam.3$residuals)
```

No good..., from the number one let's try to quit gdp
```{r}
summary(consump.gas.gam.1)
shapiro.test(consump.gas.gam.1$residuals)
```

Residuals are not gaussian
```{r}
T0 <- summary.aov(aov(lm(dif_gas_eu ~bs(dif_gdp_eu) + dif_pop_eu + dif_gdp_eu:dif_pop_eu ,data = vec_gas.diff) ))[[1]][1,4]

aov.H0= aov(lm(dif_gas_eu ~  dif_pop_eu + dif_gdp_eu:dif_pop_eu ,data = vec_gas.diff) )
#aov.H0
residuals.H0 <- aov.H0$residuals
n = dim(vec_gas.diff)[1]
T_perm<- numeric(B)

pb <- progress_bar$new(
    format = "  processing [:bar] :percent eta: :eta",
    total = B, clear = FALSE)
pb$tick(0)
B=1000
set.seed(seed)

for(perm in 1:B){
  permutation <- sample(n)
  residuals.H0 <- residuals.H0[permutation]
  risposta.perm.H0 <- aov.H0$fitted + residuals.H0
  T_perm[perm] <- summary.aov(aov(gam(risposta.perm.H0 ~ bs(dif_gdp_eu) + dif_pop_eu + dif_gdp_eu:dif_pop_eu,data = vec_gas.diff) ))[[1]][1,4] 
pb$tick
}
p_val=sum(T_perm>= T0)/B
p_val
```

We quit gdp
```{r}
consump.gas.gam.1 <- lm(dif_gas_eu ~  dif_pop_eu + dif_gdp_eu:dif_pop_eu,
                           data = vec_gas.diff) 
summary(consump.gas.gam.1)

hist(consump.gas.gam.1$residuals)
qqnorm(consump.gas.gam.1$residuals)
shapiro.test(consump.gas.gam.1$residuals)
```

Finally!!!
```{r}
consump.gas.gam=consump.gas.gam.1
```


### Predictions for 2020-2030
```{r}
#summary of the three models
summary(consump.oil.petr.gam)
summary(consump.fossils.gam)
summary(consump.gas.gam)
```


```{r}
# Preds (2020-2030)

consump.oil.petr.gam.preds <- predict(consump.oil.petr.gam, newdata=vec_oil_pred.diff, se=T)

consump.fossils.gam.preds <- predict(consump.fossils.gam, newdata=vec_fossil_pred.diff, se=T)

consump.gas.gam.preds <- predict(consump.gas.gam, newdata=vec_gas_pred.diff, se=T)
```


Plot regression
```{r}
#oil
gdp.grid=with(vec_oil.diff,seq(min(dif_gdp_eu),max(dif_gdp_eu),length.out=100))
pop.grid=with(vec_oil.diff,seq(min(dif_pop_eu),max(dif_pop_eu),length.out=100))
grid.oil=expand.grid(gdp.grid,pop.grid)
names(grid.oil)=c('dif_gdp_eu','dif_pop_eu')


preds_oil=predict(consump.oil.petr.gam,newdata=grid.oil)
persp3d(gdp.grid,pop.grid,preds_oil,col='darkolivegreen1',border="white",lwd=0.1,xlab="dif_gdp",ylab="dif_pop",alpha=0.5)
with(vec_oil.diff, points3d(dif_gdp_eu ,dif_pop_eu ,dif_oil_eu ,col='black',size=10))
```

```{r}
#fossils
preds_ff=predict(consump.fossils.gam,newdata=grid.oil)
persp3d(gdp.grid,pop.grid,preds_ff,col='gray50',border="white",lwd=0.1,xlab="dif_gdp",ylab="dif_pop",alpha=0.5)
with(vec_fossil.diff, points3d(dif_gdp_eu ,dif_pop_eu ,dif_fossil_eu ,col='black',size=10))
```


```{r}
#gas
preds_gas=predict(consump.gas.gam,newdata=grid.oil)
persp3d(gdp.grid,pop.grid,preds_gas,col='gainsboro',border="white",lwd=0.1,xlab="dif_gdp",ylab="dif_pop",alpha=0.5)
with(vec_gas.diff, points3d(dif_gdp_eu ,dif_pop_eu ,dif_gas_eu ,col='black',size=10))
```

Plot predictions
```{r}
with(vec_oil.diff, plot(seq(1991,2019) ,dif_oil_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoules" , col =" darkgrey ",main='Prediction - Oil & Petr.'))
points(seq(2020,2030), consump.oil.petr.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.oil.petr.gam$fitted.values,lwd=1,col="blue")
lines(seq(1991,2030),rep(0,length(seq(1991,2030))),lty=2,lwd=1,col =" darkgrey ")


with(vec_fossil.diff, plot(seq(1991,2019) ,dif_fossil_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoules" , col =" darkgrey ",main='Prediction - Fossil Fuels'))
points(seq(2020,2030), consump.fossils.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.fossils.gam$fitted.values,lwd=1,col="blue")
lines(seq(1991,2030),rep(0,length(seq(1991,2030))),lty=2,lwd=1,col =" darkgrey ")



with(vec_gas.diff, plot(seq(1991,2019) ,dif_gas_eu ,xlim=c(1991,2030),cex =1,xlab="Year",ylab="Terajoules" , col =" darkgrey ",main='Prediction - Natural Gas'))
points(seq(2020,2030), consump.gas.gam.preds$fit ,lwd =2, col ="red")
lines(seq(1991,2019),consump.gas.gam$fitted.values,lwd=1,col="blue")
lines(seq(1991,2030),rep(0,length(seq(1991,2030))),lty=2,lwd=1,col =" darkgrey ")


```

We proceeded with yearly variations framework also for the following models

The second auxiliary model we fit is the one that finds a relationship between the renewable energy consumptions and the non-renewable ones.

## DIFF_EU_RENEWABLE CONSUMPTIONS  ~ DIFF_EU_PETROLEUM  + DIFF_EU_SOLID FOSSILFUELS + DIFF_EU_NATURAL GAS + interactions

```{r}
# Join all energies for common DF
vec_re <- cbind(as.numeric(consump.renew.diff.total[1,]),vec_oil.diff$dif_oil_eu,vec_fossil.diff$dif_fossil_eu, vec_gas.diff$dif_gas_eu)

vec_re <- data.frame(vec_re)
colnames(vec_re) <- c("value_re", "value_oil", "value_ff", "value_ng")
```

We need smoothing also on oil,fossil fuels and natural gas differences, to fit a more complex mode with interactions

```{r}
rownames(vec_re)=years_90_19[2:30]
vec_re.temp=t(vec_re)
vec_re.s=smoothing_procedure(vec_re.temp,1991,2019,interval=3)
rownames(vec_re.s)=rownames(vec_re.temp)
vec_re.s=data.frame(t(vec_re.s))
```

```{r}
with(vec_re.s,plot(value_oil,value_re,main="Diff renewables vs diff oil"))
with(vec_re.s,plot(value_ff,value_re,main="Diff renewables vs diff fossil fuels"))
with(vec_re.s,plot(value_ng,value_re,main="Diff renewables vs diff natural gas"))

```



```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil,bs='cr') + s(value_ff,bs='cr') + s(value_ng,bs='cr') + s(I(value_oil*value_ff),bs='cr') + s(I(value_ff*value_ng),bs='cr') + s(I(value_oil*value_ng),bs='cr') + s(I(value_oil*value_ff*value_ng),bs='cr'), data=vec_re.s)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```

Let's try to quit natural gas and oil - fossil fuels interaction (residuals are gaussian)

```{r}
ren_reduced=gam(value_re ~ s(value_oil, bs = "cr") + s(value_ff, bs = "cr")  + s(I(value_ff * value_ng), bs = "cr") +s(I(value_oil * value_ng), bs = "cr") + s(I(value_oil *value_ff * value_ng), bs = "cr"),
                data = vec_re.s)
anova(ren_reduced,consump.renew.gam,test="F")
```

We can quit them

```{r}
consump.renew.gam <- gam(value_re ~ s(value_oil, bs = "cr") + s(value_ff, bs = "cr")  + s(I(value_ff * value_ng), bs = "cr") +s(I(value_oil * value_ng), bs = "cr") + s(I(value_oil *value_ff * value_ng), bs = "cr"),
                data = vec_re.s)

summary(consump.renew.gam)

hist(consump.renew.gam$residuals)
qqnorm(consump.renew.gam$residuals)
shapiro.test(consump.renew.gam$residuals)
```


```{r}
Acf(consump.renew.gam$residuals)
```



```{r}
Pacf(consump.renew.gam$residuals)
```

Unfortunately we have correlated residuals at one step, but as before we think this is due to the smoothing we had to apply in order to fit this model.

### Predictions for 2020-2030
```{r}
oil.preds.s=data.frame(t(consump.oil.petr.gam.preds$fit))
colnames(oil.preds.s)=seq(2020,2030)
oil.preds.s=smoothing_procedure(oil.preds.s,2020,2030,interval=3)

ff.preds.s=data.frame(t(consump.fossils.gam.preds$fit))
colnames(ff.preds.s)=seq(2020,2030)
ff.preds.s=smoothing_procedure(ff.preds.s,2020,2030,interval=3)

gas.preds.s=data.frame(t(consump.gas.gam.preds$fit))
colnames(gas.preds.s)=seq(2020,2030)
gas.preds.s=smoothing_procedure(gas.preds.s,2020,2030,interval=3)
```



```{r}
vec_re_pred <- t(rbind(oil.preds.s,ff.preds.s, gas.preds.s))
vec_re_pred <- data.frame(vec_re_pred)
colnames(vec_re_pred) <- c("value_oil", "value_ff", "value_ng")


consump.renew.gam.preds <- predict(consump.renew.gam, newdata=vec_re_pred, se=T)
```


Plot prediction
```{r}
# See graphs
with(vec_re, plot(seq(1991,2019) ,value_re ,xlim=c(1991,2030),cex=.5,xlab="Year",ylab="Terajoules" , col =" darkgrey ",main='Prediction - Renewable Energy Consumption'))
points(seq(2020,2030,1/3), consump.renew.gam.preds$fit ,cex=1, col ="red")
lines(seq(1991,2019,1/3),consump.renew.gam$fitted.values,col="blue",lwd=1)
lines(seq(1991,2030,1/3),rep(0,length(seq(1991,2030,1/3))),lwd=1,lty=2,col =" darkgrey ")

```



```{r}
renew.predictions=data.frame(t(consump.renew.gam.preds$fit))
colnames(renew.predictions)=seq(2020,2030,1/3)
renew.predictions=renew.predictions[1,as.character(seq(2020,2030))]
```

```{r}
(renew.predictions.total=consump.renew.europe[,30]+cumsum(as.numeric(renew.predictions)))
```

Having fit these auxiliary models, we could develop our final model for the prediction of future variations of Greenhouse gases emissions, until 2030. 

## DIFF_TOTAL_GHG ~  DIFF_TOTAL_RENEWABLE CONSUMPTION

```{r}
ghg=read.xlsx("data/ghg_emissions.xlsx", sheet=3, colNames=F)

ghg <- na.omit(ghg) # Remove NA values

ghg <- data.frame(lapply(ghg, as.numeric)) # Set cells as numeric
ghg=data.frame(t(ghg))
rownames(ghg) <- years_90_19

colnames(ghg)="ValueGhg"

head(ghg)

```



```{r}
plot(years_90_19,ghg$ValueGhg,xlab="Years",ylab="Percentage emissions",main="Percentage of Ghg emissions wrt 1990")
```



```{r}
ghg.diff=data.frame(diff_ghg=diff(ghg$ValueGhg))
```

```{r}
plot(seq(1991,2019),ghg.diff$diff_ghg,xlab="Years",ylab="Percentage emissions",main="Variations of percentage of Ghg emissions wrt 1990")
```


```{r}
#using differences for covariates
vec_ghg.diff= cbind(ghg.diff$diff_ghg,vec_re$value_re)
vec_ghg.diff <- data.frame(vec_ghg.diff)
vec_ghg_pred.diff <- data.frame(t(renew.predictions))

colnames(vec_ghg.diff) <- c("value_ghg", "value_re")
colnames(vec_ghg_pred.diff)="value_re"

```


```{r}
with(vec_ghg.diff,plot(value_re,value_ghg,main="Diff ghg vs diff renewables"))

```



```{r}

ghg.gam <- gam(value_ghg ~ s(value_re,bs='cr'), data=vec_ghg.diff)

summary(ghg.gam)

hist(ghg.gam$residuals)
qqnorm(ghg.gam$residuals)
shapiro.test(ghg.gam$residuals)
```

The gam machinery suggest us that it is sufficient to use a simple linear model!
```{r}
ghg.l <- lm(value_ghg ~ value_re, data=vec_ghg.diff)

summary(ghg.l)

hist(ghg.l$residuals)
qqnorm(ghg.l$residuals)
shapiro.test(ghg.l$residuals)
```


```{r}
Acf(ghg.l$residuals,main="Residuals Acf")
```

```{r}
Pacf(ghg.l$residuals,main="Residuals Pacf")
```


Plot Regression

```{r}
newdata=with(vec_ghg.diff,seq(min(value_re),max(value_re),by=1))
newdata=data.frame(value_re=newdata)
ghg.reg=predict(ghg.l,newdata=newdata,se=T)
se.bands=cbind(ghg.reg$fit +2* ghg.reg$se.fit ,ghg.reg$fit -2* ghg.reg$se.fit)

with(vec_ghg.diff,plot(value_re,value_ghg,main="Diff ghg vs diff renewables"))
lines(newdata$value_re,ghg.reg$fit,col="green",lwd=2)
matlines(newdata$value_re,se.bands,col="green",lwd=1,lty=2)

```


### Predicted decrease

How much is the predicted decrease?


```{r}
#predictions
ghg.l.preds <- predict(ghg.l, newdata=vec_ghg_pred.diff, se=T)

with(vec_ghg.diff, plot(seq(1991,2019) ,value_ghg ,xlim=c(1990,2030),cex =.7,pch=19,xlab="Year",ylab="Diff percentage" , col =" darkgrey ",main='Prediction - Ghg Emissions'))
points(seq(2020,2030),ghg.l.preds$fit ,cex=0.7,pch=19, col ="green")
lines(seq(1991,2019),ghg.l$fitted.values,lwd=2,col="green")
lines(seq(1991,2030,1/3),rep(0,length(seq(1991,2030,1/3))),col="darkgrey",lty=2)
```


```{r}
#predicted decrease
deltas=as.numeric(ghg.l.preds$fit)
Percentage_emissions=ghg[30,1]+cumsum(deltas)
Percentage_decrease=as.numeric(100-Percentage_emissions[11])

Percentage_emissions
Percentage_decrease

```

A cut of 32.32% is expected with the actual rhythm, so much more effort is needed in order to comply with the Green Deal objective!


```{r}
with(ghg, plot(seq(1990,2019) ,ValueGhg ,xlim=c(1990,2030),ylim=c(40,100),cex =.7,pch=19,xlab="Year",ylab="Percentage" ,main='Prediction - Ghg Emissions'))
points(seq(2020,2030),Percentage_emissions,cex=.7,col="red",pch=19)
lines(seq(1990,2030),rep(45,length(seq(1990,2030))),lty=2,lwd=2,col="green")
```


Let's also compute the conformal prediction intervals

```{r}

train_gam_ghg <- function(x,y,out=NULL){
    colnames(x)=c("value_re")
    train_data=data.frame(y,x)
    
    model_gam= gam(y ~ s(value_re,bs='cr'), 
    data = train_data)
}


predict_gam_ghg <- function(obj, new_x){
    new_x=data.frame(new_x)
    colnames(new_x)=c("value_re")
    as.numeric(predict(obj,new_x))
}

c_preds.ghg <- conformal.pred(
    vec_ghg.diff[,2], 
    vec_ghg.diff[,1],
    as.matrix(vec_ghg_pred.diff[,1]),
    alpha=0.05, 
    verbose=F, 
    train.fun = train_gam_ghg, 
    predict.fun = predict_gam_ghg)
```

```{r}
plot(seq(1991,2019), vec_ghg.diff$value_ghg, xlim=range(c(1990,2030)),cex =.7,pch=19,xlab="Year",ylab="Diff percentage",col =" darkgrey ",main='Conformal prediction - Ghg Emissions',ylim=c(-10,10))

points(seq(2020,2030),c_preds.ghg$pred,cex=0.7,pch=19 ,col ="green")
lines(seq(2020,2030),c_preds.ghg$up,lwd =2, col =" blue",lty =3)
lines(seq(2020,2030),c_preds.ghg$lo, lwd =2, col =" blue",lty =3)
lines(seq(1991,2019),c_preds.ghg$fit, lwd =2, col =" green",lty =1)
lines(seq(1991,2030),rep(0,length(seq(1991,2030))),col="darkgrey",lty=2,lwd=1)
```


```{r}
lo_perc=ghg[30,1]+cumsum(c_preds.ghg$lo)
up_perc=ghg[30,1]+cumsum(c_preds.ghg$up)
for (i in 1:11){
  lo_perc[i]=max(0,lo_perc[i])
  up_perc[i]=min(100,up_perc[i])

}

with(ghg, plot(seq(1990,2019) ,ValueGhg ,xlim=c(1990,2030),ylim=c(0,100),cex =.5,xlab="Year",ylab="Percentage" , col =" darkgrey ",main='Prediction - Ghg Emissions'))
points(seq(2020,2030),Percentage_emissions,cex=.5,col="green")
lines(seq(1990,2030),rep(45,length(seq(1990,2030))),col="darkgrey",lty=2)
lines(seq(2020,2030),lo_perc,col="green",lty=2)
lines(seq(2020,2030),up_perc,col="green",lty=2)
```

# Robustness

In our project, we wanted to include a part about robustness methods applied to our datasets. Even though during the course’s lectures all the methods regarding robust statistics were applied to multivariate datasets with no temporal correlation, some of the concepts can be used in our project to try to infer more information on our dataset.

Two specific methods were used in our code: Minimum Covariance Determinant and Robust regression.

WARNING: during this section, when talking about energy datasets, we are using the year-to-year differences unless specified otherwise

```{r echo = T, results = 'hide'}
library(robustbase)
library(psych)
library(MASS)
library(ellipse)
library(here)
library(DescTools)
library(knitr)
library(RobStatTM)
```


## a. Test for COUNTRY outliers in diff dataset 

Objective: Try to spot the most extreme cases (countries) in our dataset(s), where our tests could struggle the most. 

```{r}
# Standarization on differences of each country since MCD depends on Mahalannobis distance 
sd.consump.ff.diff <- t(scale(t(consump.fossils.diff.s)))
sd.consump.oil.diff <- t(scale(t(consump.oil.petr.diff.s)))
sd.consump.gas.diff <- t(scale(t(consump.gas.diff.s)))

sd.consump.renew.diff <- t(scale(t(consump.renew.diff[-1,])))

sd.pop.diff <- t(scale(t(pop.diff[,1:29])))
sd.gdp.diff <- t(scale(t(gdp.diff[,1:29])))

matplot(t(sd.consump.ff.diff), type="l")
matplot(t(sd.consump.oil.diff), type="l")
matplot(t(sd.consump.gas.diff), type="l")

matplot(t(sd.consump.renew.diff), type="l")

matplot(t(sd.gdp.diff), type="l")
matplot(t(sd.pop.diff), type="l")
```


```{r}
### MCD on dataset of various energies

alpha <- .75
```


### a.1. For Non-renewable energy consumption

This approach consists in representing each country as an independent sample of p dimensions, but this time, p corresponds to the value of each energy type for each year (N=Countries, p=energy sources).
This would mean we would obtain several country outliers for each year. A possible approach to join the information on outliers for all years would be counting how many times each country has been classified as an outlier. This way we would obtain a rank of the most outlying countries in our dataset.
Since for MCD to be applied we need a multivariate dataset, we need to combine at least two energy sources.
We try this method on the Non-Renewable energy sources (Fossil fuels, Oil & Petroleum and Natural Gas). 

```{r}
## N -> countries
## p -> diff. type of energies/datum
# (E.g. for 1991)

sd.consump.nr.1991 <- data.frame(cbind(sd.consump.ff.diff[,1], sd.consump.gas.diff[,1], sd.consump.oil.diff[,1])) # Combine all NR energy consumptions for 1991
colnames(sd.consump.nr.1991) <- c("FF", "Gas", "Oil") 
rownames(sd.consump.nr.1991) <- rownames(sd.consump.ff.diff)
sd.consump.nr.1991 <- na.omit(sd.consump.nr.1991) # Discard Cyprus and Iceland with NA values in Gas consump.

fit_MCD.2 <- covMcd(x = sd.consump.nr.1991, alpha = alpha, nsamp = "best")

mcd_best.2 <- fit_MCD.2$best

N <- nrow(sd.consump.nr.1991)
p <- ncol(sd.consump.nr.1991)
pairs(sd.consump.nr.1991[,1:3], col=ifelse(fit_MCD.2$mcd.wt,"black","red"), pch=19)

# Which are the outliers?
rownames(sd.consump.nr.1991)[!(1:N%in%mcd_best.2)]
# And the cases considered outliers from distance plots?
rownames(sd.consump.nr.1991)[!(fit_MCD.2$mcd.wt)]
```


```{r}
## Try the former method for each year 1991 - 2019 to see which is the most repeated outliers

nr_outliers_mcd <- function(year, alpha=.75,plott=F){
    year <- 2020-year
    sd.consump.nr.aux <- data.frame(cbind(sd.consump.ff.diff[,year], sd.consump.gas.diff[,year], sd.consump.oil.diff[,year])) # Combine all NR energy consumptions for 1991
    colnames(sd.consump.nr.aux) <- c("FF", "Gas", "Oil") 
    rownames(sd.consump.nr.aux) <- rownames(sd.consump.ff.diff)
    sd.consump.nr.aux <- na.omit(sd.consump.nr.aux) # Discard Cyprus and Iceland with NA values in Gas consump.
    
    fit_MCD.aux <- covMcd(x = sd.consump.nr.aux, alpha = alpha, nsamp = "best")
    
    mcd_best.aux <- fit_MCD.aux$best
    
    N <- nrow(sd.consump.nr.aux)
    p <- ncol(sd.consump.nr.aux)
    if(plott==T){
        plot(fit_MCD.aux)
    }
    
    # Which are the outliers?
   return(rownames(sd.consump.nr.aux)[!(fit_MCD.aux$mcd.wt)])
}

# Test for 1991
nr_outliers_mcd(1991,plott=T)
nr_outliers_mcd(1992)

outliers <- NULL
for(i in 1991:2019){
    outliers <- c(outliers, nr_outliers_mcd(i))
}

# Get 5 most repeated outlying countries in non-renewable energies
outl_occ <- table(outliers)
outl_occ.sort <- outl_occ[order(outl_occ, decreasing = T)]
outl_occ.sort[1:5] # Top 5 outliers
```


```{r}
### Plots

top5.outl <- which(rownames(sd.consump.ff.diff) %in% names(outl_occ.sort[1:5])) # Get top 5 most repeated outliers
# For the 1991 data, we can colour this top outliers as:
pairs(sd.consump.nr.1991[,1:3], col=ifelse(1:N%in%top5.outl,"red","black"), pch=19)

# Mahalannobis distance plots,
# Distance distance plots,
# QQplots
# Scree plot
plot(fit_MCD.2, classic=TRUE)

```

This section is quite useful from an analytic point of view, but not quite for our Core part of the project, since we use no specific country information in our final prediction models.


We wonder if it is also possible to search for outliers on the year axis. In particular, having a dataset composed of year to year differences of different energy sources (i.e. columns as years and rows as energy sources), we will try to detect which year(s) had anomalous data with respect to the rest of the data.

This would mean transposing our data matrix (now the columns would be energy sources and the rows each of the years) and we treating each row as an observation for which we would want to detect outliers. This would be interpreted as years for which we had an anomalous growth (or decrease) wrt the rest of the years.


A problem arises from this last proposal: should we include in the year axis the predicted values for future values? We will try both options, but we should take into account that NOT including the future values would mean we could try to extract the outliers from our original dataset and retrain our models from a “new” dataset.
## b.1 Test for YEAR outliers with predictions

O&P + FF + NG (training + prediction)

```{r}
nr.past.preds <- data.frame(
    scale(c(t(consump.oil.petr.diff.total),consump.oil.petr.gam.preds$fit)), 
    scale(c(t(consump.fossils.diff.total),consump.fossils.gam.preds$fit)),
    scale(c(t(consump.gas.diff.total),consump.gas.gam.preds$fit)))

rownames(nr.past.preds) <- seq(1991,2030)
colnames(nr.past.preds) <- c("oil.petr", "ff", "ng")
```


```{r}
## N -> each year 
## p -> NR energy sources 
alpha <- .75
fit_MCD.4 <- covMcd(x = nr.past.preds, alpha = alpha, nsamp = "best")
plot(fit_MCD.4)

mcd_best.4 <- fit_MCD.4$best

N <- nrow(nr.past.preds)
p <- ncol(nr.past.preds)
plot(nr.past.preds, col=ifelse(1:N%in%mcd_best.4,"black","red"),pch=19)

# Which are the most n - alpha*n "outlying" data?
rownames(nr.past.preds)[!(1:N%in%mcd_best.4)]
# And the cases considered outliers from distance plots?
rownames(nr.past.preds)[!(fit_MCD.4$mcd.wt)]
```

```{r}
plot(seq(1991,2030), nr.past.preds[,1], col=ifelse(fit_MCD.4$mcd.wt,"black","red"),pch=19,ylab="Oil&Petr.")
plot(seq(1991,2030), nr.past.preds[,2], col=ifelse(fit_MCD.4$mcd.wt,"black","red"),pch=19,ylab="Fossil Fuels")
plot(seq(1991,2030), nr.past.preds[,3], col=ifelse(fit_MCD.4$mcd.wt,"black","red"),pch=19,ylab="Natual Gas")
```
There is a clear swamping effect going on since not all 9 years seem to be real outliers. The year with index 20 is a clear outlier while indices 16, 19 or 17 could also be considered as outliers, but by inspecting individual plots, does not look like it.


## b.2. Test for YEAR outliers without predictions

Let's try to find outlying years from our Non-Renewable consumption data which is the base of our prediction models.
After finding outlying years the idea is to retrain our models and compare them to our original ones.

### b.2.1. Outliers in NRE (training data)

The idea behind this part is to retrain our models without the outliers in our original dataset.


```{r}
nre.diff.sd.total <- data.frame(
    scale(t(consump.oil.petr.diff.total)), 
    scale(t(consump.fossils.diff.total)),
    scale(t(consump.gas.diff.total))
)

rownames(nre.diff.sd.total) <- seq(1991,2019)
colnames(nre.diff.sd.total) <- c("oil.petr", "ff", "ng")
```


```{r}
## N -> each year 
## p -> NR energy sources 
alpha <- .75
fit_MCD.7 <- covMcd(x = nre.diff.sd.total, alpha = alpha, nsamp = "best")
plot(fit_MCD.7)

mcd_best.7 <- fit_MCD.7$best

N <- nrow(nre.diff.sd.total)
p <- ncol(nre.diff.sd.total)
plot(nre.diff.sd.total, col=ifelse(1:N%in%mcd_best.7,"black","red"),pch=19)

# Which are the most n - alpha*n "outlying" data?
rownames(nre.diff.sd.total)[!(1:N%in%mcd_best.7)]
# Which should be considered outliers?
rownames(nre.diff.sd.total)[!(fit_MCD.7$mcd.wt)]
```

There is a clear swamping going on if we take all 1-alpha outlying data since we can only see two years in the distance plot that could be tagged as outliers (not all 7). This can also be seen in the individual plots of NRE energies

```{r}
plot(seq(1991,2019), nre.diff.sd.total[,1], col=ifelse(fit_MCD.7$mcd.wt,"black","red"),pch=19,ylab="Oil&Petr.")
plot(seq(1991,2019), nre.diff.sd.total[,2], col=ifelse(fit_MCD.7$mcd.wt,"black","red"),pch=19,ylab="Fossil Fuels")
plot(seq(1991,2019), nre.diff.sd.total[,3], col=ifelse(fit_MCD.7$mcd.wt,"black","red"),pch=19,ylab="Natural Gas")

```

We select years with index 21 and 24 as outliers:
```{r}
outl.nre.train <- c(21, 24)
rownames(nre.diff.sd.total)[outl.nre.train]
```

There is a problem we face when going into the next section of retraining the model without the year outliers. This comes from the fact that Renewable differences predictions are created directly from Non renewable consumptions differences.

To obtain future predictions for Renewable consumptions we must use the future predictions for Non-renewable consumptions. So when choosing outliers for the Non-renewable consumption data should we use the MCD method on the original dataset, or on the combination of original+predictions dataset (as in b.1.1).

Both have been done already. With the second one we obtain 7 outliers, while with the first methodology we obtain 2. Inspecting the indiviudal graphs and the distance-distance plots, we can assume that it is better to choose the outliers detected in the current section since the 2011 and 2014 yearly NRE consumptions are much clearer outliers than extra ones detected in the b.1.1. section.

We can infer that the extra outliers from section b.1.1. are selected as such because of the extra-centrality that the predictions of NRE consumptions add to the dataset. It is clear that a swamping effect is taking place because some variabilities are amplified and falsely tagged as outlying. 

### b.2.2. Redo DIFF_RENEWABLES ~ DIFF_NONRENEWABLES model

```{r}
# Join all energies for common DF
vec_re.rob <- cbind(as.numeric(consump.renew.diff.total[1,]),vec_oil.diff$dif_oil_eu, vec_fossil.diff$dif_fossil_eu, vec_gas.diff$dif_gas_eu)

vec_re.rob <- data.frame(vec_re)[-outl.nre.train,] # Discard Outlying data
colnames(vec_re.rob) <- c("value_re", "value_oil", "value_ff", "value_ng")
```

Smoothing procedure

```{r}
vec_re.rob.temp=t(vec_re.rob)
vec_re.rob.s.1=smoothing_procedure(vec_re.rob.temp, 1991, 1990+outl.nre.train[1]-1,interval=3)
vec_re.rob.s.2=smoothing_procedure(vec_re.rob.temp, 1990+outl.nre.train[1]+1, 1990+outl.nre.train[2]-1,interval=3)
vec_re.rob.s.3=smoothing_procedure(vec_re.rob.temp, 1990+outl.nre.train[2]+1, 2019,interval=3)

vec_re.rob.s = cbind(vec_re.rob.s.1, vec_re.rob.s.2, vec_re.rob.s.3)

rownames(vec_re.rob.s)=rownames(vec_re.rob.temp)
vec_re.rob.s=data.frame(t(vec_re.rob.s))
```

```{r}
with(vec_re.rob.s,plot(value_oil,value_re,main="Diff ren vs diff oil"))
with(vec_re.rob.s,plot(value_ff,value_re,main="Diff ren vs diff ff"))
with(vec_re.rob.s,plot(value_ng,value_re,main="Diff ren vs diff ng"))

```


```{r}
consump.renew.gam.rob <- gam(value_re ~ s(value_oil,bs='cr') + s(value_ff,bs='cr') + s(value_ng,bs='cr') + s(I(value_oil*value_ff),bs='cr') + s(I(value_ff*value_ng),bs='cr') + s(I(value_oil*value_ng),bs='cr') + s(I(value_oil*value_ff*value_ng),bs='cr'), data=vec_re.rob.s)

summary(consump.renew.gam.rob)

hist(consump.renew.gam.rob$residuals)
qqnorm(consump.renew.gam.rob$residuals)
shapiro.test(consump.renew.gam.rob$residuals)
```

Let's test whether oil and oil-fossil fuels interaction are needed (gaussian residuals)

```{r}
ren_rob_reduced= gam(value_re ~ s(value_ff,bs='cr') + s(value_ng,bs='cr') + s(I(value_ff*value_ng),bs='cr') + s(I(value_oil*value_ng),bs='cr') + s(I(value_oil*value_ff*value_ng),bs='cr'), data=vec_re.rob.s)
anova(ren_rob_reduced,consump.renew.gam.rob,test="F")
```

We can discard them

```{r}
consump.renew.gam.rob <- gam(value_re ~  s(value_ff,bs='cr') + s(value_ng,bs='cr') +  s(I(value_ff*value_ng),bs='cr') + s(I(value_oil*value_ng),bs='cr') + s(I(value_oil*value_ff*value_ng),bs='cr'), data=vec_re.rob.s)

summary(consump.renew.gam.rob)

hist(consump.renew.gam.rob$residuals)
qqnorm(consump.renew.gam.rob$residuals)
shapiro.test(consump.renew.gam.rob$residuals)
```

Let's test whether oil-natural gas interaction is needed (gaussian residuals) 

```{r}
ren_rob_reduced= gam(value_re ~ s(value_ff,bs='cr') + s(value_ng,bs='cr') + s(I(value_ff*value_ng),bs='cr') + s(I(value_oil*value_ff*value_ng),bs='cr'), data=vec_re.rob.s)
anova(ren_rob_reduced,consump.renew.gam.rob,test="F")
```

We cannot quit this interaction, so we have our model

```{r}
Acf(consump.renew.gam.rob$residuals)
```

```{r}
Pacf(consump.renew.gam.rob$residuals)
```

Get predictions

```{r}
# Smoothing of oil, ff and gas already in oil.preds.s, ff.preds.s, gas.preds.s

vec_re_pred.rob <- t(rbind(oil.preds.s,ff.preds.s, gas.preds.s))
vec_re_pred.rob <- data.frame(vec_re_pred.rob)
colnames(vec_re_pred.rob) <- c("value_oil", "value_ff", "value_ng")


consump.renew.gam.preds.rob <- predict(consump.renew.gam.rob, newdata=vec_re_pred.rob, se=T)
```

Plot prediction
```{r}
with(vec_re.rob, plot(rownames(vec_re.rob) ,value_re ,xlim=c(1991,2030),cex=.5,xlab="Year",ylab="Terajoules" , col =" darkgrey ",main='Robust prediction - Renewable Energy Consumption'))
points(seq(2020,2030,1/3), consump.renew.gam.preds.rob$fit ,cex=1, col ="red")
lines(rownames(vec_re.rob.s),consump.renew.gam.rob$fitted.values,col="blue",lwd=1)
lines(seq(1991,2030,1/3),rep(0,length(seq(1991,2030,1/3))),lwd=1,lty=2,col =" darkgrey ")

```

```{r}
renew.predictions.rob=data.frame(t(consump.renew.gam.preds.rob$fit))
colnames(renew.predictions.rob)=seq(2020,2030,1/3)
renew.predictions.rob=renew.predictions.rob[1,as.character(seq(2020,2030))]
```



### b.2.3. Redo DIFF_GHG ~ DIFF_RENEWABLES model

Create train dataset from new predictions with renewable sources without outlying years
```{r}
vec_ghg.diff.2 <- cbind(ghg.diff$diff_ghg[-outl.nre.train], vec_re.rob$value_re)
vec_ghg.diff.2 <- data.frame(vec_ghg.diff.2)
vec_ghg_pred.diff.2 <- data.frame(t(renew.predictions.rob))

rownames(vec_ghg.diff.2)=rownames(vec_re.rob)
colnames(vec_ghg.diff.2) <- c("value_ghg", "value_re")
colnames(vec_ghg_pred.diff.2)="value_re"
```


```{r}
ghg.gam.2 <- gam(value_ghg ~ s(value_re, bs='cr'), data=vec_ghg.diff.2)

summary(ghg.gam.2)

hist(ghg.gam.2$residuals)
qqnorm(ghg.gam.2$residuals)
shapiro.test(ghg.gam.2$residuals)
```

The GAM machinery still suggest us to use a linear model, however unfortunately now the model is not significant at 5%.

```{r}
ghg.l.2 <- lm(value_ghg ~ value_re, data=vec_ghg.diff.2)

summary(ghg.l.2)

hist(ghg.l.2$residuals)
qqnorm(ghg.l.2$residuals)
shapiro.test(ghg.l.2$residuals)

```

```{r}
ghg.rob <- ghg.l.2

ghg.rob.preds <- predict(ghg.rob, newdata=vec_ghg_pred.diff.2, se=T)

```

### b.2.4. Comparison with original models

Plot new vs past predictions of RE ~ NRE:
```{r}
seq.outl <- c(seq(1991,1990+outl.nre.train[1]-1),
              seq(1990+outl.nre.train[1]+1, 1990+outl.nre.train[2]-1),
              seq(1990+outl.nre.train[2]+1, 2019))
seq.outl.s <- c(seq(1991,1990+outl.nre.train[1]-1, 1/3),
              seq(1990+outl.nre.train[1]+1, 1990+outl.nre.train[2]-1, 1/3),
              seq(1990+outl.nre.train[2]+1, 2019, 1/3))

# Plot previous predictions
with(vec_re, plot(seq(1991,2019) ,value_re ,xlim=c(1991,2030),cex=.5,xlab="Year",ylab="Terajoules" , col =" darkgrey ",main='Prediction - Renewable Energy Consumption'))
points(seq(2020,2030,1/3), consump.renew.gam.preds$fit ,cex=1, pch=16, col ="blue")
lines(seq(1991,2019,1/3),consump.renew.gam$fitted.values,col="blue",lwd=2)

# Plot new "robust" predictions
points(1990+outl.nre.train, vec_re$value_re[outl.nre.train], col =" black ",pch=16) # Outliers
points(seq(2020,2030,1/3), consump.renew.gam.preds.rob$fit ,cex=1, pch=17, col ="orchid")
lines(seq.outl.s,consump.renew.gam.rob$fitted.values,col="orchid",lwd=2)

lines(seq(1991,2030,1/3),rep(0,length(seq(1991,2030,1/3))),lwd=1,lty=2,col =" darkgrey ")

legend("topright",legend=c("Old fit","New fit","Old predictions","New predictions","Outliers"),col=c("blue","orchid","blue","orchid","black"),pch=c(16,16,16,17,16))

```

Plot regression GHG ~ RE
```{r}
newdata=with(vec_ghg.diff, seq(min(value_re), max(value_re),by=1))
newdata=data.frame(value_re=newdata)
ghg.reg.rob=predict(ghg.rob, newdata=newdata,se=T)
se.bands.rob=cbind(ghg.reg.rob$fit +2* ghg.reg.rob$se.fit ,ghg.reg.rob$fit -2* ghg.reg.rob$se.fit)

with(vec_ghg.diff,plot(value_re,value_ghg,main="Diff ghg vs diff renewables"))
# Previous regression
lines(newdata$value_re,ghg.reg$fit,col="green",lwd=2)
matlines(newdata$value_re,se.bands,col="green",lwd=1,lty=2)
# New regression
lines(newdata$value_re, ghg.reg.rob$fit, col="darkgreen", lwd=2)
matlines(newdata$value_re, se.bands.rob, col="darkgreen", lwd=1, lty=2)

legend("topright",legend=c("Old regression","New regerssion"),col=c("green","darkgreen"),pch=c(16,16))

```

Plot new vs past predictions of GHG ~ RE:

```{r}
# Plot previous predictions
with(vec_ghg.diff, plot(seq(1991,2019) ,value_ghg ,xlim=c(1990,2030),cex =.5,xlab="Year",ylab="Percentage" , col =" darkgrey ",main='Prediction - Ghg Emissions'))
points(seq(2020,2030),ghg.l.preds$fit ,cex=1, pch=16, col ="green")
lines(seq(1991,2019),ghg.l$fitted.values,lwd=2,col="green")
lines(seq(1991,2030,1/3),rep(0,length(seq(1991,2030,1/3))),col="darkgrey",lty=2)

# Plot new "robust" predictions
points(1990+outl.nre.train,vec_ghg.diff.2$value_ghg[outl.nre.train],xlim=c(1990,2030),cex =.5,col =" darkgrey ")
points(seq(2020,2030),ghg.rob.preds$fit ,cex=1, pch=17, col ="darkgreen")
lines(seq.outl,ghg.rob$fitted.values,lwd=2,col="darkgreen")

legend("bottomright",legend=c("Old fit","New fit","Old predictions","New predictions"),col=c("green","darkgreen","green","darkgreen"),pch=c(16,16,16,17))

```


```{r}

deltas.rob=as.numeric(ghg.rob.preds$fit)
Percentage_emissions.rob=ghg[30,1]+cumsum(deltas.rob)
Percentage_decrease.rob=as.numeric(100-Percentage_emissions.rob[11])

Percentage_emissions.rob
Percentage_decrease.rob

```

Plot predictions
```{r}
with(ghg, plot(seq(1990,2019) ,ValueGhg ,xlim=c(1990,2030),ylim=c(40,100),cex =.7,xlab="Year",ylab="Percentage" ,pch=16, col =" darkgrey ",main='Prediction - Ghg Emissions'))
points(seq(2020,2030),Percentage_emissions,cex=1,pch=16,col="red")
points(seq(2020,2030), Percentage_emissions.rob, cex=1,pch=17,col="coral")
lines(seq(1990,2030),rep(45,length(seq(1990,2030))),col="green",lty=2,lwd=2)

legend("topright",legend=c("Old predictions","New predictions"),col=c("red","coral"),pch=16)
```

Fortunately predictions look very similar to the ones made on the complete datasets, both visually and numerically.

## c. Robust linear models

Idea: use Robust Linear models on our final predictor i.e. GHG ~ RE. This makes a lot of sense since our original model is a linear one. We expect for these models to act not too worse than the original lm. This means we will try to obtain inference by using this methods and our original data: NOT the "robust" dataset(s)

We will be applying the Least Median Squares (LMS) and Least Trimmed Squares (LTS) models, covered during the course. For the former, we will use the lmsreg(.) function, while for the latter we will use the lmrob(.) function.

Contrary to the course’s labs, we decide to use lmrob(.) instead of ltsReg(.) following the robustbase package documentation’s advice (ref): "We strongly recommend using lmrob(.) instead of ltsReg(.) 

### c.1. LMS + LTS on final model 

Lets take our original predictions for renewable energy consumption from the Core part of our project.

```{r}
plot(vec_ghg.diff)
```


Now, let's look how robust linear regressors act with this data and compare it with the original LM model:

LMS
```{r}
fit_lms <- lmsreg(value_ghg ~ value_re, data = vec_ghg.diff)

hist(fit_lms$residuals)
qqnorm(fit_lms$residuals)
shapiro.test(fit_lms$residuals)
```

```{r}
Acf(fit_lms$residuals,main="Residuals Acf")

Pacf(fit_lms$residuals,main="Residuals Pacf")
```

LTS
```{r}
fit_lts <- lmrob(value_ghg ~ value_re, data = vec_ghg.diff, alpha=.5)

summary(fit_lts)

hist(fit_lts$residuals)
shapiro.test(fit_lts$residuals)

plot(fit_lts)
```
```{r}
Acf(fit_lts$residuals,main="Residuals Acf")

Pacf(fit_lts$residuals,main="Residuals Pacf")
```

Sum of square residuals for each estimator and R-squared
```{r}
sum(ghg.l$residuals^2)
sum(fit_lms$residuals^2)
sum(fit_lts$residuals^2)


summary(ghg.l)
summary(fit_lts)
```


Plot original regression vs new regressions
```{r}
newdata=with(vec_ghg.diff,seq(min(value_re),max(value_re),by=1))
newdata=data.frame(value_re=newdata)

newdata.rob = with(vec_ghg.diff,seq(min(value_re),max(value_re),by=200)) 
newdata.rob =data.frame(value_re=newdata.rob)

ghg.reg.lms=predict(fit_lms, newdata=newdata.rob, se=T)
ghg.reg.lts=predict(fit_lts, newdata=newdata.rob, se=T)
se.bands.lts=cbind(ghg.reg.lts$fit +2* ghg.reg.lts$se.fit ,ghg.reg.lts$fit -2* ghg.reg.lts$se.fit)
```


```{r}
with(vec_ghg.diff,plot(value_re,value_ghg,main="Diff ghg vs diff renewables"))

lines(newdata$value_re, ghg.reg$fit, col="green",lwd=2)
matlines(newdata$value_re, se.bands,col="green",lwd=1,lty=2)

lines(newdata.rob$value_re, ghg.reg.lms,col="blue",lwd=2)

lines(newdata.rob$value_re, ghg.reg.lts$fit,col="orchid",lwd=2)
matlines(newdata.rob$value_re, se.bands.lts, col="orchid",lwd=1,lty=2)

legend("topright",legend=c("Old fit","Lms","Lts"),col=c("green","blue","orchid"),pch=16)
```

The LTS model seems to be very similar by looking at the graph above. And their Sum of Square residuals is also very close, while the LMS estimator yields a worse fit of our data.

But by looking at the Adjusted R-squared of the LM model, it has a higher value (0.13) than the LTS model (0.08).

Even though it seems that our LTS model will not improve our original LM model, let us take a look at its predictions:

```{r}
#predictions
ghg.lts.preds <- predict(fit_lts, newdata=vec_ghg_pred.diff, se=T)

with(vec_ghg.diff, plot(seq(1991,2019) ,value_ghg ,xlim=c(1990,2030),cex =.7,pch=19,xlab="Year",ylab="Diff percentage" , col =" darkgrey ",main='Prediction - Ghg Emissions'))
# Original Predictions
points(seq(2020,2030),ghg.l.preds$fit ,cex=0.7,pch=19, col ="green")
lines(seq(1991,2019),ghg.l$fitted.values,lwd=2,col="green")
# New predictions LTS
points(seq(2020,2030),ghg.lts.preds$fit ,cex=0.7,pch=19, col ="orchid")
lines(seq(1991,2019),fit_lts$fitted.values,lwd=2,col="orchid")

lines(seq(1991,2030,1/3),rep(0,length(seq(1991,2030,1/3))),col="darkgrey",lty=2)

legend("topright",legend=c("Old fit","Lts"),col=c("green","orchid"),pch=16)
```


```{r}

deltas.lts=as.numeric(ghg.lts.preds$fit)
Percentage_emissions.lts=ghg[30,1]+cumsum(deltas.lts)
Percentage_decrease.lts=as.numeric(100-Percentage_emissions.lts[11])

Percentage_emissions.lts
Percentage_emissions
c(Percentage_decrease.lts, Percentage_decrease)

```

```{r}
with(ghg, plot(seq(1990,2019) ,ValueGhg ,xlim=c(1990,2030),ylim=c(40,100),cex =.7,pch=19,xlab="Year",ylab="Percentage" ,main='Prediction - Ghg Emissions'))
points(seq(2020,2030),Percentage_emissions, cex=.7,col="red",pch=19)
points(seq(2020,2030),Percentage_emissions.lts,cex=.7,col="coral",pch=19)
lines(seq(1990,2030),rep(45,length(seq(1990,2030))),lty=2,lwd=2,col="green")
legend("topright",legend=c("Old predictions","New predictions"),col=c("red","coral"),pch=19)
```


We find that the predictions obtained by using the LTS estimator are almost the same, even a little more conservative since the decrease is a little less tilted than the LM one.

From this section's LTS model, which tries to robustify a linear model, we find that, since only one outlier (index 19) is trimmed away, there is almost no difference between our original LM model and this new one. 

This could be understood as the possibility for our project to choose the LTS model as a final predictor for the GHG emissions. A balanced approach between robustness and accuracy should be taken into account. Both models seem valid enough.

Even the predictions made by quitting the outliers from the non-renewable sources datasets are still very similar to the one obtained with the original data, so all this evidence makes us confidently say that our models and predictions are quite robust, since they are not influenced that much by the presence of outlying observations.